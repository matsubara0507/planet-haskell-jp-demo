<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Planet Haskell (JP)</title><id>https://matsubara0507.github.io/planet-haskell-jp-demo/feed.xml</id><updated>2018-06-06T01:11:48.468+09:00</updated><link href="https://matsubara0507.github.io/planet-haskell-jp-demo"/><entry><id>https://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html</id><title type="text">[linux][cygwin] unzipコマンドで "error:  invalid compressed data to inflate" というエラーメッセージがでたら？</title><updated>2018-06-06T01:11:48.468+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html"/><summary type="text">zipアーカイブの中に長さが0のファイルが含まれていると、unzipコマンドでは以下のようなエラーメッセージが表示されて、解凍することができません。アーカイブが壊れていなくてもエラーになります。
% unzip hoge.zip
  error:  invalid compressed data to inflate

このような場合には、-tzipオプションを指定して7zコマンドを実行することで、エラーを回避して解凍できます。パスワード保護されているzipアーカイブも問題なく解凍できました。

% 7z x -tzip hoge.zip


manページによると、以下のフォーマットがサポートされていて、デフォルトは7zとのこと。

The program supports 7z (that implements  LZMA  compression  algorithm),  
ZIP</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2018/06/03/195024</id><title type="text">日持ちする直列化のためのライブラリ「winery」</title><updated>2018-06-04T00:57:20+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2018/06/03/195024"/><summary type="html">人類は、酒と共に発展してきたと言っても過言ではない。穀物や果実などを酒に変換することにより、糖を除く栄養を保ったまま、高い保存性を持たせることができる。酒は人々の喉を潤し、時に薬として使われた。 プログラミングにおいても、終了したら消えてしまうデータを、保存性の高いバイト列に変えたい場面がよくある。そのような操作を直列化(シリアライズ)と呼び、いくつかのアプローチが存在する。 コード生成タイプ Protocol Buffers、cap'n'protoなど データの構造を記述する言語(スキーマ)から、データ構造およびシリアライザ・デシリアライザをコードごと生成する。幅広い言語で使える一方、作れる…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/06/02/181649</id><title type="text">今日は第15回 Cloud Application Platformアーキテクチャの日です</title><updated>2018-06-02T18:16:49+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/06/02/181649"/><summary type="html">今日は第15回 Cloud Application Platformアーキテクチャの日です 第15回 Cloud Application Platformアーキテクチャ にお邪魔しています。 Cloud Application Platformアーキテクチャ / asami224 さん ディスカッション用のスライドです Cloud Application Platformのコンセプト Web DSL DSLという言葉は聞かなくなったが、また戻ってくる アプリバブルは終わった。WEBに戻ってきた WEB開発はGUI開発の歴史を繰り返しそう JSは型がないのでバグがとれない。 lint は限界があ…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/05/26/144115</id><title type="text">Dist::Milla で cpanfile に書かれた依存モジュールの解決</title><updated>2018-05-26T15:42:39+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/05/26/144115"/><summary type="html">チュートリアル にも書いてないし、やった記憶もない。昔からこうだっけ？ $ milla listdeps | cpanm 依存モジュールが入ったら、 milla build とか milla test とか。 Test::Pod とか必要だったら、 listdeps に --author とかつければ良い。</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2018/05/24/213324</id><title type="text">We Are JavaScripters! @19th で Haskell 製フレームワーク Miso について話してきました</title><updated>2018-05-24T21:33:24+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2018/05/24/213324"/><summary type="html">先日行われた We Are JavaScripters! @19th で Haskell によるフロントエンド開発について発表してきました。 Elm の代わりにフレームワーク Miso を使うことで、クライアントサイドとサーバサイドの両方を Haskell で実装することができる、という内容です。 github.com なお今回のプレゼンでは、参加者のほとんどは Haskell に馴染みがないだろう*1ということもあって、実装上の詳細にはほとんど触れませんでした。 Elm と Miso の詳しい比較、さらに Servant と組み合わせた Isomorphic なアプリの作り方については、記事…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/05/20/183734</id><title type="text">windowでGCPのcloud shellを使う</title><updated>2018-05-20T18:37:34+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/05/20/183734"/><summary type="html">windows の chrome で GCP の cloud shell を使おうとすると、 Ctrl-t, Ctrl-n, Ctrl-w あたりをブラウザのショートカットに食われて発狂しそうになって困ってたんだけど、 SSH for Google Cloud Platform で解決できることを知った。 ちなむと gcloud alpha cloud-shell も試したんだけど、puttyが Server refused our key とか言い出して何もできなかった。実にアルファ版らしい。 cloud shell は tmux をデフォルトで有効にしてくれるのだけど、デフォルトではステー…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2018/05/18/205101</id><title type="text">JAWS DAYS 2018 で形式手法による IAM の検証について話してきました</title><updated>2018-05-18T20:51:01+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2018/05/18/205101"/><summary type="html">だいぶ日が空いてしまって今更ですが、先日行われた JAWS DAYS 2018 で登壇してきました*1。モデル検査器 Alloy を使って AWS の IAM を検証してみるという内容です。 形式手法 × AWS というテーマではこれまでにもいくつかのイベントで発表していますが、題材はネットワーク関連の検証がメインでした。 ccvanishing.hateblo.jp ccvanishing.hateblo.jp ccvanishing.hateblo.jp さすがに同じことばかり話していても芸がないので、今回は新ネタとして IAM を投入してみました。CFP も Security Slot …</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2018/05/17/180426</id><title type="text">Kubernetes Meetup Tokyo #10 で Pod の Preemption について話してきました</title><updated>2018-05-17T18:04:26+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2018/05/17/180426"/><summary type="html">だいぶ日が空いてしまって今更ですが、先日行われた Kubernetes Meetup Tokyo #10 で、v1.9 から導入された新機能 Preemption について発表してきました。 Preemption は、Kubernetes クラスタのリソースが不足した際に、優先度が低い Pod を追い出して優先度が高い Pod の稼働を保証する仕組みです。 当日は時間が不足気味だったので、説明不十分だったかなと思われる点についていくつか補足しておきます。 Priority の指定について スライド中では詳しく説明しませんでしたが、ユーザは直接 Pod（や Deployment 中の Pod T…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/07/31/090000</id><title type="text">ptraceシステムコール入門 ― プロセスの出力を覗き見してみよう！</title><updated>2018-05-14T18:45:57+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/07/31/090000"/><summary type="html">他のプロセスを中断せずに、その出力をミラーリングして新しくパイプで繋ぐ、そんなことはできるのでしょうか。 straceやgdbといったコマンドは一体どういう仕組みで動いているのでしょうか。 ptraceシステムコールを使い、プロセスが呼ぶシステムコールを調べて出力を覗き見するコマンドを実装してみたいと思います。 ptraceシステムコール Linuxを触っていると、いかにプロセスを組み合わせるか、組み合わせる方法をどれだけ知っているかが重要になってきます。 パイプやリダイレクトを使ってプロセスの出力結果を制御したり、コードの中からコマンドを実行して、終了ステータスを取得したりします。 プロセス…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html</id><title type="text">Haskell で型安全に YAML ファイルをビルド時に埋め込む</title><updated>2018-05-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Haskell で型安全に YAML ファイルをビルド時に埋め込む&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-05-13" itemprop="datePublished"&gt;
        May 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/haskell.html"&gt;haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;ザックリ言えば「&lt;a href="https://ryota-ka.hatenablog.com/entry/2018/02/14/103000"&gt;Template Haskell でコード中に JSON を埋め込んだりコンパイル時にファイルから型安全に読み込んだりする - ryota-ka’s blog&lt;/a&gt;」という記事の YAML 版です．&lt;/p&gt;
&lt;p&gt;ただし，ryota さんの記事では Template Haskell を解説しながら JSON を読み込む関数を定義していますが， YAML 版は &lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt; パッケージに同様の関数が既にあるので特に解説はしません． あくまでも Haskell の型システムとメタプログラミングを感じてもらえたらなぁと．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ソースコードは全てこの&lt;a href="https://github.com/matsubara0507/sample-yaml-th"&gt;リポジトリ&lt;/a&gt;にまとめてある．&lt;/p&gt;
&lt;h1 id="yaml-を埋め込む"&gt;YAML を埋め込む&lt;/h1&gt;
&lt;p&gt;次のような設定ファイルに関する型があったとします．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yaml パッケージで YAML にデコードするためには &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; の &lt;a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:FromJSON"&gt;&lt;code&gt;FromJSON&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスである必要がある． &lt;code&gt;FromJSON&lt;/code&gt; のインスタンスに凝ってもしょうがないので，今回は &lt;code&gt;Generics&lt;/code&gt; を使って適当に定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Generics&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Config&lt;/code&gt; 型のデフォルト値を YAML ファイルで記述したいとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="fu"&gt;languageExtensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これをコンパイル時に埋め込んでかつ型検査も行いたい． そのためには Template Haskell と yaml パッケージの &lt;a href="https://hackage.haskell.org/package/yaml-0.8.30/docs/Data-Yaml-TH.html#v:decodeFile"&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt;&lt;/a&gt; 関数を用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;decodeFile ::&lt;/span&gt; (&lt;span class="dt"&gt;Lift&lt;/span&gt; a, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; a) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; (&lt;span class="dt"&gt;TExp&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;TExp a&lt;/code&gt; 型というのは型付きの &lt;code&gt;Exp&lt;/code&gt; 型らしいが，ぼくはあまりよく分からないので割愛． 型を見ればわかるように，&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにもなってなきゃいけない． &lt;code&gt;DerivingLift&lt;/code&gt; 言語拡張を使えば簡単に定義できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveLift #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; import &lt;span class="dt"&gt;Language.Haskell.TH.Syntax&lt;/span&gt; &lt;span class="co"&gt;-- template-haskell package&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;, &lt;span class="dt"&gt;Lift&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使い方は簡単で，次のようにすればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="ot"&gt;defaultConfig ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;defaultConfig &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$$&lt;/span&gt;(decodeFile &lt;span class="st"&gt;&amp;quot;./template/.config.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点として，Template Haskell の制約より &lt;code&gt;Config&lt;/code&gt; 型の定義と &lt;code&gt;defaultConfig&lt;/code&gt; 関数の定義は別ファイルに分けなければいけない．&lt;/p&gt;
&lt;h2 id="試す"&gt;試す&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; defaultConfig
Config {columns = 80, languageExtensions = []}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;試しに間違えてみよう&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat template/.config.yaml
column: 80
languageExtensions: []
$ stack build
sample-yaml-th-0.1.0.0: build (lib)
Preprocessing library for sample-yaml-th-0.1.0.0..
Building library for sample-yaml-th-0.1.0.0..
[1 of 2] Compiling Sample.Config.Internal ( src\Sample\Config\Internal.hs, .stack work\dist\5c8418a7\build\Sample\Config\Internal.o )
[2 of 2] Compiling Sample.Config    ( src\Sample\Config.hs, .stack-work\dist\5c8418a7\build\Sample\Config.o )

C:\Users\hoge\haskell\sample-yaml-th\src\Sample\Config.hs:14:20: error:
    • Aeson exception:
Error in $: key &amp;quot;columns&amp;quot; not present
    • In the Template Haskell splice
        $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In the expression: $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In an equation for ‘defaultConfig’:
          defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |
14 | defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="おまけ-with-extensible"&gt;おまけ : with Extensible&lt;/h1&gt;
&lt;p&gt;さぁココからが本題！ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; という神パッケージを使ってリファクタリングをしてみよう！！&lt;/p&gt;
&lt;h2 id="問題点"&gt;問題点&lt;/h2&gt;
&lt;p&gt;大した問題ではないんだけど&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;ファイルを分けなければいけないのが悲しい&lt;/li&gt;
&lt;li&gt;YAML のキーがキャメルケース(&lt;code&gt;languageExtensions&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="extensible-パッケージ"&gt;extensible パッケージ&lt;/h2&gt;
&lt;p&gt;言わずもがな，拡張可能なレコードやバリアントを提供するパッケージだ． (詳しくは，最近急ピッチで充実されている&lt;a href="https://wiki.hask.moe/"&gt;攻略Wiki&lt;/a&gt;を読むといいんじゃないんかな？)&lt;/p&gt;
&lt;p&gt;例えば，さっきから使っている &lt;code&gt;Config&lt;/code&gt; 型を &lt;code&gt;extensible&lt;/code&gt; レコード型で書くと次のように書ける&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds     #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;地味にうれしいことに，extensible であれば関数名では許されないハイフンが含んだフィールド名も定義できるのだ．&lt;/p&gt;
&lt;h2 id="リファクタリング"&gt;リファクタリング&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt; を使うには &lt;code&gt;FromJSON&lt;/code&gt; 型クラスと &lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにしなければいけない． でも安心して欲しい． どちらも最新の extensible-0.4.9 では定義済みだ(そして extensible のレコードは &lt;code&gt;type&lt;/code&gt; 宣言なので追加でインスタンスを定義する必要は無い)．&lt;/p&gt;
&lt;p&gt;ただし，extensible-0.4.9 はまだ Stackage の LTS にも nightly にも追加されていないので &lt;code&gt;stack.yaml&lt;/code&gt; に追加する必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-11.9&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; extensible-0.4.9&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスは extensible で定義済みなので1つ目のファイルを分けるはクリアーだ． 実は2つもクリアーしている． 拡張可能レコードの &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスは &lt;code&gt;&amp;quot;path-format&amp;quot;&lt;/code&gt; のようなハイフンを含んだ文字列もそのまま扱ってくれる．&lt;/p&gt;
&lt;p&gt;以下が extensible 版の &lt;code&gt;Config&lt;/code&gt; 型に対応する YAML ファイルだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.extensible-config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;span class="fu"&gt;language-extensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに実行してみよう！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; Sample.Extensible.Config.defaultConfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="デフォルトで置き換える"&gt;デフォルトで置き換える&lt;/h2&gt;
&lt;p&gt;最後に簡単な実行ファイルを実装してみる． 設定ファイルのパスを与えると読みに行き，足りない部分は先ほどから埋め込んでるデフォルト値に置き換えて出力するモノだ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;quot;./template/.example.yaml&amp;quot;
columns: 100
$ stack exec -- pconfig &amp;quot;./template/.example.yaml&amp;quot;
columns @= 100 &amp;lt;: language-extensions @= [] &amp;lt;: nil
$ stack exec -- pconfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もちろんパスにファイルが無ければデフォルトのモノを出力するだけだ．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;さてどうすれば良いだろうか？ 例えば，&lt;code&gt;FromJSON&lt;/code&gt; 型クラスの &lt;code&gt;Meybe a&lt;/code&gt; 型のインスタンスはフィールドが無い場合に &lt;code&gt;Nothing&lt;/code&gt; を与えてくれるので， &lt;code&gt;Config&lt;/code&gt; 型の各フィールドを &lt;code&gt;Maybe&lt;/code&gt; でラップするというのはどうだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Maybe Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;フィールドが2つなら良いが多くなってきたら辛そうだ…&lt;/p&gt;
&lt;h3 id="必殺-nullable"&gt;必殺 Nullable&lt;/h3&gt;
&lt;p&gt;全てを &lt;code&gt;Meybe&lt;/code&gt; でラップする場合は &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使うと良いだろう(ないしは &lt;code&gt;RecordOf Maybe&lt;/code&gt;)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nullable h :* xs&lt;/code&gt; も既に &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスになっているのでそのまま YAML を読み込める． あとは次のようなデフォルト値と &lt;code&gt;Nullable&lt;/code&gt; を与えたら &lt;code&gt;Nothing&lt;/code&gt; の部分だけデフォルト値で置き換えた値を返す関数を実装してやればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;fromNullable ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; h) &lt;span class="fu"&gt;:*&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;fromNullable def &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  hmapWithIndex &lt;span class="fu"&gt;$&lt;/span&gt; \m x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; fromMaybe (hlookup m def) (getNullable x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;extensible ならこうやって全てのフィールドに対し走査する関数が使える．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;あとはこんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE NoImplicitPrelude #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO.Directory&lt;/span&gt;      (doesFileExist)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt;          &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" data-line-number="14"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" data-line-number="15"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" data-line-number="16"&gt;  path &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; listToMaybe &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-17" data-line-number="17"&gt;  config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readConfigWith defaultConfig path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-18" data-line-number="18"&gt;  hPutBuilder stdout &lt;span class="fu"&gt;$&lt;/span&gt; encodeUtf8Builder (tshow config)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-20" data-line-number="20"&gt;&lt;span class="ot"&gt;readConfigWith ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-21" data-line-number="21"&gt;readConfigWith def path &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-22" data-line-number="22"&gt;  file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readFileBinaryWith &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-23" data-line-number="23"&gt;  &lt;span class="kw"&gt;if&lt;/span&gt; Y.decodeEither file &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; &lt;span class="dt"&gt;Y.Null&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-24" data-line-number="24"&gt;    pure def&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-25" data-line-number="25"&gt;  &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-26" data-line-number="26"&gt;    config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either (error &lt;span class="fu"&gt;.&lt;/span&gt; show) pure &lt;span class="fu"&gt;$&lt;/span&gt; Y.decodeEither&amp;#39; file&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-27" data-line-number="27"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt; fromNullable def config&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-29" data-line-number="29"&gt;&lt;span class="ot"&gt;readFileBinaryWith ::&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-30" data-line-number="30"&gt;readFileBinaryWith def path &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-31" data-line-number="31"&gt;  doesFileExist path &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; bool (pure def) (readFileBinary path)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;いろいろとインポートするのがめんどくさくて &lt;code&gt;rio&lt;/code&gt; ライブラリを使っているが，あんまり気にしないで．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;ちなみに，&lt;a href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html"&gt;前回の記事&lt;/a&gt;に書いた &lt;a href="https://github.com/matsubara0507/taskpad"&gt;&lt;code&gt;taskpad&lt;/code&gt;&lt;/a&gt; にこの機能を追加してる．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/05/11/131846</id><title type="text">WSLのubuntuにDist::Millaを入れる</title><updated>2018-05-11T13:18:46+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/05/11/131846"/><summary type="html">WSL のubuntuにDist::Millaを入れたときのメモ。plenv、perl5.26.1、cpanmくらいまではすんなり入った。 割と試行錯誤して入れたから、他にも必要かも。 $ perl -v This is perl 5, version 26, subversion 1 (v5.26.1) built for x86_64-linux ..略.. # Dist::Zilla::Plugin::LicenseFromModule からの依存が漏れてそう $ cpanm JSON # SSL関連 $ sudo apt install libssl-dev $ sudo apt in…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html</id><title type="text">オレ的 Haskell で CLI を作る方法 2018</title><updated>2018-05-10T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;オレ的 Haskell で CLI を作る方法 2018&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-05-10" itemprop="datePublished"&gt;
        May 10, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;現在 &lt;a href="https://github.com/matsubara0507/taskpad"&gt;TaskPad&lt;/a&gt; という簡易的なタスク管理(編集)ツールを Haskell で作っていて，少し CLI を作るうえでのオレ的ノウハウが溜まったのでメモっとく．&lt;/p&gt;
&lt;h2 id="taskpad"&gt;TaskPad&lt;/h2&gt;
&lt;p&gt;先に，何を作ってるかを書いておく． まだ完成していないが，気持ちは次のような Yaml ファイルを編集して自身のタスク管理をしようかなと考えている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="fu"&gt;memo:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="fu"&gt;tasks:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;1:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;done:&lt;/span&gt;&lt;span class="at"&gt; true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;children:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;    &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;2:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;done:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;    &lt;span class="fu"&gt;children:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; world&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;span class="fu"&gt;date:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;#39;20180504&amp;#39;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;現状できている CLI は次のような感じ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ taskpad --help
taskpad - operate daily tasks

Usage: taskpad [-v|--verbose] [-d|--date DATE] COMMAND [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &amp;quot;debug&amp;quot;
  -d,--date DATE           Task&amp;#39;s date
  --version                Show version
  -h,--help                Show this help text

Available commands:
  new                      Create a new task file. Note: if don&amp;#39;t use --date
                           option then use today&amp;#39;s date.
  add                      Add Task
  done                     Done Task
  tasks                    Show Tasks&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;taskpad new&lt;/code&gt; で Yaml ファイルを生成し，&lt;code&gt;taskpad add &amp;quot;hoge&amp;quot;&lt;/code&gt; “hoge” というタスクを追加し，&lt;code&gt;taskpad done 1&lt;/code&gt; で1番目のタスクを完了したことにし，&lt;code&gt;taskpad tasks&lt;/code&gt; でタスクの一覧を出力する．&lt;/p&gt;
&lt;h2 id="ノウハウ"&gt;ノウハウ？&lt;/h2&gt;
&lt;p&gt;たぶん他ではあんまり書いてない，いくつかのことを書いておく．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;optparse-applicative + extensible を使った CLI のオプションパーサー
&lt;ul&gt;
&lt;li&gt;特にサブコマンドをバリアントで表現しているのが面白い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;optparse-applicative でバージョンを表示&lt;/li&gt;
&lt;li&gt;バリアントと型クラスを用いた分岐&lt;/li&gt;
&lt;li&gt;rio + extensible で大域変数&lt;/li&gt;
&lt;li&gt;rio を用いてロギング&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オプションパーサーに &lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; を用いている． オプションパーサーには &lt;a href="https://hackage.haskell.org/package/optparse-simple"&gt;optparse-simple&lt;/a&gt; や &lt;a href="https://hackage.haskell.org/package/optparse-generic"&gt;optparse-generics&lt;/a&gt; など他にもいくつかあるが，サブコマンドのような多少込み入ったコトをしようとすると optparse-applicative が欲しくなる． &lt;a href="https://hackage.haskell.org/package/rio"&gt;rio&lt;/a&gt; ライブラリは，なんとなく最近使っている alt. Prelude ライブラリ(詳しくは&lt;a href="https://github.com/commercialhaskell/rio#readme"&gt;本家の README&lt;/a&gt; か&lt;a href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html"&gt;前の僕の記事&lt;/a&gt;を読んで)． &lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; は Haskell の残念なレコード構文や直和型の代わりに，拡張可能なレコード・バリアント型を提供してくれる面白いパッケージだ．&lt;/p&gt;
&lt;h3 id="import-と言語拡張"&gt;import と言語拡張&lt;/h3&gt;
&lt;p&gt;extensible はかなり言語拡張を用いる． 以降では，めんどくさいので &lt;code&gt;import&lt;/code&gt; も含め明示的に扱わない． 以下のコードが先頭にくっついてるとビルドはできるはずだ(たぶん，試してない)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds             #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE FlexibleContexts      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE MultiParamTypeClasses #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell       #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeApplications      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeFamilies          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;RIO.Text&lt;/span&gt;          &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO.Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Functor.Identity&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Proxy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;GHC.TypeLits&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Options.Applicative&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="extensible-で-optparse-applicative"&gt;extensible で optparse-applicative&lt;/h3&gt;
&lt;p&gt;少しだけ &lt;code&gt;optparse-applicative&lt;/code&gt; について説明しておく． optparse-applicative は CLI オプションをパースして任意の型にマッピングしてくれる． 主に次のようにして用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; run &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; execParser opts&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;    opts &lt;span class="fu"&gt;=&lt;/span&gt; info (options &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; helper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;         &lt;span class="fu"&gt;$&lt;/span&gt; fullDesc&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;        &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; header &lt;span class="st"&gt;&amp;quot;taskpad - operate daily tasks&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;&lt;span class="ot"&gt;options ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;options &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:execParser"&gt;&lt;code&gt;execParser&lt;/code&gt;&lt;/a&gt; 関数は &lt;code&gt;ParserInfo a -&amp;gt; IO a&lt;/code&gt; という型を持つ． &lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper"&gt;&lt;code&gt;helper :: Parser (a -&amp;gt; a)&lt;/code&gt;&lt;/a&gt; は &lt;code&gt;--help&lt;/code&gt; オプションを与えてくれる関数だ． &lt;code&gt;info&lt;/code&gt; 関数と &lt;code&gt;fullDesc&lt;/code&gt; や &lt;code&gt;header&lt;/code&gt; により，&lt;code&gt;Parser a&lt;/code&gt; 型のパーサーに対し &lt;code&gt;--help&lt;/code&gt; で出力する情報を追加して &lt;code&gt;ParserInfo a&lt;/code&gt; 型に変換する．&lt;/p&gt;
&lt;h4 id="型の定義"&gt;型の定義&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;extensible&lt;/code&gt; で &lt;code&gt;optparse-applicative&lt;/code&gt; を使うとは即ち，任意の型，ここでいう &lt;code&gt;Options&lt;/code&gt; 型が拡張可能レコードや拡張可能バリアントであるというシチュエーションだ． 今回は &lt;code&gt;Options&lt;/code&gt; 型をまずは次のように定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;verbose&amp;quot; &amp;gt;: Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;subcmd&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;new&amp;quot;   &amp;gt;: ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" data-line-number="9"&gt;   , &lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-12" data-line-number="12"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-14" data-line-number="14"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SubCmd&lt;/code&gt; 型が拡張可能なバリアント型だ． ちなみに，Haskell のプリミティブな代数型データ構造で記述すると以下のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; verbose ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; date    ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;  ,&lt;span class="ot"&gt; subcmd  ::&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;New&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Add&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Done&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Tasks&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自分的に，extensible を使う利点は3つある．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;フィールド名と関数名の名前空間が別なので衝突が無い&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; 宣言によりレコードに対しいちいち型クラスのインスタンスを定義する必要が無い(既にあるものは)&lt;/li&gt;
&lt;li&gt;型レベルリストによってフィールド全体に対する走査を行える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逆にデメリットは，(2) にも関係するのだが，&lt;code&gt;type&lt;/code&gt; 宣言のためインスタンスの定義が衝突することがしばしばある(これはインスタンスのスコープをコントロールできないという Haskell 全体での問題でもある)．&lt;/p&gt;
&lt;h4 id="拡張可能レコードのパーサー"&gt;拡張可能レコードのパーサー&lt;/h4&gt;
&lt;p&gt;まずは拡張可能レコード(&lt;code&gt;Options&lt;/code&gt; 型)のパーサーを書いてみる． バリアント(&lt;code&gt;SubCmd&lt;/code&gt; 型)のは &lt;code&gt;undefined&lt;/code&gt; としておこう． 細かい &lt;code&gt;optparse-applicative&lt;/code&gt; の構文は割愛する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;options ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;options &lt;span class="fu"&gt;=&lt;/span&gt; hsequence&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;verbose &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; switch (long &lt;span class="st"&gt;&amp;quot;verbose&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; short &lt;span class="ch"&gt;&amp;#39;v&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Enable verbose mode: verbosity level \&amp;quot;debug\&amp;quot;&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date    &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; optional (strOption (long &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; short &lt;span class="ch"&gt;&amp;#39;d&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; metavar &lt;span class="st"&gt;&amp;quot;DATE&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Task&amp;#39;s date&amp;quot;&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd  &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; subcmdParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコードの値を構築するには &lt;code&gt;#fieldName @= fieldValue&lt;/code&gt; というの &lt;code&gt;&amp;lt;:&lt;/code&gt; で直列につないでいく(細かくは extensible の解説記事を読んで)． &lt;code&gt;&amp;lt;@=&amp;gt;&lt;/code&gt; 演算子はモナドなフィールドの値を持ち上げてくれるバージョンの &lt;code&gt;@=&lt;/code&gt; 演算子だ． &lt;code&gt;$&lt;/code&gt; の右側は，正確には違うが，次の型のようなイメージとなる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ch"&gt;&amp;#39;[ Parser (&amp;quot;verbose&amp;quot; &amp;gt;: Bool)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt; , &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt; , &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;subcmd&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt; ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Haskeller っであれば，後はリスト型で言う &lt;code&gt;sequence&lt;/code&gt; できれば良さそうとわかるだろう． その型レベルリスト版が &lt;code&gt;hsequence&lt;/code&gt; だ．&lt;/p&gt;
&lt;h4 id="拡張可能バリアントのパーサー"&gt;拡張可能バリアントのパーサー&lt;/h4&gt;
&lt;p&gt;さて，今回の自分的なメインディッシュだ． 仮に通常の直和型であれば次のように書くだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; subparser&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt;   (pure &lt;span class="dt"&gt;New&lt;/span&gt; &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt;   (&lt;span class="dt"&gt;Add&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; strArgument (metavar &lt;span class="st"&gt;&amp;quot;TEXT&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;  (&lt;span class="dt"&gt;Done&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; argument auto (metavar &lt;span class="st"&gt;&amp;quot;ID&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; (pure &lt;span class="dt"&gt;Tasks&lt;/span&gt; &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;&lt;span class="ot"&gt;withInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;withInfo opts &lt;span class="fu"&gt;=&lt;/span&gt; info (helper &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; opts) &lt;span class="fu"&gt;.&lt;/span&gt; progDesc&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この程度のサブコマンドならそこまで複雑じゃなく書けた． しかし悲しいことに，例えば &lt;code&gt;command &amp;quot;tasks&amp;quot;&lt;/code&gt; の行が無くてもビルドは通る． 即ち，&lt;strong&gt;直和型に対し網羅性を型検査で保証することが出来ない&lt;/strong&gt;．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;対して extensible のバリアントならどうだろうか． 理想的にはバリアントと同じフィールドを持つレコードの各要素が &lt;code&gt;ParserInfo a&lt;/code&gt; であるような値から自動で導出してくれると良い． つまり次のように扱いたい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; variantFrom&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;new   &lt;span class="fu"&gt;@=&lt;/span&gt; (pure () &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Create a new task file. Note: if don&amp;#39;t use --date option then use today&amp;#39;s date.&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;add   &lt;span class="fu"&gt;@=&lt;/span&gt; (strArgument (metavar &lt;span class="st"&gt;&amp;quot;TEXT&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Task contents&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Add Task&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;done  &lt;span class="fu"&gt;@=&lt;/span&gt; (argument auto (metavar &lt;span class="st"&gt;&amp;quot;ID&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Done task from id&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Done Task&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;tasks &lt;span class="fu"&gt;@=&lt;/span&gt; (pure () &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Show Tasks&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="ot"&gt;variantFrom ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="dt"&gt;Variant&lt;/span&gt; xs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;variantFrom &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Wrapper&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Repr&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;  _Wrapper &lt;span class="fu"&gt;=&lt;/span&gt; id&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@=&lt;/code&gt; と &lt;code&gt;&amp;lt;:&lt;/code&gt; で構築したレコードが &lt;code&gt;Record = RecordOf Identity&lt;/code&gt; ではなく，&lt;code&gt;RecordOf h&lt;/code&gt; であるためには &lt;code&gt;h&lt;/code&gt; が &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Wrapper.html#t:Wrapper"&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスである必要がある(というかインスタンスでありさえすれば良い)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;さてキモは &lt;code&gt;variantFrom&lt;/code&gt; だ． 通常の直和型版の &lt;code&gt;subcmdParser&lt;/code&gt; 関数を見ればわかるように，&lt;code&gt;command&lt;/code&gt; 関数で作成した値をモノイドで畳み込めばいいので，お察しの通り(??) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#v:hfoldMap"&gt;&lt;code&gt;hfoldMap&lt;/code&gt;&lt;/a&gt; を使う． ついでに &lt;code&gt;command&lt;/code&gt; の一引数目に渡すサブコマンドの文字列はフィールド名から取得するようにしよう． この場合，インデックスと &lt;code&gt;KnownSymbol&lt;/code&gt; 制約を渡す必要があるので &lt;code&gt;hfoldMap&lt;/code&gt; の代わりに &lt;code&gt;hfoldMapWithIndexFor&lt;/code&gt; 関数を使う．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;variantFrom ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;) xs &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="dt"&gt;Variant&lt;/span&gt; xs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;variantFrom &lt;span class="fu"&gt;=&lt;/span&gt; subparser &lt;span class="fu"&gt;.&lt;/span&gt; subcmdVariant&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;    subcmdVariant &lt;span class="fu"&gt;=&lt;/span&gt; hfoldMapWithIndexFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;)) &lt;span class="fu"&gt;$&lt;/span&gt; \m x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; k &lt;span class="fu"&gt;=&lt;/span&gt; symbolVal (proxyAssocKey m)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;      &lt;span class="kw"&gt;in&lt;/span&gt; command k ((&lt;span class="dt"&gt;EmbedAt&lt;/span&gt; m &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getField x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;結果として，&lt;strong&gt;extensible のバリアント版は網羅性を型検査によって検証できるようになった！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="バージョンの表示"&gt;バージョンの表示&lt;/h3&gt;
&lt;p&gt;バージョンの表示は他のコマンドと違い，コマンドが間違って(例えばサブコマンドが無い)いても &lt;code&gt;--version&lt;/code&gt; という引数さえあれば優先的にバージョンを表示する必要がある． そのようなオプションを追加する場合には &lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption"&gt;&lt;code&gt;infoOption&lt;/code&gt;&lt;/a&gt; 関数を使う．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Paths_taskpad&lt;/span&gt;       &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Meta&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Version&lt;/span&gt;        (&lt;span class="dt"&gt;Version&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Version&lt;/span&gt;        &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Development.GitRev&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; run &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; execParser opts&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;    opts &lt;span class="fu"&gt;=&lt;/span&gt; info (options &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; version Meta.version &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; helper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;         &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" data-line-number="12"&gt;&lt;span class="ot"&gt;version ::&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-13" data-line-number="13"&gt;version v &lt;span class="fu"&gt;=&lt;/span&gt; infoOption (showVersion v)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; long &lt;span class="st"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Show version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-17" data-line-number="17"&gt;&lt;span class="ot"&gt;showVersion ::&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-18" data-line-number="18"&gt;showVersion v &lt;span class="fu"&gt;=&lt;/span&gt; unwords&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-19" data-line-number="19"&gt;  [ &lt;span class="st"&gt;&amp;quot;Version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-20" data-line-number="20"&gt;  , Version.showVersion v &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-21" data-line-number="21"&gt;  , &lt;span class="st"&gt;&amp;quot;Git revision&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-22" data-line-number="22"&gt;  , &lt;span class="fu"&gt;$&lt;/span&gt;(gitHash)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-23" data-line-number="23"&gt;  , &lt;span class="st"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(gitCommitCount) &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; commits)&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-24" data-line-number="24"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;**&amp;gt;&lt;/code&gt; 演算子はただの &lt;code&gt;flip (&amp;lt;*&amp;gt;)&lt;/code&gt; だ． ちなみに，&lt;code&gt;version&lt;/code&gt; と &lt;code&gt;helper&lt;/code&gt; の適用順を入れ替えると &lt;code&gt;--help&lt;/code&gt; の表示がほんの少しだけ変わる．&lt;/p&gt;
&lt;h3 id="バリアントと型クラス"&gt;バリアントと型クラス&lt;/h3&gt;
&lt;p&gt;こっからは &lt;code&gt;run :: Options -&amp;gt; IO ()&lt;/code&gt; 関数を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;  matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;    undefined &lt;span class="co"&gt;-- ???&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;    (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getTodaysDate&lt;/code&gt; 関数は自身で定義しているとする． &lt;code&gt;--date&lt;/code&gt; オプションを指定しなかった場合には今日の日付を取得する． 問題はサブコマンドの分岐だ．&lt;/p&gt;
&lt;p&gt;バリアントの分岐には &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; 関数を用いる． &lt;code&gt;matchField&lt;/code&gt; 関数の型は &lt;code&gt;RecordOf (Match h r) xs -&amp;gt; VariantOf h xs -&amp;gt; r&lt;/code&gt; となる． 一引数目のレコードと二引数目のバリアントの &lt;code&gt;xs&lt;/code&gt; が等しいということから共通のフィールドを期待しているのが分かるだろう． レコード側の各フィールドに，各バリアントに対するフィールドの値を受け取り &lt;code&gt;r&lt;/code&gt; 型の返り値の関数を記述するといった具合だ(この部分が &lt;code&gt;Match h r&lt;/code&gt; に集約されている)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;今回は，このレコードの構築に型クラスを用いる． 以下のような型クラスを定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  run&amp;#39; ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実装は置いておいて，インスタンスを与えてみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 関数の &lt;code&gt;matchField&lt;/code&gt; 関数の引数は次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;  matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;    (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m date &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;    (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy @ Run&lt;/code&gt; の &lt;code&gt;@&lt;/code&gt; の部分は &lt;code&gt;TypeApplications&lt;/code&gt; 拡張のモノだ． フィールドの値は &lt;code&gt;Identity x&lt;/code&gt; 型として来るので &lt;code&gt;runIdentity&lt;/code&gt; 関数を用いて剥がし，&lt;code&gt;run' m date&lt;/code&gt; へと適用する． もちろんサブコマンドのインスタンスを書き忘れていた場合は，ちゃんと型検査に引っかかる！&lt;/p&gt;
&lt;h3 id="rio-で大域変数"&gt;rio で大域変数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; で大域変数を扱うには &lt;code&gt;RIO env&lt;/code&gt; モナドを用いる． 適当なアプリケーションモナドを定義してやろう． 今回はひとつしか大域変数が無いのであんまりメリットを感じないかもしれないが…&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;TaskPad&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot; &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 関数も書き直してやる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;MonadUnliftIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date   &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;         &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;  runRIO env &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" data-line-number="7"&gt;    matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" data-line-number="8"&gt;      (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" data-line-number="9"&gt;      (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" data-line-number="11"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-12" data-line-number="12"&gt;&lt;span class="ot"&gt;  run&amp;#39; ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TaskPad&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに &lt;code&gt;new&lt;/code&gt; サブコマンドを書いてみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;  run&amp;#39; _ _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;    date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; asks (view &lt;span class="fu"&gt;#&lt;/span&gt;date)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;    writeMemo &lt;span class="fu"&gt;$&lt;/span&gt; mkMemo date&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mkMemo&lt;/code&gt; や &lt;code&gt;writeMemo&lt;/code&gt; については次のように定義している． &lt;code&gt;Memo&lt;/code&gt; 型も拡張可能レコードだ． 最近の extensible のアップデートで拡張可能レコードが &lt;code&gt;ToJson&lt;/code&gt; 型クラスと &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスになったので，Yaml への変換は特にインスタンスを書くことなく行えるようになった．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot;  &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Task&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;memo&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" data-line-number="7"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" data-line-number="9"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Task&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; (&lt;span class="dt"&gt;TaskFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;children&amp;quot; &amp;gt;: [SubTask]])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" data-line-number="10"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SubTask&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;TaskFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" data-line-number="12"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;TaskFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" data-line-number="13"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" data-line-number="14"&gt;   , &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" data-line-number="15"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-17" data-line-number="17"&gt;&lt;span class="ot"&gt;mkMemo ::&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-18" data-line-number="18"&gt;mkMemo date&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-19" data-line-number="19"&gt;    &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date  &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-20" data-line-number="20"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;tasks &lt;span class="fu"&gt;@=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-21" data-line-number="21"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;memo  &lt;span class="fu"&gt;@=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-22" data-line-number="22"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-23" data-line-number="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-24" data-line-number="24"&gt;&lt;span class="ot"&gt;writeMemo ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-25" data-line-number="25"&gt;writeMemo memo &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-26" data-line-number="26"&gt;  writeFileBinary (Text.unpack &lt;span class="fu"&gt;$&lt;/span&gt; memo &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;.yaml&amp;quot;&lt;/span&gt;) (Y.encode memo)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="rio-でロギング"&gt;rio でロギング&lt;/h3&gt;
&lt;p&gt;ロギングは実用アプリケーションの重要な要素だろう． &lt;code&gt;rio&lt;/code&gt; であればまぁまぁ簡単に書ける．&lt;/p&gt;
&lt;p&gt;まずは &lt;code&gt;Env&lt;/code&gt; にロギング用の関数を足してやる． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogFunc"&gt;&lt;code&gt;LogFunc&lt;/code&gt;&lt;/a&gt; 型や &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:HasLogFunc"&gt;&lt;code&gt;HasLogFunc&lt;/code&gt;&lt;/a&gt; 型クラスは &lt;code&gt;rio&lt;/code&gt; ライブラリに定義されているものだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot;   &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;logger&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LogFunc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-6" data-line-number="6"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-7" data-line-number="7"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens (view &lt;span class="fu"&gt;#&lt;/span&gt;logger) (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x &lt;span class="fu"&gt;&amp;amp;&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="ot"&gt;`set`&lt;/span&gt; y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実はこれだけで &lt;code&gt;TaskPad&lt;/code&gt; モナド(すなわち &lt;code&gt;RIO Env&lt;/code&gt; モナド)の中で自由にロギング関数を呼べるようになる． 試しに &lt;code&gt;new&lt;/code&gt; サブコマンドにロギングを足してみよう． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logInfo"&gt;&lt;code&gt;logInfo&lt;/code&gt;&lt;/a&gt; 関数がロギング関数のひとつだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;  run&amp;#39; _ _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;    date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; asks (view &lt;span class="fu"&gt;#&lt;/span&gt;date)&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;    writeMemo &lt;span class="fu"&gt;$&lt;/span&gt; mkMemo date&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;    logInfo (display &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;create new task&amp;#39;s file: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; date &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あとは &lt;code&gt;run&lt;/code&gt; 関数を書き換えよう(&lt;code&gt;Env&lt;/code&gt; 型の中身が変わったので)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb23-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;MonadUnliftIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" data-line-number="3"&gt;  date    &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" data-line-number="4"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;verbose)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-5" data-line-number="5"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \logger &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date   &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-7" data-line-number="7"&gt;           &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="fu"&gt;@=&lt;/span&gt; logger&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-8" data-line-number="8"&gt;           &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-9" data-line-number="9"&gt;    runRIO env &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-10" data-line-number="10"&gt;      matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-11" data-line-number="11"&gt;        (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-12" data-line-number="12"&gt;        (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LogFunc&lt;/code&gt; 型の値を得るには &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:withLogFunc"&gt;&lt;code&gt;withLogFunc&lt;/code&gt;&lt;/a&gt; 関数を用いるのが良いだろう． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogOptions"&gt;&lt;code&gt;LogOptions&lt;/code&gt;&lt;/a&gt; 型の値(ここでいう &lt;code&gt;logOpts&lt;/code&gt;)を生成する &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logOptionsHandle"&gt;&lt;code&gt;logOptionsHandle&lt;/code&gt;&lt;/a&gt; 関数の二引数目に &lt;code&gt;True&lt;/code&gt; を与えることでログがデバッグ仕様になる(そういえば &lt;code&gt;Options&lt;/code&gt; 型には &lt;code&gt;--verbose&lt;/code&gt; オプションがあった)． ちなみに，デバッグ仕様のときにだけ表示するロギング関数として &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logDebug"&gt;&lt;code&gt;logDebug&lt;/code&gt;&lt;/a&gt; 関数がある．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;早く完成させるぞ&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2018/04/27/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_4_%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%9F</id><title type="text">技術書典 4 にサークル参加した</title><updated>2018-04-30T09:55:47+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2018/04/27/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_4_%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%9F"/><summary type="html">4月22日に開催された『技術書典 4』にサークル参加してきました。 techbookfest.org 技術書典は1と2に個人で参加して3は会社として参加して今回の4は会社と個人と2サークルにかかわっていました。 超技術書典を抜くと皆勤です。 個人サークル 既刊として『遠回りして学ぶ Yesod 入門』を増刷し、新刊は『手続き Haskell』を持っていきました。 doujin.kakkun61.com doujin.kakkun61.com 数字 売り上げ部数は、どんぶり勘定ですが（特に Yesod 本のダウンロードカードが完全に記憶による）下記の通りとなりました。 Yesod 本 紙 + P…</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html</id><title type="text">[cygwin] cygwinセットアップ・環境構築手順メモ</title><updated>2018-04-27T13:16:22.723+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html"/><summary type="text">

主に自分向けの防備録です。windows10上で確認。インストーラーはここからDLする。





&lt;&lt;設定&gt;&gt;

ssh-agentの重複起動を防ぐ


ユーザーのアカウント名、ホームディレクトリの変更



/etc/passwdを編集する（最新バージョンでは自動生成されない？）
Cygwinを移動したら/etc/passwdの再生成を
巨大ドメインに参加している PC での /etc/passwd, /etc/group ファイルのつくりかた 

ssh-agentのために秘密鍵セットアップ



~/.ssh/


※group/otherの権限を削除する必要がある

% chmod 700 ~/.ssh 


less, lv, manコマンド終了時に画面をクリアしない

[linux][cygwin] less, manの終了直前の画面をクリアしないで端末上に残す方法 
</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/01/21/175227</id><title type="text">ぼくのかんがえた最強の拡張可能レコード</title><updated>2018-04-27T11:57:55+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/01/21/175227"/><summary type="html">注意(2018/04) かなり古い記事なので、extensibleの最新のバージョンとはまったく互換性がない __ 動機 GHCに、OverloadedRecordFields(ORF)という拡張の導入が提案されている。 (Records/OverloadedRecordFields/Design – GHCより) Haskellのレコードの深刻な欠点は、フィールドをオーバーロードできないことだ。例えば、 data Person = Person { personId :: Int, name :: String } data Address = Address { personId :: I…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2018/04/10/100000</id><title type="text">バイナリエディタを作りました！</title><updated>2018-04-15T17:59:13+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2018/04/10/100000"/><summary type="html">バイナリエディタを作りました。 インストールは go get -u github.com/itchyny/bed/cmd/bed でできると思います。 なぜ作ったのか 私は昔からファイルフォーマットに興味があり、画像ファイルやPDFファイルのフォーマットを調べるのが好きでした。 最近も圧縮ファイルのフォーマットを趣味で調べたりしています。 コンパイラ技術にも興味があり、ゆくゆくは実行ファイルを生成したりしたいなという思いもあります。 バイナリファイルをエディットするにはバイナリエディタが必要となるわけですが、自分の手に馴染むUIを持つエディタがありませんでした。 私は実はVimというエディタが…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html</id><title type="text">rio ライブラリを試す その１</title><updated>2018-04-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;rio ライブラリを試す その１&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-13" itemprop="datePublished"&gt;
        Apr 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先日，alt. &lt;code&gt;Prelude&lt;/code&gt; を目指している &lt;a href="https://hackage.haskell.org/package/rio"&gt;&lt;code&gt;rio&lt;/code&gt;&lt;/a&gt; ライブラリの ver.0.1 がリリースされました． 自作している CLI ツールを試しに &lt;code&gt;rio&lt;/code&gt; で置き換えようかとしてまして，自分の整理のためにまとめてみようと思います．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ただし，&lt;code&gt;rio&lt;/code&gt; 作者ではないし，全部をちゃんと追っていないので間違っているかも． 間違っている場合は&lt;a href="https://github.com/matsubara0507/source-gh-pages"&gt;このリポジトリに Issue&lt;/a&gt; するか &lt;a href="https://www.reddit.com/r/haskell_jp"&gt;Reddit&lt;/a&gt; でコメントでもしてください m(_ _ )m&lt;/p&gt;
&lt;h1 id="readme-でひとめぐり"&gt;README でひとめぐり&lt;/h1&gt;
&lt;p&gt;もともとはビルドツール Stack を作成するために考えたデザインパターンをまとめたものっぽい．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad"&gt;The RIO Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリの README にはライブラリのゴール・目的の他に(彼らにとっての)ベストプラクティスが書いてある(&lt;code&gt;rio&lt;/code&gt; 自体がそれに則って作られてる)． ここには翻訳というより，README の各項目の要約を記述する．&lt;/p&gt;
&lt;h2 id="goal"&gt;Goal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリのゴール(目的)は以下の3つ．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;よく設計された信頼できるライブラリのコレクション&lt;/li&gt;
&lt;li&gt;より優れた Prelude の代替え&lt;/li&gt;
&lt;li&gt;高品質な Haskell コードを書くためのベストプラクティス&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1)により &lt;code&gt;text&lt;/code&gt; や &lt;code&gt;bytesyring&lt;/code&gt; のような，ほとんど &lt;code&gt;base&lt;/code&gt; のようなパッケージを &lt;code&gt;dependencies&lt;/code&gt; に列挙する必要が無くなる． (3)は大域変数(&lt;code&gt;Reader&lt;/code&gt; モナド)やロガーのような実用モナド回りのベストプラクティスが目玉かな(他にもあるけど)．&lt;/p&gt;
&lt;h2 id="標準ライブラリ"&gt;標準ライブラリ&lt;/h2&gt;
&lt;p&gt;いくつかのパッケージを「標準」ライブラリとして再エクスポートしている． &lt;code&gt;rio&lt;/code&gt; の&lt;a href="https://github.com/commercialhaskell/rio/blob/311549f5a7c29abf6fc25e3ba7ec5ab6647e2d96/rio/package.yaml#L14"&gt;依存関係&lt;/a&gt;を見る限り，次のパッケージを再エクスポートしているようだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bytestring&lt;/li&gt;
&lt;li&gt;containers&lt;/li&gt;
&lt;li&gt;deepseq&lt;/li&gt;
&lt;li&gt;directory&lt;/li&gt;
&lt;li&gt;exceptions&lt;/li&gt;
&lt;li&gt;filepath&lt;/li&gt;
&lt;li&gt;hashable&lt;/li&gt;
&lt;li&gt;lens(microlens)&lt;/li&gt;
&lt;li&gt;process&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;unliftio&lt;/li&gt;
&lt;li&gt;unordered-containers&lt;/li&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もちろん，元のパッケージの全ての関数や型を再エクスポートしているのではなく，取捨選択して再エクスポートしている． また，後述する &lt;code&gt;Prelude&lt;/code&gt; の代わりである &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールに含まれるものもあれば，&lt;code&gt;RIO.XXX&lt;/code&gt; として別のモジュールとして提供されているものもある．&lt;/p&gt;
&lt;h3 id="lens"&gt;Lens&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lens&lt;/code&gt; の場合，申し訳程度の関数しか再エクスポートされていない． 基本的に &lt;code&gt;set&lt;/code&gt;・&lt;code&gt;sets&lt;/code&gt;・&lt;code&gt;over&lt;/code&gt;・&lt;code&gt;to&lt;/code&gt; だけだ． 演算子は参照の &lt;code&gt;(.^)&lt;/code&gt; しかない． 今後どうなるか分からないが，現状 &lt;code&gt;(.~)&lt;/code&gt; や &lt;code&gt;(%~)&lt;/code&gt; は無いので替わりに関数を中置演算子にして使うしか無さそうだ．&lt;/p&gt;
&lt;h2 id="prelude-の代替え"&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替え&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替えとして &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールというのがある． README には部分関数や遅延 I/O のような，よく問題になるものを削除していると書いてある． また，&lt;code&gt;Data.Maybe&lt;/code&gt; や &lt;code&gt;Control.Arrow&lt;/code&gt; のような良く使う &lt;code&gt;base&lt;/code&gt; ライブラリのモジュールが再エクスポートされていたり，&lt;code&gt;mapLeft&lt;/code&gt; や &lt;code&gt;whenM&lt;/code&gt; のような良く使いそうなのに &lt;code&gt;base&lt;/code&gt; には無い関数が&lt;a href="https://github.com/commercialhaskell/rio/blob/e8c4cba69599aecd9f91c4398aea47ab4eadbb07/rio/src/RIO/Prelude/Extra.hs"&gt;定義されている&lt;/a&gt;． 正直，この辺りがすごい便利．&lt;/p&gt;
&lt;h2 id="ベストプラクティス"&gt;ベストプラクティス&lt;/h2&gt;
&lt;p&gt;ココからが長い + 意見の分かれるところ． 結構 &lt;code&gt;TODO&lt;/code&gt; と書いてあるところも多いので彼らの中でもまとまってないのかな？？&lt;/p&gt;
&lt;h3 id="インポートプラクティス"&gt;インポートプラクティス&lt;/h3&gt;
&lt;p&gt;以下をやってほしいらしい&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt; 言語拡張をオン&lt;/li&gt;
&lt;li&gt;全てのモジュールに &lt;code&gt;import RIO&lt;/code&gt; を追加 (すごいめんどい)&lt;/li&gt;
&lt;li&gt;必要に応じて &lt;code&gt;RIO.XXX&lt;/code&gt; モジュールを &lt;code&gt;qualified&lt;/code&gt; を使ってインポート
&lt;ul&gt;
&lt;li&gt;適切な &lt;code&gt;qualified&lt;/code&gt; の付け方は各モジュールの Haddock の冒頭に書いてある&lt;/li&gt;
&lt;li&gt;例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-ByteString.html"&gt;&lt;code&gt;import qualified RIO.ByteString as B&lt;/code&gt;&lt;/a&gt; とか&lt;/li&gt;
&lt;li&gt;ドキュメントに &lt;code&gt;qualified&lt;/code&gt; が書いてない場合は &lt;code&gt;qualified&lt;/code&gt; しなくていいのかな？？(例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-Directory.html"&gt;&lt;code&gt;RIO.Directory&lt;/code&gt;&lt;/a&gt; とか)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中置演算子は &lt;code&gt;qualified&lt;/code&gt; しなくていい(他のモジュールと衝突しない限りは)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="言語拡張"&gt;言語拡張&lt;/h3&gt;
&lt;p&gt;「言語拡張を使わないプロジェクトなんて，最近じゃほとんどないよね」とか書いてある． 以下の観点を基にデフォルトで利用しても良さそうな言語拡張を選定したそうだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コミュニティで受け入れられている&lt;/li&gt;
&lt;li&gt;コードを壊すようなことが &lt;strong&gt;ほとんど&lt;/strong&gt; ない&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般的に&lt;/strong&gt; 安全だと考えられている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;割と断言していないのが面白い(笑) 推奨する言語拡張はこちら&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AutoDeriveTypeable
BangPatterns
BinaryLiterals
ConstraintKinds
DataKinds
DefaultSignatures
DeriveDataTypeable
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveTraversable
DoAndIfThenElse
EmptyDataDecls
ExistentialQuantification
FlexibleContexts
FlexibleInstances
FunctionalDependencies
GADTs
GeneralizedNewtypeDeriving
InstanceSigs
KindSignatures
LambdaCase
MultiParamTypeClasses
MultiWayIf
NamedFieldPuns
NoImplicitPrelude
OverloadedStrings
PartialTypeSignatures
PatternGuards
PolyKinds
RankNTypes
RecordWildCards
ScopedTypeVariables
StandaloneDeriving
TupleSections
TypeFamilies
TypeSynonymInstances
ViewPatterns&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RecordWildCards&lt;/code&gt; と &lt;code&gt;OverloadedStrings&lt;/code&gt; は議論の余地あり的なことが書いてある(詳しくはもとの README を見て)．&lt;/p&gt;
&lt;h3 id="ghcオプション"&gt;GHCオプション&lt;/h3&gt;
&lt;p&gt;以下を使いなさいとのコト．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Wall
-Wcompat
-Wincomplete-record-updates
-Wincomplete-uni-patterns
-Wredundant-constraints&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どういう形で指定してもいいけど，&lt;code&gt;package.yaml&lt;/code&gt; で書くと楽だし，後述するテンプレートにも書く予定だそうだ． あと，プロダクションコードなら &lt;code&gt;-Werror&lt;/code&gt; をオンにして，最後には確認した方が良いとも書いてある(CIとかでチェックしたいよね)．&lt;/p&gt;
&lt;h3 id="monads"&gt;Monads&lt;/h3&gt;
&lt;p&gt;まってました！ モナドです． 実用的なプロジェクトを考えるとき，必要になってくるのが大域変数・ロガー・例外・IO だと思うので，気になるのはこの辺りだよね．&lt;/p&gt;
&lt;p&gt;全体としての推奨事項は以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; を使いたいときは &lt;code&gt;RIO&lt;/code&gt; モナドを使いなさい．
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドは &lt;code&gt;ReaderT env IO&lt;/code&gt; と同じだけど，&lt;code&gt;rio&lt;/code&gt; には &lt;code&gt;RIO&lt;/code&gt; モナドに対する補助関数が含まれるのでぜひ使って．&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドで &lt;code&gt;env&lt;/code&gt; の参照関数を書くときは，具体的な型に対する参照関数を書かずに，型クラスを用いた多相的な関数を書くべき(詳しくは後述)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Has&lt;/code&gt; スタイルの型クラスを使えば lens を利用することが出来るよ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いくつかの良い &lt;code&gt;mtl&lt;/code&gt; スタイルの型クラスも利用する必要は出てくるはず
&lt;ul&gt;
&lt;li&gt;ただし，推奨しているのは &lt;code&gt;MonadReader&lt;/code&gt; &lt;code&gt;MonadIO&lt;/code&gt; &lt;code&gt;MonadUnliftIO&lt;/code&gt; &lt;code&gt;PrimMonad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MonadReader&lt;/code&gt; + &lt;code&gt;Has&lt;/code&gt; の方が &lt;code&gt;MonadLogger&lt;/code&gt; のように新しい型クラスを作るより優れていると思う&lt;/li&gt;
&lt;li&gt;特に &lt;code&gt;MonadBase&lt;/code&gt; &lt;code&gt;MonadBaseControl&lt;/code&gt; &lt;code&gt;MonadMask&lt;/code&gt; &lt;code&gt;MonadCatch&lt;/code&gt; は避けるべき&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="大域変数"&gt;大域変数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt; 回りについて． &lt;code&gt;Has&lt;/code&gt; スタイル(パターン)というのがあって，それ自体はこの&lt;a href="https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae"&gt;ページ&lt;/a&gt;が参考になるのかな？ &lt;code&gt;env&lt;/code&gt; から何らかの値を参照する場合には&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;のような関数は &lt;strong&gt;やめて&lt;/strong&gt; ，次のように書くのを推奨している．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  configL ::&lt;/span&gt; &lt;span class="dt"&gt;Lens&amp;#39;&lt;/span&gt; env &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="co"&gt;-- more on this in a moment&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; env &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで，&lt;code&gt;env&lt;/code&gt; は次のようなレコードを想定しており&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすることで，&lt;code&gt;env&lt;/code&gt; に複数の大域変数を持たせても，うまく機能させることが出来る． また，次のように &lt;code&gt;Env&lt;/code&gt; と &lt;code&gt;Config&lt;/code&gt; それぞれでインスタンスを定義することで，それぞれで利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; lens envConfig (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envConfig &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ロガー"&gt;ロガー&lt;/h4&gt;
&lt;p&gt;ロガーも同様に &lt;code&gt;Has&lt;/code&gt; スタイルを推奨している． &lt;code&gt;env&lt;/code&gt; にログを出力するための関数(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:LogFunc"&gt;&lt;code&gt;LogFunc&lt;/code&gt;&lt;/a&gt; 型のもの)を持たせる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envLogFunc ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;LogFunc&lt;/span&gt;,&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これの &lt;code&gt;Has&lt;/code&gt; スタイル型クラスは &lt;code&gt;RIO&lt;/code&gt; モジュールに&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:HasLogFunc"&gt;定義してある&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens envLogFunc (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envLogFunc &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LogFunc&lt;/code&gt; 型の値を渡すには &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:withLogFunc"&gt;&lt;code&gt;withLogFunc&lt;/code&gt;&lt;/a&gt; 関数を用いるようだ(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:mkLogFunc"&gt;&lt;code&gt;mkLogFunc&lt;/code&gt;&lt;/a&gt; 関数もあるがアドバンスドと書いてある．)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  envConfig &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getConfig&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \envLogFunc &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runRIO &lt;span class="dt"&gt;Env&lt;/span&gt;{&lt;span class="fu"&gt;..&lt;/span&gt;} action&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="ot"&gt;action ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;action &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="例外"&gt;例外&lt;/h4&gt;
&lt;p&gt;例外をどのように表現すべきかは結構議論されており，今のところの基本的アイデアは以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lookup&lt;/code&gt; のような単純に失敗する関数(部分関数になり得る？)の場合は &lt;code&gt;Maybe&lt;/code&gt; や &lt;code&gt;Either&lt;/code&gt; を返そう&lt;/li&gt;
&lt;li&gt;それらを使いたくない場合(大域脱出とか？)は例外を使って
&lt;ul&gt;
&lt;li&gt;純粋なコード(IOではなく)の場合は &lt;code&gt;MonadThrow&lt;/code&gt; 制約を使う&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; の場合は &lt;code&gt;thorowIO&lt;/code&gt; を介した実行時例外を使う(&lt;code&gt;RIO&lt;/code&gt; モナドも同じ)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「IOアクションがどのように失敗するかを正確に把握できないことにより，不安と不満を感じるかもしれない．しかし，その痛みを受け入れて共存し内在化して，&lt;code&gt;tryAny&lt;/code&gt; を用いて移動してください．これは非同期例外に対して支払う代償です．」
&lt;ul&gt;
&lt;li&gt;ちょっと何言ってるかよくわからない…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全てのリソース割り当ては &lt;code&gt;bracket&lt;/code&gt; や &lt;code&gt;finally&lt;/code&gt; のような関数で行う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のようにして，アプリ専用の例外を定義し使用することが推奨されている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;FilePathError&lt;/span&gt; FilePath&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Exception&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;  show &lt;span class="fu"&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;    &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;network error: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; (unpack err)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;    &lt;span class="dt"&gt;FilePathError&lt;/span&gt; fp &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;error accessing filepath at: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; fp&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;    &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;this codepath should never have been executed. Please report a bug.&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに，&lt;code&gt;Exception&lt;/code&gt; 型クラス(というか &lt;a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Exception-Base.html#t:SomeException"&gt;&lt;code&gt;SomeException&lt;/code&gt;&lt;/a&gt; 型)は，いわゆる存在型を利用して具体型(&lt;code&gt;AppExceptions&lt;/code&gt; とか)を隠蔽している．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;疑問なところは，投げた例外を &lt;code&gt;catch&lt;/code&gt; してからディスパッチして良いのだろうか？ 実行時例外じゃなくて大域脱出をしたいだけなんだけどな． ちょっとイマイチ使い方が分からない．&lt;/p&gt;
&lt;h3 id="strict"&gt;Strict&lt;/h3&gt;
&lt;p&gt;特別な理由が無い限り，データフィールド(レコードのフィールド？？)は正格にすべき，とのこと． 割と重要そうなのに一文しかない．&lt;/p&gt;
&lt;h3 id="プロジェクトテンプレート"&gt;プロジェクトテンプレート&lt;/h3&gt;
&lt;p&gt;そのうち，新しい Stack テンプレートを作るそうだ． もちろん，&lt;code&gt;cabal&lt;/code&gt; ファイルは使わず &lt;code&gt;hpack&lt;/code&gt; を使用する．&lt;/p&gt;
&lt;h3 id="安全第一"&gt;安全第一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; は安全性を最優先しており，そのため部分関数と遅延 I/O を全力で避けている． もし，遅延 I/O を使いたい場合は &lt;code&gt;conduit&lt;/code&gt; のようなストリーミングライブラリを使いなさい，とのこと．&lt;/p&gt;
&lt;h3 id="一般化"&gt;一般化&lt;/h3&gt;
&lt;p&gt;Haskell のよくある疑問として，いつ一般化すべきか，というのがある(いつ？)． README にはいくつかの簡単なガイドラインが書いてある．&lt;/p&gt;
&lt;p&gt;パラメトリック多相の場合，わりと議論の余地が無く，多相的な方が有用． つまり，&lt;code&gt;reverse :: [a] -&amp;gt; [a]&lt;/code&gt; は &lt;code&gt;reverse :: [Int] -&amp;gt; [Int]&lt;/code&gt; より優れている．&lt;/p&gt;
&lt;p&gt;型クラスの場合は話が微妙になる． &lt;code&gt;Foldable&lt;/code&gt; や &lt;code&gt;Traversable&lt;/code&gt; のような &lt;code&gt;RIO&lt;/code&gt; で定義済みの型クラスには可能な限り一般化(インスタンスを定義)するのが良いだろう． しかし，本当の疑問は &lt;strong&gt;自身で型クラスを定義すべきかどうか&lt;/strong&gt; の場合． 原則としては可能な限りそれは避けるべきだ． もし，自身で型クラスを定義している場合は，&lt;strong&gt;自分が期待していなかった型がインスタンス化されてもバグが起きないよう&lt;/strong&gt; に気を付けること，とのこと．&lt;/p&gt;
&lt;h3 id="コーディングスタイル"&gt;コーディングスタイル&lt;/h3&gt;
&lt;p&gt;議論中だそうだ．&lt;/p&gt;
&lt;h3 id="モジュール階層"&gt;モジュール階層&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RIO.Prelude.XXX&lt;/code&gt; モジュールはドキュメントを Haddock で読みやすくするための階層で，個別にインポートすることを想定しているわけではない． と書いてあるが，結局 &lt;a href="https://github.com/commercialhaskell/rio/pull/72"&gt;ver.0.1 からは Haddock からも消えてしまった&lt;/a&gt;ので気にする必要はない．&lt;/p&gt;
&lt;h1 id="io-まわり"&gt;I/O まわり&lt;/h1&gt;
&lt;p&gt;(この話は README に書いてあるわけではないです)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIO&lt;/code&gt; モジュールには文字列型(&lt;code&gt;String&lt;/code&gt;)の一般的な &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; のような I/O 関数は無い． 実用コードの場合，これらの関数を直接呼ぶことは稀だろうが，例えば CLI を作ったときに &lt;code&gt;--version&lt;/code&gt; オプションでバージョン情報を出力したい場合などがある．&lt;/p&gt;
&lt;p&gt;替わりとして次のような I/O 関数が提供されている．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Strict.ByteString&lt;/code&gt; 型の &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; であれば &lt;code&gt;RIO.ByteString&lt;/code&gt; モジュールで再定義されている&lt;/li&gt;
&lt;li&gt;ファイルの入出力であれば &lt;code&gt;RIO&lt;/code&gt; モジュールに &lt;code&gt;Strict.ByteString&lt;/code&gt; 版と &lt;code&gt;Text&lt;/code&gt; 版が提供されている&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt; 型の標準出力 &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:hPutBuilder"&gt;&lt;code&gt;hPutBuilder&lt;/code&gt;&lt;/a&gt; 関数ならある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンソールに対する I/O はどれを使うべきかはまだ&lt;a href="https://github.com/commercialhaskell/rio/issues/5"&gt;議論中&lt;/a&gt;みたいだ．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;何となく&lt;a href="https://github.com/matsubara0507/scrapbook/tree/rio"&gt;置き換えはできた&lt;/a&gt;けど，例外や I/O 回りは良く分かってない… また試していこう．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/02/windows-windows10.html</id><title type="text">[windows] Windows10セットアップ・設定項目のメモ</title><updated>2018-04-12T13:07:28.167+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/02/windows-windows10.html"/><summary type="text">Windows10セットアップ時の設定項目、インストールアプリの備忘録。


スタートメニュー・タスクバーの設定

タスクバーの設定 

小さいタスクバーボタンを使う：オン 
[スタート]ボタンを右クリックするかWindowsキー＋Xキーを押したときに表示されるメニューで、コマンドプロンプトをWindows PowerShellに置き換える：オフ
タスクバーボタンを結合する

「タスクバーに入りきらない場合」を選択

タスクバーをすべての ディスプレイに表示する：オフ



 Quick Launcherを表示する

クイック起動を復活する 
Windows 10 タスクバーにクイック起動を表示する

スタートメニューにコントロールパネルを表示する

「Windows 10」のコントロールパネルを表示する方法について

スタートメニューにピン止めするアプリ：

Windowsシステム</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html</id><title type="text">ML Day ＃1 に行ってきた</title><updated>2018-04-02T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;ML Day ＃1 に行ってきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-02" itemprop="datePublished"&gt;
        Apr 2, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://ml-lang.connpass.com/event/78199/"&gt;ML Day #1&lt;/a&gt; というイベントに参加してきたので，そのメモ？まとめ？みたいな感じの記事です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ML Day は毎年やってるML勉強会というML系の発表会形式の勉強会のこと． (なぜか)名前を変えたらしい． ちなみに，今後は半年に一回ペースでやりたいらしい．&lt;/p&gt;
&lt;h2 id="ぼくのはなし"&gt;ぼくのはなし&lt;/h2&gt;
&lt;p&gt;新設された LT 枠で発表してきた．&lt;/p&gt;
&lt;p&gt;スライドはこれ&lt;/p&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/o84VhGTUREO4No" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;さすがに Haskell の話をするのはアレだったので，Haskell の新しいモジュールシステム Backpack のベースになった MixML の話をした． この日までに(Haskellで)実装完了してドヤ顔する予定だったのだが全然終わらなかった orz (Alt braif*ck じゃなくて)ちゃんとした規模の処理系を実装するのって，大変なんですね…&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;a href="https://github.com/rossberg/mixml"&gt;SML/NJ で実装されたもの&lt;/a&gt;があり，実質これを参考に Haskell で書き直すだけの作業． だけど SML -&amp;gt; Haskell に直すのって大変，非純粋なものを純粋な世界にするって大変(そりゃそう)． 気軽に状態を持ちやがって…&lt;/p&gt;
&lt;h2 id="自分的ハイライト"&gt;自分的ハイライト&lt;/h2&gt;
&lt;p&gt;濃い目の話が多かったのでざっくりと．&lt;/p&gt;
&lt;p&gt;資料は既に&lt;a href="https://ml-lang.connpass.com/event/78199/presentation/"&gt;ほとんど上がっている&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="ml型付の基礎の基礎"&gt;ML型付の基礎の基礎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/haochenxie"&gt;Haochen&lt;/a&gt; くん
&lt;ul&gt;
&lt;li&gt;名〇屋で &lt;a href="https://sicss.connpass.com/event/71199/"&gt;TaPL の読書会&lt;/a&gt;を主催してるひと&lt;/li&gt;
&lt;li&gt;こんど&lt;a href="https://nupsc.sicss.org/"&gt;名古屋でプロコン&lt;/a&gt;やるんだって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haochenxie.name/dl/the_introduction_of_foundation_of_ml_type_checking.pdf"&gt;資料はコレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基礎 (foundation) の 基礎 (introduction) の話
&lt;ol type="1"&gt;
&lt;li&gt;型は素晴らしい&lt;/li&gt;
&lt;li&gt;でも型を書きたくない
&lt;ul&gt;
&lt;li&gt;プログラマは怠惰を美徳にしている生き物だもんね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再構築すればいいじゃない！
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;型検査無しにもどるなんてのは論外&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;素晴らしい本(TaPL)と素晴らしい先生(ピアース先生)
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;ML Day 出る以上読め&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;おまけとして let 多相の話もしてた&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sicss.connpass.com/event/83801/"&gt;5/6に論理プログラミング言語の第一人者の講演&lt;/a&gt;を企画しているらしい
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://readcoqart.connpass.com/event/83722/"&gt;Coq 勉強会&lt;/a&gt;と被ってるのがなぁぁぁぁ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tba"&gt;TBA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href="https://twitter.com/pi8027"&gt;坂口和彦&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;PPL2018 のポスター賞の人でその話を&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発表スライドは上がってないけど &lt;a href="http://logic.cs.tsukuba.ac.jp/~sakaguchi/posters/ppl2018.pdf"&gt;PPL2018 のポスター&lt;/a&gt;はあった&lt;/li&gt;
&lt;li&gt;Coq でリストの置換(permutation)の自動証明(だったかな)
&lt;ul&gt;
&lt;li&gt;証明の過程をいろいろ話してくれた&lt;/li&gt;
&lt;li&gt;(がぼくはよくわかってない)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sqlab.jp/FLOPS2018/"&gt;FLOPS’18&lt;/a&gt; に通ったので発表するらしい&lt;/li&gt;
&lt;li&gt;質問: 項書き換えでできないの？
&lt;ul&gt;
&lt;li&gt;中野先生に聞かれた(PPLで？？)&lt;/li&gt;
&lt;li&gt;出来たら教えてといって何もないのでできないんじゃない？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="型つき組版処理システムsatysfi"&gt;型つき組版処理システムSATySFi&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/bd_gfngfn"&gt;bd_gfngfn&lt;/a&gt; 氏&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://drive.google.com/file/d/1BB7ZAiwPO3hVtq7PGImPtMs1-kOd7SzW/view"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;彼の有名な &lt;a href="https://github.com/gfngfn/SATySFi"&gt;型つき組版処理システムSATySFi&lt;/a&gt; の話
&lt;ul&gt;
&lt;li&gt;目標: L〇TeX を倒す&lt;/li&gt;
&lt;li&gt;目標: エラーの可読性向上(大事)&lt;/li&gt;
&lt;li&gt;ML系に似た組版用型システムが載っている
&lt;ul&gt;
&lt;li&gt;let 多相もレコード多相もある&lt;/li&gt;
&lt;li&gt;しかし GADT や Functor はまだ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「いきなり PDF がでまして」をよく言っていた(笑)&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;質問: 構文にポリシーはあるの？
&lt;ul&gt;
&lt;li&gt;ML系の文法にしたい(けど LaTeX に寄せたほうが…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="mlでつくる拡張可能インタプリタ"&gt;MLでつくる拡張可能インタプリタ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/linerlock"&gt;linerlock&lt;/a&gt; 氏
&lt;ul&gt;
&lt;li&gt;今日までつくば大生
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;これのせいで二番煎じに&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://speakerdeck.com/takahisa/extensible-interpreter-in-ml"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;言語開発 &lt;strong&gt;も&lt;/strong&gt; モジュラーにしたいので拡張可能なインタプリタを作ればいいじゃない
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/takahisa/kennel"&gt;コレ&lt;/a&gt;のことかな？&lt;/li&gt;
&lt;li&gt;例えば超簡易的な自作言語に新しくリスト追加してと言われても簡単にできるように&lt;/li&gt;
&lt;li&gt;評価器は楽しいので(拡張可能な評価器の)研究が多い&lt;/li&gt;
&lt;li&gt;構文解析は無い…なのでここをサイボウズラボユースでやった(？)
&lt;ul&gt;
&lt;li&gt;構文解析の無い言語なんてないのにね&lt;/li&gt;
&lt;li&gt;作ったの&lt;a href="https://github.com/takahisa/finale"&gt;コレ&lt;/a&gt;かな？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「(BNFに新しい構文を)上に足すか下に足すか、花火じゃないけど」
&lt;ul&gt;
&lt;li&gt;上に足すか下に足すかで意味が変わることが…&lt;/li&gt;
&lt;li&gt;そこで最長一致法 : 全部試して一番長いのをとる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;型とか最適化とかできてない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lt"&gt;LT&lt;/h3&gt;
&lt;p&gt;は割愛(つかれた)． ラインナップは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自作言語を OCaml で作り直したら ML みたいなコア言語になってしまったという話&lt;/li&gt;
&lt;li&gt;Elm の紹介&lt;/li&gt;
&lt;li&gt;OCaml の祖先 CAML の解説&lt;/li&gt;
&lt;li&gt;自作したパーサージェネレーターの紹介&lt;/li&gt;
&lt;li&gt;Verifastの辛い話(&lt;del&gt;古いOCamlを使うのつらいという愚痴&lt;/del&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LT の資料は全部 connpass にあがっている．&lt;/p&gt;
&lt;h3 id="コンパイラバックエンド"&gt;コンパイラバックエンド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href=""&gt;インターネットの闇&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;この会の主催者(？)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OCaml のソースコードを皆で読もうの会
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;バックエンドはコンパイラのコト&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;not Webバックエンド&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ガリグ先生しか読めない化け物(type系)&lt;/li&gt;
&lt;li&gt;OCaml のバックは副作用ガンガン使う、FPとは？GC付きのC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bucklescriptでノベルゲームdslを作る"&gt;BuckleScriptでノベルゲームDSLを作る&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は[pocketberserker]氏
&lt;ul&gt;
&lt;li&gt;普段は F# の人&lt;/li&gt;
&lt;li&gt;F# ネタが切れた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://github.com/pocketberserker/ml_day_1"&gt;ココ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;資料もこの DSL で書かれたもの(？？)&lt;/li&gt;
&lt;li&gt;ノベルゲーなのでバックができない(笑)&lt;/li&gt;
&lt;li&gt;発表者はデバッグモードで戻ってた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノベルゲーDSLを作りたい遺伝子を持ってしまったので作るという話
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/cowlick/cowlick"&gt;つくったやつ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自分が今書いてるのはS式なのか？？？？S式が分からなくなる&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;strong&gt;Reason を ML ユーザーが触るべきではない！&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="感想"&gt;感想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;濃い(誉め言葉)&lt;/li&gt;
&lt;li&gt;後半は疲れてしまった(ごめん)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;質問時間を含めて発表時間(律儀に終わる必要はない)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;MixML 完成させてリベンジ発表したい&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/03/31/145715</id><title type="text">.NETがむずかしい</title><updated>2018-03-31T14:57:15+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/03/31/145715"/><summary type="html">MSのエコシステムがよくわからなくていろいろ調べている。調べたのはこんなところ。 .NET のランタイム環境は複数ある Windows では、.NET Framework と .NET core macOS では、mono と .NET core mono はCLIで扱える ( mono コマンド) .NET core はCLIで扱える( dotnet コマンド) というか、それぞれにコンパイラとかツールセットが付いてるんだろうけど、環境によってコマンド名などは一緒なんだろうか？ Visual Studio では .NET Framework のアプリを作れる そして .NET core も作…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/06/18/230000</id><title type="text">AtCoder Beginner Contest 040</title><updated>2018-03-28T12:17:31+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/06/18/230000"/><summary type="html">A - 赤赤赤赤青 n個の中の特定の一つのブロックを隣り合うブロックの入れ替えによって両端のいずれかに移動する最小の回数。 main :: IO () main = getContents &gt;&gt;= print . (\[n, x] -&gt; min (x - 1) (n - x)) . map read . words B - □□□□□ n個のタイルをどれだけたくさん使ってできる限り正方形に並べられるか。指標は二辺の差と使い切れなかったタイルの数の和が最小のもの。 main :: IO () main = readLn &gt;&gt;= print . solve solve :: Int -&gt; Int …</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/08/08/100000</id><title type="text">CSVファイルをSQLのクエリで集計できるqコマンドをHaskellで実装してみました！</title><updated>2018-03-28T12:14:06+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/08/08/100000"/><summary type="html">先日、Twitterでqコマンドが話題になっていました。 github.com スターが3000を超えていてすごいですね。2014年から開発されているツールで、Pythonで書かれています。 これはGoで実装してみたいなーと思っていたところ、mattnさんが素早く実装されていました。 mattn.kaoriya.net 一本取られたと思ったものの、よく読むとまだ標準入力しか対応していないようです。 いったいどういう仕組みなのか、何の実装が難しいところなのか、qコマンドが嬉しい場面はどういうケースなのか、自分も知りたくなったので1から実装してみました。 私が一番素早く書ける言語ということでHas…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/07/25/100000</id><title type="text">30のプログラミング言語でFast inverse square rootを実装してみました！</title><updated>2018-03-28T12:13:22+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/07/25/100000"/><summary type="html">あなたの好きな言語は何ですか。そして、あなたの好きなアルゴリズムは何ですか。 好きな言語があると、その言語でどんな問題でも解決しようとなりがちになります。その言語を極めるのは素晴らしいことですが、その言語や似たような言語でしかコードが書けなくなったり、他の言語に対して見向きもしなくなってしまう可能性があります。 勇気を出して新しい言語にチャレンジしてみませんか？色々な言語に挑戦してみませんか？ 何から始めればいいか分からない。次にどの言語を学べばいいか分からない。いま特に何も困っていない。何でも得意な言語で書けてしまう。そういう人が多いのではないでしょうか。 新しい言語にチャレンジするきっかけ…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/12/31/210000</id><title type="text">2016年を振り返って</title><updated>2018-03-28T10:48:21+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/12/31/210000"/><summary type="html">会社は二年目に入り業務にも慣れ、ある程度まとまった仕事を任せられるようになりました。 携わっているサービスのコードに詳しくなり、リファクタリングの方向性を示して改善を進めてきました。 難しい障害も乗り越えながら、引き継いだ手綱を何とか制御できるようになってきたという所感です。 今年は18記事書きました。特に反響の大きかったエントリーは次の3つの記事でした。 内容の方向性もバラバラであまり何したいかよく分からなくなっていますね。どういう技術を学んでいくか悩んでいた一年だったと思います。ブログには書いていませんが、Vimのソースコードをいじったりmrubyのコードを読み込んだりしていた時期もありま…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/08/23/110000</id><title type="text">JavaScriptのsetTimeoutをログに出す</title><updated>2018-03-28T10:48:09+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/08/23/110000"/><summary type="html">setTimeoutは難しい。いつ呼ばれるかよく分からないし、ライブラリーを使うとそのライブラリーがsetTimeoutを使いすぎてしまう。よく分からなかったけどsetTimeoutすると動くからそうしていた、んだけど実はタイミングの関係で偶然うまく動いているように見えているだけだった、なんてこともよくある。 ウェブアプリケーションの描画が遅い。「なぜか遅い」が、処理を丁寧に追っていっても手がかりがつかめないということがある。色々な方法を駆使した後に、なぜかsetTimeoutの発火が遅いということにたどり着いた。どれくらい遅いか。 window.setTimeout = (function(…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/03/06/100000</id><title type="text">LLVM APIを使ってみよう！ 〜 Brainf**kコンパイラをIRBuilderで書き直してみた 〜</title><updated>2018-03-28T10:44:28+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/03/06/100000"/><summary type="html">先日LLVMの入門記事を書きました。 clangが吐くLLVM IR (Intermediate representation, 中間表現) を頼りに、Brainf**kのコンパイラを書いてみました。 itchyny.hatenablog.com この記事で書いたコードでは、直接printfでLLVM IRの命令を出力していました。 このステップを踏むことで、LLVM IRの命令をどう調べればいいかについて身についたと思います。 しかし、この「コンパイラ」は次のような問題がありました。 bf2llvmコマンドが出力するのがLLVM IRのために、lliやllcといったLLVM IRのランタイム…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/02/27/100000</id><title type="text">LLVMを始めよう！ 〜 LLVM IRの基礎はclangが教えてくれた・Brainf**kコンパイラを作ってみよう 〜</title><updated>2018-03-28T10:33:19+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/02/27/100000"/><summary type="html">コンパイラを作ってみたいと思っていても、アセンブリ言語はよくわからない。 パーサーみたいなコードは書いたことがあるけれど、コード生成の処理はさっぱりだ。 実行ファイルをバイナリエディターで見るとかなにそれ怖い。 そんな私なのですが、LLVMに興味を持ち始めています。 SwiftやRust、あるいはEmscriptenなど、近年注目されている言語やコンパイラ技術の中枢にはLLVMがあります。 アセンブリはよく分からなくてもLLVMを使いこなせるようになれば、マルチプラットフォームで実行ファイルを生成できる言語処理系を作るのではないか。 コンパイラ作ってみたいな、LLVMを使ってみようかなと思って…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/03/14/159265</id><title type="text">円周率の16進数表現100億桁目を求めてみた！ ― 円周率の世界記録をどのように検証するか ―</title><updated>2018-03-28T10:31:51+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/03/14/159265"/><summary type="html">あなたは円周率を何桁言えますか。3.14159…という、あの数字です。 円周率の小数部分は無限に続き、循環することもありません。 古来より、数学者は円周率の値を様々な幾何学的な近似や公式を用いて計算してきました。 その桁数は計算機の発明により飛躍的に伸び、収束の速い公式の発見や効率の良いアルゴリズムの発明などによって加速してきました *1。 5年前、私がまだ学生だった頃、円周率1億桁の計算に挑んだことがありました。 私にとって高精度計算の初めての挑戦で、様々な試行錯誤で苦労したのをよく覚えています。 itchyny.hatenablog.com 2017年現在、円周率計算の世界記録は22兆桁で…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/04/21/200000</id><title type="text">VimプラグインのTravis CIテストを複数のVimのバージョンで動かそう</title><updated>2018-03-28T10:30:13+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/04/21/200000"/><summary type="html">Vimプラグインにテストがあるのはあたりまえ。 そういう空気になってきたのはここ3年くらいのことでしょうか。 私自身、昔はあまりテスト文化に慣れておらず、「Vimプラグインみたいな小さなスクリプトにテストなんているのか？自分のプラグインは普段から使う、バグっていたらすぐ気がつくからテストなんていらないでしょ」と思っていました。 しかし、そういうテストのない自作プラグインがどんどん増えていき、3年4年と経ってしまうと自分のプラグインのコードを触りにくくなってきました。 昔はあまりVimプラグインの書き方に慣れていなかったので、酷いコードが絡み合っているのだけど、普段使う分には普通に便利なプラグイ…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/05/30/223000</id><title type="text">lightline.vimのREADME.mdを書き直しました</title><updated>2018-03-28T10:29:32+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/05/30/223000"/><summary type="html">lightline.vimはVimのステータスラインをいい感じにしてくれるプラグインです。 作って四年弱経つんですね。 おかげさまで多くのユーザーさまに使っていただいています。 itchyny.hatenablog.com github.com このREADME.mdを最近書き換えました。 ……… それだけかいな！って感じなのですが、いろいろと大変でした… 主に精神的に… つらい… プラグインを作った勢いと使って欲しいという強い思いで、プラグインを作ってすぐにREADME.mdをかなり詳しく書いていた そのために当初の設計や実装時の思いが強く出ていたが、初めてプラグインを触る人にとっては読みに…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/12/31/170000</id><title type="text">2017年を振り返って</title><updated>2018-03-28T10:27:47+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/12/31/170000"/><summary type="html">今年は仕事で関わっているプロダクトが大きな転換期を迎えて、様々な経験ができました。 ミドルウェアを自ら作り上げ、データをオンラインで移行し、運用を始めるというのはなかなか経験できないことだと思います。 サービスは以前より安定し、穏やかな年末を過ごしています。 今年は初めてカンファレンスで登壇しました。 慣れないことばかりで色々と戸惑いましたが、沢山の方に発表を聞きに来ていただいて嬉しかったです。 マネージドサービスを組み合わせて1つのソフトウェアを作り、それをサーバーレスミドルウェアとして抽象度を上げて捉えることができるようになったもの、このカンファレンスに参加してよかったことでした。 今年は…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html</id><title type="text">多相バリアントを使いこなそう with Haskell</title><updated>2018-03-24T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;多相バリアントを使いこなそう with Haskell&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-03-24" itemprop="datePublished"&gt;
        Mar 24, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://sampou.connpass.com/event/80492/"&gt;この前の「『Haskellによる関数プログラミングの思考法』読書会」&lt;/a&gt;の後の懇親会(？)で &lt;strong&gt;多相バリアント&lt;/strong&gt; の話になりまして，その時に以下の記事が話題にあがった．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090512/1242055541"&gt;多相バリアントを使いこなそう(2) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090516/1242456737"&gt;多相バリアントを使いこなそう(4) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの記事は OCaml で多相バリアントの紹介をしています． ということで，同様の議論を Haskell でもしてみた！というのが，この記事の内容です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;(2018.04.13 追記アリ)&lt;/p&gt;
&lt;h3 id="haskell-と多相バリアント"&gt;Haskell と多相バリアント&lt;/h3&gt;
&lt;p&gt;悲しいことに，Haskell には組み込みで多相バリアントは無い(バリアントとは Haskell の代数的データ型における直和型と概ね一緒)． なので，多相バリアントを Haskell で模倣するために，毎度おなじみ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージを用いる．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ネタバレをすると Haskell で同じことをするのは難しかった． なので，本質的な議論は osiire’s blog の方を読んだ方がいいと思うよ． 結局，本記事は osiire’s blog のと同様のことを Haskell もとい，&lt;code&gt;extensible&lt;/code&gt; パッケージでどのように行うか，という記事って感じになった．&lt;/p&gt;
&lt;h2 id="多相バリアントの基本"&gt;多相バリアントの基本&lt;/h2&gt;
&lt;p&gt;多相バリアントとは，名前の通り，多相的なバリアントである． バリアントは前述したとおり，直和型と基本的に同じ．&lt;/p&gt;
&lt;p&gt;例えば，普通の直和型として次のようなものがあったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Joker&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Str&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;「最初の型はジョーカーと数字札があるトランプの型，次の型は何かファイルからデータを読み込む時に文字列と数字のデータを統一的に扱うための型」だそうです(&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1)&lt;/a&gt; より)． どちらの型にも &lt;code&gt;Number Int&lt;/code&gt; という部分があるので次のような関数を両方に適用できそうな気がする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;getNumber (&lt;span class="dt"&gt;Number&lt;/span&gt; n) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; n&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;getNumber _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，そんなことはできない(そもそも，Haskell の値コンストラクタは名前空間を共有してしまうので同時に利用はできないのだが…)． そこで多相バリアントを用いれば，このような関数を実装することが出来るようになる．&lt;/p&gt;
&lt;h3 id="多相バリアントを定義"&gt;多相バリアントを定義&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;extensible&lt;/code&gt; パッケージを使って多相バリアント(拡張可能バリアント)を定義すると次のようになる(&lt;code&gt;DataKinds&lt;/code&gt; と &lt;code&gt;TypeOperators&lt;/code&gt; 言語拡張が必要)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;joker&amp;quot; &amp;gt;: (), &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;str&amp;quot; &amp;gt;: String, &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とくに細かい説明はしないが，なんとなく意味が読み取れるだろう． &lt;code&gt;getNumber&lt;/code&gt; 関数の実装は難しいので後回しにするとして，&lt;code&gt;getNumber&lt;/code&gt; 関数の型は &lt;code&gt;extensible&lt;/code&gt; パッケージの &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#t:-8838-"&gt;&lt;code&gt;⊆&lt;/code&gt;&lt;/a&gt; 型クラスを用いて次のように書ける(意味は見た通り)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE FlexibleContexts #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHCi で試してみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに動作する．&lt;/p&gt;
&lt;h2 id="包含関係"&gt;包含関係&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;getNumber&lt;/code&gt; 関数をどのように実装するかだが，その前に多相バリアントの包含関係を議論しておく(この議論は&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3)&lt;/a&gt;に対応する)．&lt;/p&gt;
&lt;p&gt;次のような簡単なバリアント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;fuga&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このバリアント型に対し，&lt;code&gt;⊆&lt;/code&gt; を用いて多相的な関数は2種類考えれる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; と &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; を要素に持つバリアント型全てが利用できる関数である(さっきの &lt;code&gt;getNumber&lt;/code&gt; と同じ)． &lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; か &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; のどれかを要素に持つ(それ以外は持ってはいけない)バリアント型全てに利用できる関数である． 試しに，次の3つのバリアント型の値を定義し，GHCi で試してみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;hoge1 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="ot"&gt;hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;piyo&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; () &lt;span class="ch"&gt;&amp;#39;: HogeFields)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;hoge2 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;piyo &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;hoge&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;hoge3 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;見てわかるように(？)，&lt;code&gt;hoge3 ⊆ hoge1 ⊆ hoge2&lt;/code&gt; である(厳密にはバリアントの要素の集合で成り立つ関係だが)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;toInt1&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;toInt1&lt;span class="ot"&gt; hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;fuga&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt1’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;toInt2&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-16" data-line-number="16"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-17" data-line-number="17"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;piyo&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-18" data-line-number="18"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-19" data-line-number="19"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt2’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-20" data-line-number="20"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-21" data-line-number="21"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-22" data-line-number="22"&gt;toInt2&lt;span class="ot"&gt; hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに，&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge2&lt;/code&gt; に適用でき，&lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge3&lt;/code&gt; に適用できている．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;toInt1&lt;/code&gt; と &lt;code&gt;toInt2&lt;/code&gt; の実装を与えてみる． 実は簡単なのは後者 &lt;code&gt;toInt2&lt;/code&gt; だ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; flip matchField (spread&lt;span class="ot"&gt; xs ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;a href="https://matsubara0507.github.io/posts/2017-11-28-fun-of-extensible-1.html"&gt;昔の記事&lt;/a&gt;でも紹介した) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#v:spread"&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; 関数を用いることで &lt;strong&gt;バリアント型を拡張できる&lt;/strong&gt; (&lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; 関数の使い方についてはこの&lt;a href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html"&gt;記事&lt;/a&gt;を参照して)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;shrink ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="ot"&gt;spread ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; ys&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;del&gt;拡縮する関数 &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; は強力なのだが，多相的すぎて前後の型が分からないとエラーになる(気がする(パッケージの作者じゃないので細かいことはよくわからん))ので，型注釈 (&lt;code&gt;spread xs :: Hoge&lt;/code&gt; の部分)を与える必要がある．&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(2018.04.13 追記) &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; の代わりに &lt;code&gt;shrinkAssoc&lt;/code&gt; や &lt;code&gt;spreadAssoc&lt;/code&gt; を使えば値が多相でもうまく扱えるとのコトを&lt;a href="https://www.reddit.com/r/haskell_jp/comments/86rx9b/多相バリアントを使いこなそう_with_haskell/dwaq3cw/"&gt;作者様よりコメント&lt;/a&gt;いただいた． 感謝．&lt;/p&gt;
&lt;h3 id="必殺-coinclusion"&gt;必殺 Coinclusion&lt;/h3&gt;
&lt;p&gt;前者が難しいのは，&lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; とは逆の振る舞いを要求するからだ． そのために(この前作者から教えてもらった隠し技(別に隠してない)) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使う！ &lt;code&gt;Nullable&lt;/code&gt; を使うとバリアントやレコードの全ての要素を簡単に &lt;code&gt;Maybe&lt;/code&gt; でラップできる(なんかいいテーマがあったら，そのうち解説する)． さらに &lt;code&gt;Nullable&lt;/code&gt; を用いることで，Coinclusion を定義できる！&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;wrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:*&lt;/span&gt; xs) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; h &lt;span class="fu"&gt;:*&lt;/span&gt; ys&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;retrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:|&lt;/span&gt; ys) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; ((&lt;span class="fu"&gt;:|&lt;/span&gt;) h) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;wrench&lt;/code&gt; や &lt;code&gt;retrench&lt;/code&gt; は &lt;code&gt;shrink&lt;/code&gt; と &lt;code&gt;spread&lt;/code&gt; の逆向きの変換になっているのが分かるだろうか？ 逆向きにしたせいで足りない部分は &lt;code&gt;Nullable&lt;/code&gt; によって &lt;code&gt;Nothing&lt;/code&gt; となる． 例えば &lt;code&gt;Variant (&amp;quot;piyo&amp;quot; &amp;gt;: () ': HogeFields)&lt;/code&gt; から &lt;code&gt;Hoge&lt;/code&gt; に縮小する場合は，&lt;code&gt;embedAssoc (#piyo @= ())&lt;/code&gt; が &lt;code&gt;Nothing&lt;/code&gt; となり，他が &lt;code&gt;Just&lt;/code&gt; でラップされる．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;Coinclusion を用いて &lt;code&gt;toInt2&lt;/code&gt; 関数を実装してみると次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds           #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RankNTypes          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE ScopedTypeVariables #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;&lt;span class="ot"&gt;matchFieldWithDefault ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" data-line-number="12"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" data-line-number="13"&gt;matchFieldWithDefault defaultValue pat &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" data-line-number="14"&gt;  fromMaybe defaultValue &lt;span class="fu"&gt;.&lt;/span&gt; matchFieldWithMaybe pat&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" data-line-number="16"&gt;&lt;span class="ot"&gt;matchFieldWithMaybe ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" data-line-number="17"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" data-line-number="18"&gt;matchFieldWithMaybe pat &lt;span class="fu"&gt;=&lt;/span&gt; matchWith func (wrench pat)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" data-line-number="19"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" data-line-number="20"&gt;&lt;span class="ot"&gt;    func ::&lt;/span&gt; forall x &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r)) x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; h x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" data-line-number="21"&gt;    func fx gx &lt;span class="fu"&gt;=&lt;/span&gt; (\x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runMatch (getField x) &lt;span class="fu"&gt;$&lt;/span&gt; getField gx) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getNullable fx&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;めんどくさいので細かい解説はしない(そもそももっといい方法があるかもしれない)． この &lt;code&gt;matchFieldWithMaybe&lt;/code&gt; を用いれば &lt;code&gt;getNumber&lt;/code&gt; も簡単に実装できるだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithMaybe &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-イベントを拡張する"&gt;例 : イベントを拡張する&lt;/h2&gt;
&lt;p&gt;ここからは「多相バリアントを使いこなそう」で取り上げられてた例を Haskell で示そう． ひとつ目は次のふたつのイベント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;keyPress&amp;quot; &amp;gt;: Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;keyRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;mousePress&amp;quot; &amp;gt;: (Int, Int)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;mouseRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;click&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて，これらの両方の型許容する型 &lt;code&gt;Event&lt;/code&gt; を作りたい． 普通の直和型を用いて次のように書くことが出来る．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Key&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Mouse&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，これでは元のふたつの型をうまく再利用できていない． 既に何度か登場している型レベルリストの連結 &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#t:-43--43-"&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt; を使って次のように書くこともできる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすると，&lt;code&gt;Event&lt;/code&gt; 型と &lt;code&gt;KeyboardEvent&lt;/code&gt; 型・&lt;code&gt;MouseEvent&lt;/code&gt; 型には包含関係ができ，前述した &lt;code&gt;Hoge&lt;/code&gt; 型で示した方法により各々で関数を共有することが出来る． 例えば次の &lt;code&gt;getCharFromEvent&lt;/code&gt; 関数は &lt;code&gt;KeyboardEvent&lt;/code&gt; 型と &lt;code&gt;Event&lt;/code&gt; 型の両方で利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getCharFromEvent ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;getCharFromEvent &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault (error &lt;span class="st"&gt;&amp;quot;not a key&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyPress   &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyRelease &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-トランプで-expression-problem"&gt;例 : トランプで Expression Problem&lt;/h2&gt;
&lt;p&gt;Expression Problem が何なのかは各位ググってもらうとして，「多相バリアントを使いこなそう」の最後で紹介されていた，多相バリアントによる Expression Problem の解法を Haskell でもやってみる．&lt;/p&gt;
&lt;p&gt;次のような型と関数があったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;number&amp;quot; &amp;gt;: Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;jack&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;queen&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;king&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-7" data-line-number="7"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-9" data-line-number="9"&gt;&lt;span class="ot"&gt;cardNum ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-10" data-line-number="10"&gt;cardNum &lt;span class="fu"&gt;=&lt;/span&gt; matchField cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-12" data-line-number="12"&gt;&lt;span class="ot"&gt;cardNumPattern ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-13" data-line-number="13"&gt;cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;11&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-16" data-line-number="16"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;12&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-17" data-line-number="17"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;13&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-18" data-line-number="18"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;cardNumPattern&lt;/code&gt; を切り出しているのがあからさまに恣意的だが…)これに以下のことは可能だろうか？&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(キャストせず)&lt;/li&gt;
&lt;li&gt;元のコードを一切変更せず&lt;/li&gt;
&lt;li&gt;新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;新しい操作も加えた&lt;/li&gt;
&lt;li&gt;新しい場合分け構造を定義する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後の「構造」というのは今回は置いておいて(OCaml ではモジュールとして定義してたが，Haskell でモジュールに切り分けるにはファイルを切り分ける必要があるので…めんどい…)，1-4を考えてみよう． &lt;code&gt;Card&lt;/code&gt; 型やその関数を拡張したものとして，次のような &lt;code&gt;CardExt&lt;/code&gt; 型とその関数を定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;joker&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;&lt;span class="ot"&gt;cardExtNum ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;cardExtNum &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" data-line-number="6"&gt;  matchField &lt;span class="fu"&gt;$&lt;/span&gt; shrink (&lt;span class="fu"&gt;#&lt;/span&gt;joker &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; cardNumPattern)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" data-line-number="8"&gt;&lt;span class="ot"&gt;nextCardExt ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" data-line-number="9"&gt;nextCardExt &lt;span class="fu"&gt;=&lt;/span&gt; matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; (\n &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;if&lt;/span&gt; n &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" data-line-number="11"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" data-line-number="12"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" data-line-number="13"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" data-line-number="14"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで一応&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(もちろん!)&lt;/li&gt;
&lt;li&gt;既存のコードを改造せず&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;joker&amp;quot; &amp;gt;: ()&lt;/code&gt; という新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextCardExt&lt;/code&gt; という新しい操作(関数)を加える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ことができた．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;組込みでこれらの機能がある OCaml はいいなぁとなった．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2018/02/11/185306</id><title type="text">HaskellでDiscordのBotを作る</title><updated>2018-03-09T13:45:13+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2018/02/11/185306"/><summary type="html">Discordはゲーミング向けのテキストチャットと音声通話を兼ねるプラットフォームであり、「テキストチャンネル」と「ボイスチャンネル」の二種を好きなだけ作ることができる。もちろん音声を全チャンネルに常時垂れ流すわけには行かないので、通話するにはボイスチャンネルに参加するという手順を踏む必要がある。しかし、例えば誰かがやっているゲームに混ざろうとしてボイスチャンネルに参加しても、チャンネル外のユーザーにはいかなる通知も発生しないため、気づかれないままのことがよくある。 そこで、ボイスチャンネルに参加したとき、テキストチャンネルにその旨を投稿するボットを用意すれば、気軽に通話の合図を送れる。全員に…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/03/07/084537</id><title type="text">F#とUnityを学んでいる</title><updated>2018-03-07T08:45:37+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/03/07/084537"/><summary type="html">せっかくWindowsマシンを使っているのだからMSの開発環境のエコシステムにどっぷり浸かってみたいと常々思っていたのだが、ようやく最近触り始めた。 まず、F#については Beginning F# 4.0 を読んでいる。F#はOCamlをベースにしていると聞いていてずっと興味があった言語。改めて学んでみると、あー、Haskellって後発の強みでsyntax改善されている部分も多いんだなあという印象は受ける。が、まだまだ序盤の面白くない部分なので、もっと読み進めるとがらっと印象が変わりそう。 www.apress.com UnityはWindowsで触る必要はないんだろうけど、C#つながりで興味…</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html</id><title type="text">[haskell] http-clientライブラリを利用してHaskellでHTTPクライアント機能を実装する</title><updated>2018-03-05T09:34:57.715+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html"/><summary type="text">Haskellでは、http-clientライブラリを用いることで、HTTPクライアント機能を簡単に実装できます。http-client以外にも何種類かライブラリがありますが、今回はhttp-client, http-client-tlsの機能と使い方をまとめておきます。

本エントリで紹介するhttp-client, http-client-tlsライブラリの機能：

単純なHTTP GETリクエスト

主要な型の説明 

Managerのカスタマイズ 

https
proxy設定 
タイムアウト値の設定

Requestのカスタマイズ

ベーシック認証 
リクエストヘッダ 

Responseの操作

ストリーミング受信 
レスポンスヘッダの参照 

エラーハンドリング 






単純なHTTP GETリクエスト
{-# LANGUAGE OverloadedStrings #</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html</id><title type="text">tasty-discover が Windows+日本語環境で動かなかったので直す</title><updated>2018-03-04T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;tasty-discover が Windows+日本語環境で動かなかったので直す&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-03-04" itemprop="datePublished"&gt;
        Mar 4, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;おそらく少数派であろう Windows + 日本語環境の Haskeller のひげです．&lt;/p&gt;
&lt;p&gt;最近は知人のすゝめで，Haskell のテストフレームワークに &lt;a href="https://hackage.haskell.org/package/tasty"&gt;&lt;code&gt;tasty&lt;/code&gt;&lt;/a&gt; を使ってます． &lt;code&gt;tasty&lt;/code&gt; にも例に漏れず &lt;a href="http://hackage.haskell.org/package/tasty-discover"&gt;&lt;code&gt;tasty-discover&lt;/code&gt;&lt;/a&gt; というテスト用の関数を &lt;code&gt;.hs&lt;/code&gt; ファイルから集めてきてくれるツールがある． しかし，悲しいことに &lt;code&gt;tasty-discover&lt;/code&gt; がマルチバイト文字(日本語とか)を Windows で読み込むと &lt;strong&gt;いつもの&lt;/strong&gt; エラーで死んでしまう．&lt;/p&gt;
&lt;p&gt;なので，直して PR 出した． この記事はそのメモです．&lt;/p&gt;
&lt;h2 id="問題のエラー"&gt;問題のエラー&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Building test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
tasty-discover: test\ConfigTest.hs: hGetContents: invalid argument (invalid byte sequence)
`tasty-discover&amp;#39; failed in phase `Haskell pre-processor&amp;#39;. (Exit code: 1)
Progress: 1/2
--  While building custom Setup.hs for package tasty-discover-4.1.3 using:
      C:\Users\Hoge\AppData\Roaming\stack\setup-exe-cache\i386-windows\Cabal-simple_Z6RU0evB_2.0.1.0_ghc-8.2.2.exe --builddir=.stack-work\dist\010ee936 build lib:tasty-discover exe:tasty-discover test:test --ghc-options &amp;quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&amp;quot;
    Process exited with code: ExitFailure 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hGetContents: invalid argument (invalid byte sequence)&lt;/code&gt; は 日本語 Windows Haskeller なら親の顔より良く見るエラーメッセージですね(そんなことは無い)． このエラーは &lt;code&gt;hGetContents&lt;/code&gt; で読み込もうとしているファイルの文字コードが，&lt;code&gt;hGetContents&lt;/code&gt; で設定されている文字コードと違うために起きている(&lt;code&gt;hGetContents&lt;/code&gt; 関数は，例えば &lt;code&gt;readFile&lt;/code&gt; 関数などで呼び出されている)．&lt;/p&gt;
&lt;h2 id="対処法"&gt;対処法&lt;/h2&gt;
&lt;p&gt;日本語 Windows Haskeller 筆頭の igrep 氏が Haskell-jp Blog に投稿してくれてる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"&gt;WindowsでHaskellを扱う時によく遭遇するエラーと対処法 - Haskell-jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は(孫プロセスとして読んでるせいか)「それでもダメな場合」に当たる． つまり，場当たり的な解決方法(&lt;code&gt;chcp 65001&lt;/code&gt; と打つとか)ではダメで，プログラムを修正するしかない．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;神な igrep 氏は，この場合の解決策も書いておいてくれた． この &lt;a href="https://github.com/haskell/haddock/pull/566"&gt;PR&lt;/a&gt; を参考にして書き換えてやればよい．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tasty-discover&lt;/code&gt; も&lt;a href="https://github.com/lwm/tasty-discover/pull/138/files"&gt;こんな感じに書き加えた&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="pr-を出す"&gt;PR を出す&lt;/h2&gt;
&lt;p&gt;修正自体は1時間ほどで終わり(移動中の新幹線の中で直した)，これでテストを実行できるようになったので PR を出さずに満足してしまった(あるある)． 半月ほどほっといてたら，同じケースで困った知り合いに &lt;a href="https://github.com/lwm/tasty-discover/issues/135"&gt;Issue&lt;/a&gt; を出されてしまった(笑)&lt;/p&gt;
&lt;p&gt;しょうがないので PR を出そうとしたら，「Windows は良く分からないから，ぜひ Windows 環境用の自動テストも欲しい！」と&lt;a href="https://github.com/lwm/tasty-discover/issues/127"&gt;作者に言われてしまった&lt;/a&gt;(「時間があればやって」とね)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.appveyor.com/"&gt;AppVeyor&lt;/a&gt; と言うのを使えばいいみたい． 調べたらサクッとできそうなので，やってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.snoyman.com/blog/2016/08/appveyor-haskell-windows-ci"&gt;Using AppVeyor for Haskell+Windows CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;記事にある設定ファイルをそのままコピペしてやってみたが，問題がふたつあった． ひとつ目は，&lt;code&gt;tasty-discover&lt;/code&gt; のテスト自体に &lt;code&gt;tasty-discover&lt;/code&gt; を使っている点だ． 最初に &lt;code&gt;stack test&lt;/code&gt; を実行するときにはまだ &lt;code&gt;tasty-discover&lt;/code&gt; はインストールされてないのでテストが落ちてしまう．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[2 of 2] Compiling Paths_tasty_discover ( .stack-work\dist\010ee936\build\tasty-discover\autogen\Paths_tasty_discover.hs, .stack-work\dist\010ee936\build\tasty-discover\tasty-discover-tmp\Paths_tasty_discover.o )
Linking .stack-work\dist\010ee936\build\tasty-discover\tasty-discover.exe ...
Preprocessing test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
Building test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
ghc.EXE: could not execute: tasty-discover&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なので，&lt;code&gt;stack test&lt;/code&gt; する前に &lt;code&gt;stack install&lt;/code&gt; することにした．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ふたつ目は，そもそも WIndows のビルドが落ちる点． &lt;code&gt;System.FilePath&lt;/code&gt; に関するバグだったので，&lt;a href="https://github.com/lwm/tasty-discover/pull/136/files#diff-383b12983902facd1ce205458e1061b6"&gt;サクッと直した&lt;/a&gt;． Windows のテストに関する &lt;a href="https://github.com/lwm/tasty-discover/pull/136"&gt;PR&lt;/a&gt; もマージされたので，本命の &lt;a href="https://github.com/lwm/tasty-discover/pull/138"&gt;PR&lt;/a&gt; も出した(これもマージされた)．&lt;/p&gt;
&lt;h2 id="今回の問題をテストする"&gt;今回の問題をテストする(？)&lt;/h2&gt;
&lt;p&gt;今回の問題のテストも欲しいと言われた． &lt;code&gt;tasty-discover&lt;/code&gt; のテスト自体が &lt;code&gt;tasty-discover&lt;/code&gt; を使うため，ユニットテストとして表現できない． &lt;code&gt;stack test&lt;/code&gt; そのものが落ちるか落ちないかのテストはできるが，それはなんか違うなぁと思い，結局コミットはしていない．&lt;/p&gt;
&lt;p&gt;ただし，いちおう AppVeyor で&lt;a href="https://ci.appveyor.com/project/matsubara0507/tasty-discover/build/1.0.9"&gt;再現できるようにはした&lt;/a&gt;． AppVeyor はデフォルトだと日本語環境になっていない(即ち Shift-JIS じゃない)ため落ちない． なので，以下を参考にして日本語環境にして実行した．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/appveyor/ci/issues/846"&gt;Support a different code page · Issue #846 · appveyor/ci&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;init:
- ps: Set-WinSystemLocale ja-JP
- ps: Start-Sleep -s 5
- ps: Restart-Computer&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というのを &lt;code&gt;appveyor.yml&lt;/code&gt; に書き加えるだけで良い．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;なんか &lt;a href="https://github.com/lwm/tasty-discover/issues/139"&gt;Push 権限を貰った&lt;/a&gt;． こういうこともあるんですね(OSS歴が浅いので驚いた)．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/03/03/095904</id><title type="text">今日はYAPC::Okinawa 2018 ONNASONの日です</title><updated>2018-03-03T19:16:58+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/03/03/095904"/><summary type="html">YAPC::Okinawa 2018 ONNASON に参加していますので、自分用のメモを残しておきます。 オープニング / @codehex さん めんそーれ！ A会場は飲食禁止 モバイルルータは電源切ってね 赤いリストバンドの人を撮影しないで JPAの行動規範を守ってね #yapcjapan にて案内あるよ #yapcjapanA, #yapcjapanB 懇親会受付は12:00からです ベストトーク章に投票してね リゾートYAPCをお楽しみください 万国之津梁 / @chasbar さん London Perl Workshop 2017 へ参加した YAPCより少し小さいイベント。国単…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/03/03/174252</id><title type="text">スライド公開: YAPC::Okinawa 2018 事業を支えるPerl</title><updated>2018-03-03T17:42:52+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/03/03/174252"/><summary type="html">スペシャルセッションで、弊社のプロダクト開発の現場について話してきました。</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/12/13/170000</id><title type="text">Go言語のsyscall.Sysctlは最後のNULを落とす</title><updated>2018-03-02T17:07:49+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/12/13/170000"/><summary type="html">カーネルのパラメータを引いたり設定したりする時に便利なのが sysctl コマンドです。 $ sysctl kern.ostype kern.ostype: Darwin このコマンドのシステムコールをGo言語から叩いて、OSの種類を引いてみましょう。 func main() { ret, _ := syscall.Sysctl("kern.ostype") fmt.Printf("%s\n", ret) } Darwin 問題ないですね。 数字を返すものを叩いてみましょう。 $ sysctl machdep.cpu.feature_bits machdep.cpu.feature_bits:…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/12/23/082635</id><title type="text">猫でもわかる rkt + Kubernetes</title><updated>2018-02-28T00:36:58+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/12/23/082635"/><summary type="html">このエントリは Kubernetes Advent Calendar 2017 の 23 日目の記事です。ちなみに昨日は takezaki さんの「GCBを利用したContinuous Delivery環境」でした。 LT で使用したスライド 先日、市ヶ谷Geek★Night #16 の 10 分 LT 枠で、CoreOS 社によるコンテナ実装 rkt とその Kubernetes 連携について発表してきました。今回のエントリはこの LT の内容を補足しつつ、実際に手を動かして rkt を試せるような構成にしてあります。 Hello, rkt! rkt は、Docker の対抗馬として Cor…</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html</id><title type="text">[haskell] stack install cryptoniteがno such instruction: `rdrand %r8'エラーで失敗する問題の対処方法</title><updated>2018-02-25T15:34:07.378+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html"/><summary type="text">手許の環境（mac）で、cryptoniteライブラリのビルドがエラーになる問題が発生したが、ネットの情報を元に解決できたので、その症状と手順をblogに残しておく。



エラーの症状：
stack install cryptoniteで以下のようなエラーが発生。
% stack install cryptonite
--  While building custom Setup.hs for package cryptonite-0.24 using:
      /Users/xxx/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.0.1.0 build --ghc-options " </summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B</id><title type="text">なぜ Haskell が好きなのか</title><updated>2018-02-25T14:53:18+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B"/><summary type="html">自分は Haskell が好きで休日は Haskell を書いています。そういうことを言うと関数型が好きなんですねと言われるのですが、Haskell のよさはそこじゃないと感じているので書き起こそうかと、筆を執りました。 というわけで、この記事は技術的文書というよりもお話です。Haskell を知らない人向けです。 この記事は Haskell Advent Calendar 2017 その3の6日めの記事です。6日が過ぎても担当のいない日だったため担当します。 関数型プログラミングだから Haskell が好きというわけではない まず、「Haskell というと手続き型とは全然違う関数型なんで…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html</id><title type="text">拡張可能タングルでDo記法レスプログラミング♪ (Haskell)</title><updated>2018-02-22T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;拡張可能タングルでDo記法レスプログラミング♪ (Haskell)&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-22" itemprop="datePublished"&gt;
        Feb 22, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;「&lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージの楽しみ その３」です．&lt;/p&gt;
&lt;p&gt;拡張可能レコードやら Extensible Effect やら，Haskell の Extensible なものを全て統一された仕組みで提供する化け物パッケージ &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; について，割とドキュメントには無い(？)ネタを書いておくシリーズ第三弾です． ぼく自身は作者ではないし，間違っているかもなのでこの記事を完全には当てにしないでください．&lt;/p&gt;
&lt;p&gt;また，現在の最新バージョンは 0.4.7.1 です(そのバージョンでハナシをしてる)．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="/posts/2017-11-28-fun-of-extensible-1.html"&gt;前々回&lt;/a&gt;は拡張可能レコードの拡縮の話を，&lt;a href="/posts/2018-01-31-fun-of-extensible-2.html"&gt;前回&lt;/a&gt;は拡張可能直和型(バリアント)を引数に取る関数の話を書きました．&lt;/p&gt;
&lt;p&gt;今回は &lt;strong&gt;拡張可能タングル&lt;/strong&gt; で遊んでみます． 今回の Haskell コードは基本的に&lt;a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96"&gt;コレ&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="拡張可能タングル"&gt;拡張可能タングル&lt;/h2&gt;
&lt;p&gt;作者さんの拡張可能タングルについての記事があり，非常に分かりやすいです．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fumieval.hatenablog.com/entry/2016/12/18/181540"&gt;波打たせるものの正体(エクステンシブル・タングル) - モナドとわたしとコモナド&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拡張可能タングルを用いれば，文脈付き(&lt;code&gt;IO&lt;/code&gt; などの &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス)で拡張可能レコードを生成し，更にフィールド間で依存関係を持つ際に，型クラスを用いて各フィールドごとに振る舞いを記述できるようになる． まぁこのヒトコトでは伝わらないですよね．&lt;/p&gt;
&lt;p&gt;百聞は一見に如かず．例えば&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;     , &lt;span class="st"&gt;&amp;quot;hoge2&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;     , &lt;span class="st"&gt;&amp;quot;hoge3&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;span class="ot"&gt;makeRec ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;makeRec &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;  hoge1 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  hoge3 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; randomRIO (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt; length hoge1)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;  pure&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;     &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge1 &lt;span class="fu"&gt;@=&lt;/span&gt; hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge2 &lt;span class="fu"&gt;@=&lt;/span&gt; (length hoge1 &lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt; hoge3)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge3 &lt;span class="fu"&gt;@=&lt;/span&gt; hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; emptyRecord&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;というような関数があったとする． これを拡張可能タングルを使って書き直すと次のようになります．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;makeRec ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;makeRec &lt;span class="fu"&gt;=&lt;/span&gt; runTangles tangles (wrench emptyRecord)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="ot"&gt;tangles ::&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; (&lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;) &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;:*&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;tangles &lt;span class="fu"&gt;=&lt;/span&gt; htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; make m&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge1&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; lift getLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge2&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; (&lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (length &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge1) &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge3&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;    ml &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; length &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;    lift &lt;span class="fu"&gt;$&lt;/span&gt; randomRIO (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt; ml)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;コード量そのものは倍近くなっている． しかし，フィールドの構築方法ごとにインスタンスメソッドとして切り分けることが出来ている． しかも，&lt;strong&gt;摩訶不思議な &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Tangle.html#v:lasso"&gt;&lt;code&gt;lasso&lt;/code&gt;&lt;/a&gt; 関数により依存関係も勝手に解決してくれる&lt;/strong&gt; ． もちろん，フィールドのインスタンスが足りないときは，足りないというコンパイルエラーになるよ．&lt;/p&gt;
&lt;h2 id="do記法レスプログラミング"&gt;Do記法レスプログラミング&lt;/h2&gt;
&lt;p&gt;Haskell はなんらかの作用付きの振る舞いは次のように &lt;code&gt;Monad&lt;/code&gt; と &lt;code&gt;do&lt;/code&gt; 記法を用いて書くのが一般的だ． しかし，便利な Do 記法に甘えて無駄に長い，数十行もある Do 式を書いたことは無いだろうか？ たしかに(関数合成だけで記述するより)読みやすいが，なんかこう…ちがうじゃないですか！？&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;そこで，先述した拡張可能タングルを用いて長いDo式をフィールドごとに切り分けてみよう． 例題として次のようなログ(っぽいなにか)を読み込む関数を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Log&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;path&amp;quot;    &amp;gt;: FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;     , &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;     , &lt;span class="st"&gt;&amp;quot;code&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;     , &lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LogCsv&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;time&amp;quot;    &amp;gt;: Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;     , &lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-19" data-line-number="19"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;code&amp;quot;    &amp;gt;: Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-20" data-line-number="20"&gt;     , &lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-21" data-line-number="21"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-22" data-line-number="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-23" data-line-number="23"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Eff&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-24" data-line-number="24"&gt;    &lt;span class="ch"&gt;&amp;#39;[ EitherDef String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-25" data-line-number="25"&gt;     , &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-26" data-line-number="26"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-27" data-line-number="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-28" data-line-number="28"&gt;&lt;span class="ot"&gt;runEIO ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Either&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-29" data-line-number="29"&gt;runEIO &lt;span class="fu"&gt;=&lt;/span&gt; retractEff &lt;span class="fu"&gt;.&lt;/span&gt; runEitherDef&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-30" data-line-number="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-31" data-line-number="31"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-32" data-line-number="32"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-33" data-line-number="33"&gt;  result &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; runEIO &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-34" data-line-number="34"&gt;    (path&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; liftIO getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-35" data-line-number="35"&gt;    file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt;  liftIO (LB.readFile path)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-36" data-line-number="36"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-37" data-line-number="37"&gt;      csv &lt;span class="fu"&gt;=&lt;/span&gt; mconcat [header, &lt;span class="st"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;, file]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-38" data-line-number="38"&gt;    (_, logs) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either throwError pure (decodeByName csv)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;Header&lt;/span&gt;, &lt;span class="dt"&gt;LogCsv&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-39" data-line-number="39"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-40" data-line-number="40"&gt;      log&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; V.head logs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-41" data-line-number="41"&gt;    info &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either throwError pure (eitherDecode &lt;span class="fu"&gt;$&lt;/span&gt; log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;info)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-42" data-line-number="42"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-43" data-line-number="43"&gt;      &lt;span class="fu"&gt;#&lt;/span&gt;path &lt;span class="fu"&gt;@=&lt;/span&gt; path &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;time &lt;span class="fu"&gt;@=&lt;/span&gt; (log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;time) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; info&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-44" data-line-number="44"&gt;  either error print result&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-45" data-line-number="45"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-46" data-line-number="46"&gt;&lt;span class="ot"&gt;header ::&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-47" data-line-number="47"&gt;header &lt;span class="fu"&gt;=&lt;/span&gt; LB.intercalate &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; fmap fromString &lt;span class="fu"&gt;$&lt;/span&gt; henumerateFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-48" data-line-number="48"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-49" data-line-number="49"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-50" data-line-number="50"&gt;  ((&lt;span class="fu"&gt;:&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-51" data-line-number="51"&gt;  []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このメイン関数は次のような CSV をログデータとして読み込んで，2行目の JSON もパースしたうえで，ひとつの拡張可能レコードとして吐き出す．&lt;/p&gt;
&lt;pre class="csv"&gt;&lt;code&gt;2018-02-23T03:10:00,&amp;quot;{&amp;quot;&amp;quot;code&amp;quot;&amp;quot;:123,&amp;quot;&amp;quot;message&amp;quot;&amp;quot;:&amp;quot;&amp;quot;hello&amp;quot;&amp;quot;}&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正直，この例だと大した長さではないので切り分けるメリットはなーーんにもないんですけど．&lt;/p&gt;
&lt;h3 id="stack-script-とカスタムスナップショット"&gt;&lt;code&gt;stack script&lt;/code&gt; とカスタムスナップショット&lt;/h3&gt;
&lt;p&gt;その前に，このメイン関数をどうやって実行するか． この程度のモノをいちいち stack プロジェクトにしていてはスペースの無駄なので，&lt;code&gt;stack script&lt;/code&gt; を使う．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack script&lt;/code&gt; コマンド知っていますか？ &lt;code&gt;stack runghc&lt;/code&gt; と基本的には一緒なのだが，違いは2点(たぶん)．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;resolver の指定が必須 (たしか &lt;code&gt;runghc&lt;/code&gt; は指定しなければプロジェクトのを使うはず)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;パッケージを引数で指定する必要が無い&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2)がすごいよね． &lt;code&gt;runghc&lt;/code&gt; の場合，使ってるパッケージを &lt;code&gt;--package hoge&lt;/code&gt; と一つずつ指定しなければならない(今回は&lt;a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96#file-fun-of-tangle-hs-L13"&gt;使ってるパッケージが多い&lt;/a&gt;ので尚更大変)が，&lt;code&gt;script&lt;/code&gt; なら指定した resolver から自動で解決してくれる．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ただ問題がひとつ． 今回は &lt;a href="https://hackage.haskell.org/package/aeson"&gt;&lt;code&gt;aeson&lt;/code&gt;&lt;/a&gt; や &lt;a href="https://hackage.haskell.org/package/cassava"&gt;&lt;code&gt;cassava&lt;/code&gt;&lt;/a&gt; の型クラスのインスタンスを拡張可能レコードで使いたいので，Stackage に登録していない &lt;a href="https://github.com/matsubara0507/extensible-instances"&gt;&lt;code&gt;matsubara0507/extensible-instances&lt;/code&gt;&lt;/a&gt; にも依存したい． そこで，カスタムスナップショットだ． 日本語で詳しくは下記のサイトにまとまっていた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html"&gt;カスタムスナップショットの紹介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここには書いてないが，カスタムスナップショットは &lt;code&gt;stack script&lt;/code&gt; にも使える． 例えば今回は次のようなカスタムスナップショットを作った．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-10.6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;git:&lt;/span&gt;&lt;span class="at"&gt; https://github.com/matsubara0507/extensible-instances.git&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 8dabe7a3dd9cf162e2d81e4ca16dbe73b98a3809&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これを &lt;code&gt;snapshot.yaml&lt;/code&gt; とし，例題のコードを &lt;code&gt;fun-of-tangle.hs&lt;/code&gt; とすると次のように実行できる&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;$ &lt;span class="fu"&gt;cat&lt;/span&gt; sampleLog.csv&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ex"&gt;2018-02-23T03&lt;/span&gt;:10:00,&lt;span class="st"&gt;&amp;quot;{&amp;quot;&amp;quot;code&amp;quot;&amp;quot;:123,&amp;quot;&amp;quot;message&amp;quot;&amp;quot;:&amp;quot;&amp;quot;hello&amp;quot;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; script --resolver ./snapshot.yaml -- fun-of-tangle.hs sampleLog.csv&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="ex"&gt;Using&lt;/span&gt; resolver: custom: ./snapshot.yaml specified on command line&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="ex"&gt;path&lt;/span&gt; @= &lt;span class="st"&gt;&amp;quot;sampleLog.csv&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: time @= &lt;span class="st"&gt;&amp;quot;2018-02-23T03:10:00&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: code @= 123 &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: message @= &lt;span class="st"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ヘッダの生成"&gt;ヘッダの生成&lt;/h3&gt;
&lt;p&gt;CSV の読み込みには &lt;code&gt;cassava&lt;/code&gt; というパッケージを使っている． このパッケージには &lt;code&gt;FromRecord&lt;/code&gt; と &lt;code&gt;FromNamedRecord&lt;/code&gt; 型クラスがある． 前者は前から順に勝手に取っていくのに対し，後者はフィールド名と CSV の列名を対応させて取ってきてくれる．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cassava&lt;/code&gt; 系の拡張可能レコードのインスタンスを書いてるときは &lt;code&gt;extensible&lt;/code&gt; 力がまだ低く，フィールドからインデックスをとっていくる方法が分からなかった． そのため &lt;code&gt;FromRecord&lt;/code&gt; 型クラスのインスタンスが &lt;code&gt;extensible-instances&lt;/code&gt; にはない(何故かついこの前，&lt;a href="https://github.com/fumieval/extensible/commit/074210e76ed5bd35f62d452f66c940a40d821534"&gt;本家へコミット&lt;/a&gt;されたけど)．&lt;/p&gt;
&lt;p&gt;なので，型から列名のヘッダーを生成してしまおう，というのが &lt;code&gt;header&lt;/code&gt; 関数．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;header ::&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;header &lt;span class="fu"&gt;=&lt;/span&gt; LB.intercalate &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; fmap fromString &lt;span class="fu"&gt;$&lt;/span&gt; henumerateFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  ((&lt;span class="fu"&gt;:&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;  []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy (KeyValue KnownSymbol Show)&lt;/code&gt; ってのが悲しいですよね…(&lt;code&gt;Show&lt;/code&gt; は全く無意味)． キー側だけ型クラスを指定する方法は無いような気がしたんだよなぁ．&lt;/p&gt;
&lt;h2 id="分割しましょう"&gt;分割しましょう&lt;/h2&gt;
&lt;p&gt;では本題．&lt;/p&gt;
&lt;p&gt;まずは型クラスを考えよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに，&lt;code&gt;&amp;quot;path&amp;quot; &amp;gt;: FilePath&lt;/code&gt; のインスタンスを書いてみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;path&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; FilePath) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt; liftIO getArgs &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;    (path &lt;span class="fu"&gt;:&lt;/span&gt; _) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pure path&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;    _          &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; throwError &lt;span class="st"&gt;&amp;quot;please path.&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他のはできるだろうか？ 元のメイン関数を見ればわかると思うが，たぶん無理だと思う． 他のフィールドは &lt;code&gt;log'&lt;/code&gt; 変数に保存した中間状態を共有するからだ．&lt;/p&gt;
&lt;h3 id="中間状態をどうするか"&gt;中間状態をどうするか&lt;/h3&gt;
&lt;p&gt;他にもっといい手はあるかもしれないが，今回は &lt;strong&gt;レコードを中間状態も加えて拡張する&lt;/strong&gt; ことにする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;log&amp;quot; &amp;gt;: LogCsv &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;] &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Product.html#t:-43--43-"&gt;&lt;code&gt;(++)&lt;/code&gt;&lt;/a&gt; は型レベルリストの連結演算子だ． &lt;code&gt;'[&amp;quot;log&amp;quot; &amp;gt;: LogCsv ': &amp;quot;info&amp;quot; &amp;gt;: Info]&lt;/code&gt; が追加する中間状態にあたる． これを最後にどうやって外すかと言うと，実は簡単で &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Inclusion.html#v:shrink"&gt;&lt;code&gt;shrink&lt;/code&gt;&lt;/a&gt; 関数で縮小してやればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;makeLog ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="dt"&gt;Log&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;makeLog &lt;span class="fu"&gt;=&lt;/span&gt; shrink &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; runTangles tangles (wrench emptyRecord)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="ot"&gt;tangles ::&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; (&lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt;) &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;:*&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;tangles &lt;span class="fu"&gt;=&lt;/span&gt; htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;  \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; make m&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中間状態のインスタンス定義してしまう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;log&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LogCsv&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;    file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;.&lt;/span&gt; liftIO &lt;span class="fu"&gt;.&lt;/span&gt; LB.readFile &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;path&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;    (_, log&amp;#39;) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;      either throwError pure (decodeByName &lt;span class="fu"&gt;$&lt;/span&gt; mconcat [header, &lt;span class="st"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;, file])&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt; V.head log&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;    log&amp;#39; &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;log&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;    lift &lt;span class="fu"&gt;$&lt;/span&gt; either throwError pure (eitherDecode &lt;span class="fu"&gt;$&lt;/span&gt; log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;info)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;うん…まぁ…読みやすさのためにね，多少は &lt;code&gt;do&lt;/code&gt; を残しましたよ(タイトル詐欺)．&lt;/p&gt;
&lt;h3 id="残りは簡単"&gt;残りは簡単&lt;/h3&gt;
&lt;p&gt;あとは，フィールドを取り出すだけなので簡単．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;time &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;log&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;code&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;code &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;info&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;message &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;info&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;メイン関数はこんな感じ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; either error print &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; runEIO makeLog&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;わぁすっきり(メイン関数は)．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;これぐらいの規模だとメリットが皆無なんですが，もっと CSV の列数が多くなったらどうでしょう？ うーーーん，あんまり変わらないかも(笑) まぁ，少なくとも面白い(不思議な)プログラミングが出来るのは確かです．&lt;/p&gt;
&lt;p&gt;僕は試しにこの方法で，&lt;a href="https://github.com/matsubara0507/source-gh-pages/blob/tangle/app/Rules.hs"&gt;このサイトの Hakyll コード&lt;/a&gt;を切り刻んでみました．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/02/21/141816</id><title type="text">Haskell入門のサンプルコードの最新LTS対応</title><updated>2018-02-21T14:21:16+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/02/21/141816"/><summary type="html">拙著 Haskell入門 のサンプルコードは lts-8.24 にしか対応していなかったので、現時点の最新である lts-10.6 に対応させた。変更したのはすべてライブラリがアップデートされたのを追随したもの。 master ではなく lts-10 というブランチにしてあるので、注意。 github.com LTSのアップデートによって ghc-8.2 が使えるようになったのが嬉しい。引き続きHaskellでの開発をお楽しみくださいませ。</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html</id><title type="text">このサイトに機能を追加 2018</title><updated>2018-02-21T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;このサイトに機能を追加 2018&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-21" itemprop="datePublished"&gt;
        Feb 21, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/site.html"&gt;site&lt;/a&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;このサイトは Haskell の静的サイトジェネレーター &lt;a href="https://jaspervdj.be/hakyll/"&gt;Hakyll&lt;/a&gt; を使っています．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/posts/2016-07-07-started-github-pages.html"&gt;GitHub Pages はじめました - ひげメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定期的に自分のサイトをいじってるんだけど，久々に本腰入れて改良した． このサイトを作り始めたころと違い「Haskell力」が段違いなのでサクサクできたぜ．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;追加したのは以下の7つ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;リンクチェッカー&lt;/li&gt;
&lt;li&gt;LTS 10 に対応&lt;/li&gt;
&lt;li&gt;可変なキーバリューストアを aeson で&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post/&lt;/code&gt; 以下のマークダウン置き場を変更&lt;/li&gt;
&lt;li&gt;フィードの生成&lt;/li&gt;
&lt;li&gt;ページネーションの追加&lt;/li&gt;
&lt;li&gt;タグの追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最初のリンクチェッカーは &lt;code&gt;stack test&lt;/code&gt; で行うのだが，追加したのは実は結構前． 記事にしてなかったので書き足しておく．&lt;/p&gt;
&lt;h2 id="リンクチェッカー"&gt;リンクチェッカー&lt;/h2&gt;
&lt;p&gt;記事内にあるリンクを実際に ping して，リンクが有効かを検査するテストを作った． もちろん Haskell で書いて &lt;code&gt;stack test&lt;/code&gt; で実行できるようにした． コードはこんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Prelude&lt;/span&gt;                   &lt;span class="kw"&gt;hiding&lt;/span&gt; (&lt;span class="dt"&gt;FilePath&lt;/span&gt;, null)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;                 (nub, sort)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Maybe&lt;/span&gt;                (fromMaybe)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Text&lt;/span&gt;                 (&lt;span class="dt"&gt;Text&lt;/span&gt;, isPrefixOf, null, unpack)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Traversable&lt;/span&gt;          (traverse)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Client&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Client.TLS&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Types.Status&lt;/span&gt; (&lt;span class="dt"&gt;Status&lt;/span&gt;, ok200)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Shelly&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Test.Hspec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Text.HTML.Scalpel.Core&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;  urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fmap mconcat &lt;span class="fu"&gt;.&lt;/span&gt; shelly &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;    run_ &lt;span class="st"&gt;&amp;quot;stack&amp;quot;&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;exec&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;--&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;build&amp;quot;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;    files &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; ls &lt;span class="st"&gt;&amp;quot;_site/posts&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;    traverse (fmap scrapeLinks &lt;span class="fu"&gt;.&lt;/span&gt; readfile) files&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;  hspec &lt;span class="fu"&gt;.&lt;/span&gt; mapM_ spec &lt;span class="fu"&gt;.&lt;/span&gt; nub &lt;span class="fu"&gt;.&lt;/span&gt; sort &lt;span class="fu"&gt;$&lt;/span&gt; filter check urls&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;  check url &lt;span class="fu"&gt;=&lt;/span&gt; not &lt;span class="fu"&gt;.&lt;/span&gt; or &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt;) (null url) &lt;span class="fu"&gt;$&lt;/span&gt; fmap&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;    (&lt;span class="ot"&gt;`isPrefixOf`&lt;/span&gt; url)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;    [&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;../&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;#&amp;quot;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;  spec url &lt;span class="fu"&gt;=&lt;/span&gt; it (unpack url) &lt;span class="fu"&gt;$&lt;/span&gt; linkStatus url &lt;span class="ot"&gt;`shouldReturn`&lt;/span&gt; ok200&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" data-line-number="29"&gt;&lt;span class="ot"&gt;scrapeLinks ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" data-line-number="30"&gt;scrapeLinks txt &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe [] &lt;span class="fu"&gt;$&lt;/span&gt; scrapeStringLike txt scraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-31" data-line-number="31"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt; scraper &lt;span class="fu"&gt;=&lt;/span&gt; attrs &lt;span class="st"&gt;&amp;quot;href&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-32" data-line-number="32"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-33" data-line-number="33"&gt;&lt;span class="ot"&gt;linkStatus ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Status&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-34" data-line-number="34"&gt;linkStatus url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-35" data-line-number="35"&gt;  manager &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; newManager tlsManagerSettings&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-36" data-line-number="36"&gt;  request &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; parseRequest &lt;span class="fu"&gt;$&lt;/span&gt; unpack url&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-37" data-line-number="37"&gt;  responseStatus&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-38" data-line-number="38"&gt;    &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; httpNoBody (request { requestHeaders &lt;span class="fu"&gt;=&lt;/span&gt; [(&lt;span class="st"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;)] }) manager&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HTTPクライアントには &lt;a href="https://hackage.haskell.org/package/http-client"&gt;&lt;code&gt;http-client&lt;/code&gt;&lt;/a&gt; を，スクレイピングには &lt;a href="https://hackage.haskell.org/package/scalpel"&gt;&lt;code&gt;scalpel&lt;/code&gt;&lt;/a&gt; を使っている． &lt;a href="https://hackage.haskell.org/package/shelly"&gt;&lt;code&gt;shelly&lt;/code&gt;&lt;/a&gt; の &lt;code&gt;ls&lt;/code&gt; 関数を使って記事の一覧を取得してきている(これが Windows でも動くからうれしい)． 表示をそれっぽくするために &lt;a href="https://hackage.haskell.org/package/hspec"&gt;&lt;code&gt;hspec&lt;/code&gt;&lt;/a&gt; を使っている． &lt;code&gt;check&lt;/code&gt; 補助関数で自分のページや空文字を排除している．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;これでリンク切れや単純にタイポなんかを検出できるようになったんだが，直すのがめんどくさくて結局放置していること(オイ)．&lt;/p&gt;
&lt;h2 id="lts-10-に対応"&gt;LTS 10 に対応&lt;/h2&gt;
&lt;p&gt;リンクチェッカを回すために TravisCI を使い始めたが，なぜか GHC8 系の LTS だと OUT OF MEMORY してしまう…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--  While building custom Setup.hs for package Cabal-2.0.1.1 using:
      /home/travis/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build --ghc-options &amp;quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&amp;quot;
    Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
    Logs have been written to: /home/travis/build/matsubara0507/source-gh-pages/.stack-work/logs/Cabal-2.0.1.1.log
    Configuring Cabal-2.0.1.1...
    Preprocessing library for Cabal-2.0.1.1..
    Building library for Cabal-2.0.1.1..&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;かなーーり古い LTS だとうまくいくので，仕方なくそれを使っていたのだが直すことにした． というか知り合いが直し方を記事にしてくれてたのでやってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-31-travis-out-of-memory.html"&gt;travis-ci の初回ビルドで OUT OF MEMORY が出た時の対処法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;戦犯は &lt;code&gt;Cabal&lt;/code&gt; パッケージなので，こいつだけ先に &lt;code&gt;-j 1&lt;/code&gt; オプション(メモリを節約するが速度が遅い)でビルドしてしまうという戦略． この記事のサイトの &lt;a href="https://github.com/e-bigmoon/haskell-blog/blob/a229f118f121e0ad843faae1412e938e3e4f3a6b/.travis.yml"&gt;&lt;code&gt;.travis.yml&lt;/code&gt;&lt;/a&gt; を &lt;del&gt;コピペ&lt;/del&gt; 参考にして次のようにした&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="fu"&gt;install:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; mkdir -p ~/.local/bin&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;export PATH=$HOME/.local/bin:&lt;/span&gt;&lt;span class="at"&gt;$PATH&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;travis_retry curl -L https:&lt;/span&gt;&lt;span class="at"&gt;//www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin &amp;#39;*/stack&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="fu"&gt;jobs:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;  &lt;span class="fu"&gt;include:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install cabal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal build -j 1 Cabal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install pandoc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; travis_wait 30 stack --no-terminal build pandoc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install deprndences&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal test --only-dependencies&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; stack test&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal test --no-run-benchmarks --no-haddock-deps&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hakyll-4.10-が落ちる"&gt;hakyll-4.10 が落ちる&lt;/h3&gt;
&lt;p&gt;OUT OF MEMORY は突破したが…&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;    &lt;span class="fu"&gt;/&lt;/span&gt;tmp&lt;span class="fu"&gt;/&lt;/span&gt;stack3402&lt;span class="fu"&gt;/&lt;/span&gt;hakyll&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;4.10&lt;/span&gt;&lt;span class="fu"&gt;.&lt;/span&gt;&lt;span class="fl"&gt;0.0&lt;/span&gt;&lt;span class="fu"&gt;/&lt;/span&gt;rts&lt;span class="fu"&gt;/&lt;/span&gt;posix&lt;span class="fu"&gt;/&lt;/span&gt;OSThreads.c&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;137&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;         error&lt;span class="fu"&gt;:&lt;/span&gt; undefined reference to &lt;span class="ch"&gt;&amp;#39;pthread_create&amp;#39;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なぜだ… 最新の &lt;a href="https://github.com/jaspervdj/hakyll/commit/480da307d22aff8ab3817d1586710c5f4ff6d779"&gt;&lt;code&gt;hakyll-4.11&lt;/code&gt; では直ってるみたい&lt;/a&gt;なので，&lt;code&gt;stack.yaml&lt;/code&gt; に追加したら上手くいった．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; hakyll-4.11.0.0&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; pandoc-citeproc-0.13.0.1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="シンタックスハイライトが"&gt;シンタックスハイライトが…&lt;/h3&gt;
&lt;p&gt;おかしくなった． 理由は簡単で，Hakyll というか Pandoc がシンタックスハイライトにもともと使っていた &lt;a href="https://hackage.haskell.org/package/highlighting-kate"&gt;&lt;code&gt;highlighting-kate&lt;/code&gt;&lt;/a&gt; をやめて &lt;a href="https://hackage.haskell.org/package/skylighting"&gt;&lt;code&gt;skylighting&lt;/code&gt;&lt;/a&gt; に対応したからみたいだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fixpt.de/blog/2017-12-03-hakyll-highlighting-themes.html"&gt;fixpt - Hakyll Code Highlighting Themes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なので，パッケージを変えたら元に戻った．&lt;/p&gt;
&lt;h2 id="可変なキーバリューストアを-aeson-で"&gt;可変なキーバリューストアを aeson で&lt;/h2&gt;
&lt;p&gt;テンプレートの方だけで出てくる変数(e.g. &lt;code&gt;$github$&lt;/code&gt; とか)は &lt;code&gt;site.hs&lt;/code&gt; の実装に依存したくなくて，Hakyll をビルドせずとも &lt;code&gt;config.yaml&lt;/code&gt; に好きに追加できるようにしたかった． &lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt; パッケージ(というか &lt;a href="https://hackage.haskell.org/package/aeson"&gt;&lt;code&gt;aeson&lt;/code&gt;&lt;/a&gt;)ではそういうのを出来ないと &lt;strong&gt;思い込んでいたが &lt;code&gt;Map k v&lt;/code&gt; 型を使えばできる&lt;/strong&gt; と最近分かった(インスタンスのリストを眺めてたら気づいた)． なので，今まで使ってた &lt;a href="https://hackage.haskell.org/package/yaml-light"&gt;&lt;code&gt;yaml-light&lt;/code&gt;&lt;/a&gt; パッケージを捨てて &lt;code&gt;yaml&lt;/code&gt; パッケージで次のように実装した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt;   (decodeFileEither)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Map&lt;/span&gt;    (&lt;span class="dt"&gt;Map&lt;/span&gt;, foldMapWithKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Hakyll&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;  configYaml &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either (error &lt;span class="fu"&gt;.&lt;/span&gt; show) id &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; decodeFileEither &lt;span class="st"&gt;&amp;quot;config.yaml&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;    siteCtx &lt;span class="fu"&gt;=&lt;/span&gt; mkSiteCtx configYaml&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  hakyllWith config &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;    &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" data-line-number="15"&gt;&lt;span class="ot"&gt;mkSiteCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" data-line-number="16"&gt;mkSiteCtx &lt;span class="fu"&gt;=&lt;/span&gt; foldMapWithKey constField&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こういう &lt;code&gt;config.yaml&lt;/code&gt; を書いておくと，全てテンプレートの中で参照できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="fu"&gt;site_title:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;span class="fu"&gt;baseurl:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt;  matsubara0507&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="post-以下のマークダウン置き場を変更"&gt;&lt;code&gt;post/&lt;/code&gt; 以下のマークダウン置き場を変更&lt;/h2&gt;
&lt;p&gt;記事のマークダウンは全て &lt;code&gt;posts/&lt;/code&gt; 以下に置いていたのだが，各年ごとにディレクトリを切りたいなぁと思った． 例えば &lt;code&gt;posts/2018/02-21-add-feats-mysite-2018.md&lt;/code&gt; といった具合に． しかし，出力は今まで通り &lt;code&gt;posts/2018-02-21-add-feats-mysite-2018.html&lt;/code&gt; としたい(リンクが変わっちゃうからね)． まんま&lt;a href="http://daimatz.net/text/2014/0126-hakyll.html"&gt;同じことをしてくれている記事&lt;/a&gt;があったので，参考にして次のように書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  match &lt;span class="st"&gt;&amp;quot;posts/*/*&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;    route &lt;span class="fu"&gt;$&lt;/span&gt; composeRoutes (gsubRoute &lt;span class="st"&gt;&amp;quot;/[0-9]{4}/&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; (&lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; init)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;                          (setExtension &lt;span class="st"&gt;&amp;quot;html&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;    compile&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;$&lt;/span&gt;   pandocCompiler&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; loadAndApplyTemplate &lt;span class="st"&gt;&amp;quot;templates/post.html&amp;quot;&lt;/span&gt; postCtx&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; loadAndApplyTemplate &lt;span class="st"&gt;&amp;quot;templates/default.html&amp;quot;&lt;/span&gt; (postCtx &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; siteCtx)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; relativizeUrls&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;gsubRoute&lt;/code&gt; 関数を使うことで，ファイル名を特有のパターン記法(？)でマッチさせ置換できる． &lt;code&gt;gsubRoute &amp;quot;/[0-9]{4}/&amp;quot; $ (++ &amp;quot;-&amp;quot;) . init&lt;/code&gt; の場合，&lt;code&gt;/2018/&lt;/code&gt; をマッチさせ &lt;code&gt;init&lt;/code&gt; して &lt;code&gt;/2018&lt;/code&gt; となり，末尾に &lt;code&gt;&amp;quot;-&amp;quot;&lt;/code&gt; を追加している．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;さて実はもう一つ問題があって，Hakyll は日時を表すテンプレート変数(&lt;code&gt;$date$&lt;/code&gt; とか)を次のように取得する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;postCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;postCtx &lt;span class="fu"&gt;=&lt;/span&gt; mconcat&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  [ dateField &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%d&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;  , dateField &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%b %-d, %Y&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  , defaultContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dateField&lt;/code&gt; 関数が記事のファイル名(&lt;code&gt;yyyy-mm-dd-*.md&lt;/code&gt; の部分)かマークダウンのメタ変数から取得している． つまり，&lt;code&gt;posts/2018/02-21-add-feats-mysite-2018.md&lt;/code&gt; というファイル名じゃ日時の変数を取得できない． しょうがないので Hakyll のソースコードを読んで無理やり書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="ot"&gt;dateField&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;dateField&amp;#39; key format &lt;span class="fu"&gt;=&lt;/span&gt; field key &lt;span class="fu"&gt;$&lt;/span&gt; \item &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;  time &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getItemUTC&amp;#39; defaultTimeLocale &lt;span class="fu"&gt;$&lt;/span&gt; itemIdentifier item&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; formatTime defaultTimeLocale format time&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="ot"&gt;getItemUTC&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Identifier&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m &lt;span class="dt"&gt;UTCTime&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;getItemUTC&amp;#39; locale ident &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;  pure &lt;span class="fu"&gt;$&lt;/span&gt; parseTimeOrError &lt;span class="dt"&gt;True&lt;/span&gt; locale &lt;span class="st"&gt;&amp;quot;%Y%m-%d&amp;quot;&lt;/span&gt; (yyyy &lt;span class="fu"&gt;++&lt;/span&gt; mmdd)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;    path &lt;span class="fu"&gt;=&lt;/span&gt; toFilePath ident&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;    yyyy &lt;span class="fu"&gt;=&lt;/span&gt; takeFileName &lt;span class="fu"&gt;$&lt;/span&gt; takeDirectory path&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" data-line-number="15"&gt;    mmdd &lt;span class="fu"&gt;=&lt;/span&gt; take &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; takeBaseName path&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さっきの &lt;code&gt;dateField&lt;/code&gt; の部分を &lt;code&gt;dateField'&lt;/code&gt; にすれば記事のビルドが出来る！&lt;/p&gt;
&lt;h3 id="vs-recentfirst-関数"&gt;vs &lt;code&gt;recentFirst&lt;/code&gt; 関数&lt;/h3&gt;
&lt;p&gt;記事を日時順に並び変えてくれる &lt;code&gt;recentFirst&lt;/code&gt; 関数もファイル名に依存してる． しょうがないので力技で書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;       (sortBy)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Ord&lt;/span&gt;        (comparing)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="ot"&gt;recentFirst&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Item&lt;/span&gt; a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Item&lt;/span&gt; a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;recentFirst&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; fmap reverse &lt;span class="fu"&gt;.&lt;/span&gt; chronological&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;span class="ot"&gt;chronological&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Item&lt;/span&gt; a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Item&lt;/span&gt; a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;chronological&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;  sortByM &lt;span class="fu"&gt;$&lt;/span&gt; getItemUTC&amp;#39; defaultTimeLocale &lt;span class="fu"&gt;.&lt;/span&gt; itemIdentifier&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;&lt;span class="ot"&gt;sortByM ::&lt;/span&gt; (&lt;span class="dt"&gt;Monad&lt;/span&gt; m, &lt;span class="dt"&gt;Ord&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m k) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;sortByM f &lt;span class="fu"&gt;=&lt;/span&gt; fmap (map fst &lt;span class="fu"&gt;.&lt;/span&gt; sortBy (comparing snd)) &lt;span class="fu"&gt;.&lt;/span&gt; mapM (fmap &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (,) &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; f)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sortByM&lt;/code&gt; 関数は &lt;code&gt;sortBy&lt;/code&gt; の &lt;code&gt;Monad&lt;/code&gt; 版． &lt;code&gt;[a]&lt;/code&gt; を &lt;code&gt;[(a, m k)]&lt;/code&gt; とし &lt;code&gt;[m (a, k)]&lt;/code&gt; にして &lt;code&gt;m [(a, k)]&lt;/code&gt; にしてから &lt;code&gt;k&lt;/code&gt; でソートし最後に &lt;code&gt;a&lt;/code&gt; だけ取り出している． ちなみに，&lt;code&gt;fmap &amp;lt;$&amp;gt; (,) &amp;lt;*&amp;gt; f&lt;/code&gt; の部分は分かりますか？ &lt;code&gt;\x -&amp;gt; (,) x &amp;lt;$&amp;gt; f x&lt;/code&gt; をしてるだけですよ．&lt;/p&gt;
&lt;h2 id="フィードページネーションタグ"&gt;フィード・ページネーション・タグ&lt;/h2&gt;
&lt;p&gt;実はフィード生成・ページネーション・タグは，もとから Hakyll で提供されている機能だ． どれもこの記事に日本語で書いてある．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html"&gt;Hakyllでブログを作る(実践編2) - Wake up! Good night*&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part3.html"&gt;Hakyllでブログを作る(実践編3) - Wake up! Good night*&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だが躓きポイントはいくつかあった(だいたい日時のやつだけど…)．&lt;/p&gt;
&lt;h3 id="フィードを生成"&gt;フィードを生成&lt;/h3&gt;
&lt;p&gt;記事の通りに作っても &lt;code&gt;$published$&lt;/code&gt; 変数が無いと怒られる． &lt;code&gt;renderAtom&lt;/code&gt; 関数の中で &lt;code&gt;dateField&lt;/code&gt; 関数を使っているからだ． さすがに書き換えるのはめんどいので，自分で取ってくることにした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;postCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;postCtx &lt;span class="fu"&gt;=&lt;/span&gt; mconcat&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;  [ dateField &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%d&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;  , dateField &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%b %-d, %Y&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;  , dateField&amp;#39; &lt;span class="st"&gt;&amp;quot;published&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;  , dateField&amp;#39; &lt;span class="st"&gt;&amp;quot;updated&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;  , defaultContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あと，&lt;a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Feed.html#t:FeedConfiguration"&gt;フィードに渡す変数&lt;/a&gt;は &lt;code&gt;config.yaml&lt;/code&gt; に書くことにした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="fu"&gt;site_title:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="fu"&gt;author:&lt;/span&gt;&lt;span class="at"&gt; MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="fu"&gt;email:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="fu"&gt;baseurl:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;&lt;span class="fu"&gt;val:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これを &lt;code&gt;Config&lt;/code&gt; 型という拡張可能レコードにマッピングし，そのあとに &lt;code&gt;FeedConfiguration&lt;/code&gt; 型に変換する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Lens&lt;/span&gt; ((^.))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;site_title&amp;quot; &amp;gt;: String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;   , &lt;span class="st"&gt;&amp;quot;email&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;   , &lt;span class="st"&gt;&amp;quot;baseurl&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;val&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;&lt;span class="ot"&gt;mkFeedConfig ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FeedConfiguration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;mkFeedConfig conf &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FeedConfiguration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" data-line-number="15"&gt;  { feedTitle       &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;site_title&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" data-line-number="16"&gt;  , feedDescription &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;description&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-17" data-line-number="17"&gt;  , feedAuthorName  &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;author&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-18" data-line-number="18"&gt;  , feedAuthorEmail &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;email&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-19" data-line-number="19"&gt;  , feedRoot        &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;baseurl&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-20" data-line-number="20"&gt;  }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，&lt;code&gt;siteCtx&lt;/code&gt; も書き換える必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;mkSiteCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;mkSiteCtx &lt;span class="fu"&gt;=&lt;/span&gt; hfoldMapFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;  (toContext &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; getField)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="ot"&gt;  toContext ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;  toContext _ &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;  toContext k v  &lt;span class="fu"&gt;=&lt;/span&gt; constField k v&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; (&lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;  toContext _ &lt;span class="fu"&gt;=&lt;/span&gt; foldMapWithKey toContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; (&lt;span class="dt"&gt;Identity&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;  toContext k &lt;span class="fu"&gt;=&lt;/span&gt; toContext k &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコード最高です．&lt;/p&gt;
&lt;h3 id="ページネーションを追加"&gt;ページネーションを追加&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3"&gt;参考記事&lt;/a&gt;の中で使われている &lt;code&gt;sortRecentFirst&lt;/code&gt; も日時を取得しているので書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;sortRecentFirst&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Identifier&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Identifier&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;sortRecentFirst&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  fmap (fmap itemIdentifier) &lt;span class="fu"&gt;.&lt;/span&gt; recentFirst&amp;#39; &lt;span class="fu"&gt;.&lt;/span&gt; fmap (flip &lt;span class="dt"&gt;Item&lt;/span&gt; ())&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="タグを追加"&gt;タグを追加&lt;/h3&gt;
&lt;p&gt;躓きと言うかデザインの問題なのだが，タグのテンプレート変数を生成する &lt;a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Tags.html#v:tagsField"&gt;&lt;code&gt;tagsField&lt;/code&gt;&lt;/a&gt; 関数が，タグをカンマ区切りの文字列にしちゃうのがあった． 個人的には空白区切りにして欲しいので書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;                   (intersperse)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Text.Blaze.Html&lt;/span&gt;             (toHtml, toValue, (!))&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Text.Blaze.Html5&lt;/span&gt;            &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;H&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Text.Blaze.Html5.Attributes&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-6" data-line-number="6"&gt;&lt;span class="ot"&gt;tagsFieldWithSep ::&lt;/span&gt; &lt;span class="dt"&gt;H.Html&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tags&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-7" data-line-number="7"&gt;tagsFieldWithSep sep &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-8" data-line-number="8"&gt;  tagsFieldWith getTags simpleRenderLink (mconcat &lt;span class="fu"&gt;.&lt;/span&gt; intersperse sep)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-10" data-line-number="10"&gt;&lt;span class="ot"&gt;simpleRenderLink ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;H.Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-11" data-line-number="11"&gt;simpleRenderLink tag &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-12" data-line-number="12"&gt;  fmap (\path &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; H.a &lt;span class="fu"&gt;!&lt;/span&gt; A.href (toValue &lt;span class="fu"&gt;$&lt;/span&gt; toUrl path) &lt;span class="fu"&gt;$&lt;/span&gt; toHtml tag)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;tagsFieldWithSep &amp;quot; &amp;quot;&lt;/code&gt; とすれば空白区切りになる．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;ずーーとやろうやろうと思ってたことをいっきに片したぜ．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html</id><title type="text">自己紹介ページを生成する whoami CLI を作った (Haskell)</title><updated>2018-02-19T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;自己紹介ページを生成する whoami CLI を作った (Haskell)&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-19" itemprop="datePublished"&gt;
        Feb 19, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/application.html"&gt;application&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://github.com/matsubara0507/whoami"&gt;whoami&lt;/a&gt; という CLI を作りました． こんな感じの Yaml ファイルから&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="fu"&gt;account:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;qiita:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="fu"&gt;site:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://matsubara0507.github.io&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; メモ書きブログ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;span class="fu"&gt;post:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;latest:&lt;/span&gt;&lt;span class="at"&gt; 10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  &lt;span class="fu"&gt;posts:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://haskell.jp/blog/posts/2017/advent-calendar-2017.html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;      &lt;span class="fu"&gt;date:&lt;/span&gt;&lt;span class="at"&gt; 2017-12-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://iggg.github.io/2017/06/01/make-tweet-slack-bot&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;span class="fu"&gt;library:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; chatwork&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://hackage.haskell.org/package/chatwork&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; The ChatWork API in Haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;    &lt;span class="fu"&gt;language:&lt;/span&gt;&lt;span class="at"&gt; haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; thank_you_stars&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://hex.pm/packages/thank_you_stars&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;    &lt;span class="fu"&gt;language:&lt;/span&gt;&lt;span class="at"&gt; elixir&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt;&lt;span class="fu"&gt;qiita:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;  &lt;span class="fu"&gt;posts:&lt;/span&gt;&lt;span class="at"&gt; true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;&lt;span class="fu"&gt;app:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; AnaQRam&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://github.com/matsubara0507/AnaQRam&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; QRコードを利用したアナグラム(並び替えパズル)&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こんな感じの Markdown を生成する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode markdown"&gt;&lt;code class="sourceCode markdown"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="fu"&gt;# MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;- &lt;span class="ot"&gt;[GitHub](https://github.com/matsubara0507)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[Qiita](https://qiita.com/matsubara0507)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="fu"&gt;## My Sites&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;- &lt;span class="ot"&gt;[ひげメモ](http://matsubara0507.github.io)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="fl"&gt;    - メモ書きブログ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="fu"&gt;## My Posts&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;- &lt;span class="ot"&gt;[Haskell Advent Calendar 2017 まとめ - Haskell-jp](http://haskell.jp/blog/posts/2017/advent-calendar-2017.html)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="fl"&gt;    - posted on 2017-12-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[LINE の Echo Bot を Google Cloud Functions に作る](https://qiita.com/matsubara0507/items/04ab3c2197aa5f68e499)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="fl"&gt;    - posted on 2017-11-21&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[GitHub にチャット機能のようなものが追加された (team discussions)](https://qiita.com/matsubara0507/items/47d2e2545553e415f969)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;span class="fl"&gt;    - posted on 2017-11-21&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[GitHub Project に自動でカードのカラム遷移をする機能が追加された](https://qiita.com/matsubara0507/items/f384991b4854aa28745a)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;&lt;span class="fl"&gt;    - posted on 2017-10-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[Slack から特定のアカウントでツイートする Bot を作った｜群馬大学電子計算機研究会 IGGG](http://iggg.github.io/2017/06/01/make-tweet-slack-bot)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;&lt;span class="fl"&gt;    - posted on 2017-06-01&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;&lt;span class="fu"&gt;## Applications&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;- &lt;span class="ot"&gt;[AnaQRam](http://github.com/matsubara0507/AnaQRam)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-23" data-line-number="23"&gt;&lt;span class="fl"&gt;    - QRコードを利用したアナグラム(並び替えパズル)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-25" data-line-number="25"&gt;&lt;span class="fu"&gt;## Libraries&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-26" data-line-number="26"&gt;- &lt;span class="ot"&gt;[chatwork](http://hackage.haskell.org/package/chatwork)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-27" data-line-number="27"&gt;&lt;span class="fl"&gt;    - The ChatWork API in Haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-28" data-line-number="28"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[thank_you_stars](http://hex.pm/packages/thank_you_stars)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-29" data-line-number="29"&gt;&lt;span class="fl"&gt;    - A tool for starring GitHub repositories.&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yaml ファイルでは足りない情報をスクレイピングや各種 Web サービスの API で拾ってくる． なんか自分のアクティビティを紹介するページを SNS にリンクしてる人が多いと思うんだけど，そのページをできるだけ楽して生成したいなぁというのがモチベーション．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ホントはバイト先で作ってる Haskell 製の社内用 CLI ツールを公開したくて，内容を公開できるようにしたツールです． こんな感じのデータ処理をするツールを，バイト先では Haskell で作ってた．&lt;/p&gt;
&lt;h2 id="extensible"&gt;extensible&lt;/h2&gt;
&lt;p&gt;このツールの(まぁまぁ)面白いところは，&lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; というパッケージの機能をふんだんに使っている． 拡張可能レコード，バリアント，作用を使い，ついでに &lt;a href="https://hackage.haskell.org/package/extensible/docs/Data-Extensible-GetOpt.html"&gt;GetOpt&lt;/a&gt; も使ってみた． 軽く補足しておく(&lt;strong&gt;但し，作者ではないので間違っている部分はあるかも&lt;/strong&gt;)．&lt;/p&gt;
&lt;h3 id="拡張可能レコード"&gt;拡張可能レコード&lt;/h3&gt;
&lt;p&gt;Haskell のレコード構文&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; {&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;,&lt;span class="ot"&gt; hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を，型レベル辞書を用いて次のように書ける．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: Int, &amp;quot;hoge2&amp;quot; &amp;gt;: Text ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt; 言語拡張と組み合わせて，名前衝突の無いフィールド名を扱えたり，&lt;code&gt;lens&lt;/code&gt; を用いた OOP のような参照(e.g. &lt;code&gt;hoge ^. #hoge1&lt;/code&gt;)が出来る． また，&lt;a href="/posts/2017-11-28-fun-of-extensible-1.html"&gt;レコードの拡縮もできる&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="拡張可能バリアント"&gt;拡張可能バリアント&lt;/h3&gt;
&lt;p&gt;次のような直和型&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Hoge1&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Hoge2&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を，型レベル辞書を用いて，バリアント型のように書ける．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: Int, &amp;quot;hoge2&amp;quot; &amp;gt;: Text ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(正直あんまり利点が分かってないけど)拡縮はもちろん，&lt;a href="/posts/2018-01-31-fun-of-extensible-2.html"&gt;バリアントの操作関数をファイル分割して実装&lt;/a&gt;もできる．&lt;/p&gt;
&lt;h3 id="拡張可能作用"&gt;拡張可能作用&lt;/h3&gt;
&lt;p&gt;型レベル辞書によってモナドスタックを表現する． 今回は次のようなモナドを定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Eff&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ ReaderDef Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;   , &lt;span class="dt"&gt;EitherDef&lt;/span&gt; &lt;span class="dt"&gt;ServiceException&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;   , &lt;span class="dt"&gt;LoggerDef&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本的に&lt;a href="/posts/2017-12-09-extensible-effects-step-by-step.html"&gt;普通のモナドトランスフォーマーのように扱える&lt;/a&gt;． じゃぁ素直にモナドトランスフォーマー使えよって感じかもしれないけど気にしないで．&lt;/p&gt;
&lt;h3 id="getopt-ラッパー"&gt;&lt;code&gt;GetOpt&lt;/code&gt; ラッパー&lt;/h3&gt;
&lt;p&gt;GHCには標準で &lt;code&gt;--output hoge&lt;/code&gt; みたいな CLI のオプション引数をパースしてくれるモジュール &lt;a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/System-Console-GetOpt.html"&gt;&lt;code&gt;GetOpt&lt;/code&gt;&lt;/a&gt; がある(ぼくは初めて使った)． extensible では，パース結果を拡張可能レコードにマッピングするための補助関数が&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-GetOpt.html"&gt;提供されている&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;キモになるのは &lt;code&gt;withGetOpt&lt;/code&gt; 関数である．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;withGetOpt&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;OptionDescr&lt;/span&gt; h) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一引数目の文字列はパース失敗したとき(要するにオプションが間違ってるとき)に表示する「使い方」に使われる． 例えば，whoami だと&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;whoami [options] [input-file]
  -o FILE               --output=FILE                Write output to FILE instead of stdout.
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT  Specify output format. default is `markdown`.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;の &lt;code&gt;[options] [input-file]&lt;/code&gt; が一引数目だ． 二引数目はオプションのパーサー(？)の定義を拡張可能レコードで与えており，三引数目がパース結果の拡張可能レコードと残りの(空白区切りの)文字列を受け取ってどうするかの振る舞いを与える．&lt;/p&gt;
&lt;p&gt;まぁ詳しくは&lt;a href="https://www.schoolofhaskell.com/user/fumieval/extensible/getopt-and-extensible-records"&gt;作者さんの記事&lt;/a&gt;で紹介されている(英語だけど，あと一引数目の文字列はこの記事以降に追加された機能らしく，サンプルコードにはない)．&lt;/p&gt;
&lt;h3 id="extensible-instances"&gt;extensible-instances&lt;/h3&gt;
&lt;p&gt;拡張可能レコードは全て &lt;code&gt;Record '[...]&lt;/code&gt; の型エイリアスで定義する． つまり，拡張可能レコードの何らかの型クラスのインスタンスは &lt;code&gt;Record '[...]&lt;/code&gt; に適用しておけば全部で使える(逆に影響力がでかいともいえる)．&lt;/p&gt;
&lt;p&gt;いくつかの自作アプリーケーションでインスタンスを作っていて，ダブってたのでひとつのリポジトリにまとめた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/extensible-instances"&gt;matsubara0507/extensible-instances - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(なんか作者本人じゃないから気が引けて) Hackage にはあげてないがパッケージの体はしてるので，&lt;a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos"&gt;&lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;extra-deps&lt;/code&gt; に記述&lt;/a&gt;することで使えるはず．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;注意点として &lt;a href="https://github.com/fumieval/extensible"&gt;fumieval/extensible&lt;/a&gt; の&lt;a href="https://github.com/fumieval/extensible/blob/master/examples/aeson.hs"&gt;例にある &lt;code&gt;FromJSON&lt;/code&gt; のインスタンス&lt;/a&gt;とは微妙に実装が違う． 作者さんのは &lt;code&gt;Maybe a&lt;/code&gt; にしてもキーが存在しないといけないのだが，&lt;code&gt;aeson&lt;/code&gt; の &lt;code&gt;Generics&lt;/code&gt; は &lt;code&gt;Maybe a&lt;/code&gt; ならキーが無くても良いので，そっちに合わせた．&lt;/p&gt;
&lt;h2 id="仕組み"&gt;仕組み&lt;/h2&gt;
&lt;p&gt;コード自体は&lt;a href="https://github.com/matsubara0507/whoami"&gt;このリポジトリ&lt;/a&gt;にある．&lt;/p&gt;
&lt;h3 id="基本的な部分"&gt;基本的な部分&lt;/h3&gt;
&lt;p&gt;基本的に Yaml ファイルにはサイト・記事・ライブラリ・アプリケーションを列挙してもらう． それらは次のような型になっている(型の値として取り出せる)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot;    &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;account&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Accounts&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;SiteConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;post&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;latest&amp;quot; &amp;gt;: Maybe Int, &amp;quot;posts&amp;quot; &amp;gt;: [PostConfig]]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;library&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;LibConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   , &lt;span class="st"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;     &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;AppConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;   , &lt;span class="st"&gt;&amp;quot;qiita&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;QiitaConfig&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Accounts&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" data-line-number="15"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SiteConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" data-line-number="16"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" data-line-number="17"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" data-line-number="18"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-19" data-line-number="19"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-21" data-line-number="21"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;PostConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-22" data-line-number="22"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;title&amp;quot; &amp;gt;: Maybe Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-23" data-line-number="23"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-24" data-line-number="24"&gt;   , &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-25" data-line-number="25"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-26" data-line-number="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-27" data-line-number="27"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LibConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-28" data-line-number="28"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-29" data-line-number="29"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-30" data-line-number="30"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-31" data-line-number="31"&gt;   , &lt;span class="st"&gt;&amp;quot;language&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-32" data-line-number="32"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-33" data-line-number="33"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-34" data-line-number="34"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;AppConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-35" data-line-number="35"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-36" data-line-number="36"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-37" data-line-number="37"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-38" data-line-number="38"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt;パッケージを使って，Yaml ファイルから &lt;code&gt;Config&lt;/code&gt; 型にデコードしてもらう． &lt;code&gt;Maybe a&lt;/code&gt; になっているところは書いてあっても無くても良い項目だ．&lt;/p&gt;
&lt;p&gt;そしてサイト・記事・ライブラリ・アプリケーション固有の &lt;code&gt;Config&lt;/code&gt; 型を共通のフォーマットである &lt;code&gt;Info&lt;/code&gt; 型に変換する手続きを型クラスを用いて定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;type&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;ServiceType&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;ServiceType&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;post&amp;quot; &amp;gt;: Post&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;lib&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Library&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;   , &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Site&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-13" data-line-number="13"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-15" data-line-number="15"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Uniform&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-16" data-line-number="16"&gt;&lt;span class="ot"&gt;  fetch ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-17" data-line-number="17"&gt;&lt;span class="ot"&gt;  fill ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-18" data-line-number="18"&gt;&lt;span class="ot"&gt;  uniform ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-20" data-line-number="20"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-22" data-line-number="22"&gt;&lt;span class="ot"&gt;toInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Uniform&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-23" data-line-number="23"&gt;toInfo conf &lt;span class="fu"&gt;=&lt;/span&gt; uniform &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; fill conf &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; fetch conf&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Uniform&lt;/code&gt; 型クラスに3つの関数は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt; 関数は共通のフォーマットにするための足りない情報(&lt;code&gt;Maybe a&lt;/code&gt; で &lt;code&gt;Nothing&lt;/code&gt; だったところ)をスクレイピングなどで補完&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch&lt;/code&gt; 関数はスクレイピングするための HTML などを取ってくる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform&lt;/code&gt; 関数は実際に共通フォーマットに変換する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といった具合だ(正直分けなくてもいい)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;他にも GitHub・BitBacket・GitLab なんかを全部一緒に取り扱う &lt;code&gt;Repo&lt;/code&gt; とかも作ってもいいかもしれない． 問題は，自分が GitHub 以外に使ってないのでテストできない点だ．&lt;/p&gt;
&lt;h3 id="qiita-とか"&gt;Qiita とか&lt;/h3&gt;
&lt;p&gt;Qiita とかは RESTful API を叩いて記事を集めてる． そもそも記事自体を集めるところと，&lt;code&gt;Uniform&lt;/code&gt; 型クラスのインスタンスを共通化するのに &lt;code&gt;Service&lt;/code&gt; 型クラスを作った(名前が微妙)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Service&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  genInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; [&lt;span class="dt"&gt;Info&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy a&lt;/code&gt; なのはしょうがない． お好きなサービス(自分のサイトとかでも)を &lt;code&gt;Service&lt;/code&gt; 型クラスのインスタンスにして，&lt;code&gt;Whoami&lt;/code&gt; 型のインスタンスを書き換えれば，いろんなサイトを共通の形式で扱える．&lt;/p&gt;
&lt;h2 id="on-github-pages"&gt;on GitHub Pages&lt;/h2&gt;
&lt;p&gt;GitHub Pages で簡単に使えるようにした． サンプルのリポジトリを作ったので，これをフォークして Travis CI と GitHub Pages を設定するだけで使えるはずだ(もちろん &lt;code&gt;whoami.yaml&lt;/code&gt; を書き換えて)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/whoami-example"&gt;matsubara0507/whoami-example - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Stackage (というか Hackage)に置いていないツールを &lt;code&gt;stack install&lt;/code&gt; するために，&lt;code&gt;package.yaml&lt;/code&gt; と &lt;code&gt;stack.yaml&lt;/code&gt; と &lt;code&gt;.gitignore&lt;/code&gt; を置いてるけど気にしないで． Travis CI の定期実行を設定しておけば定期的に Qita の記事とかを更新してくれる．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;そーいえば，UNIX 系には &lt;code&gt;whoami&lt;/code&gt; というコマンドがあるんでしたね(Windowsユーザー)． 紛らわしい名前にしてしまった．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2018/02/14/160833</id><title type="text">Haskellの実行バイナリにファイルを埋め込む</title><updated>2018-02-14T16:12:25+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2018/02/14/160833"/><summary type="html">コンパイルしてできる実行バイナリにファイルを埋め込みたいことがある。
アプリのGUIで使うアイコンとか機械学習の学習済みモデルとか。
Go では (現在では非推奨らしいが) go-bindata を使う場面だろうか。

Haskell ではそういうときには [file-embed](https://hackage.haskell.org/package/file-embed) パッケージが使える。
たとえば `[project root]/resources/lorem.txt` に置かれた [lorem ipsum](https://ja.wikipedia.org/wiki/Lorem_ipsum) テキストを埋め込む場合:</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/02/05/135542</id><title type="text">Re: 凸頂点の数 横へな2016.4.2 問題</title><updated>2018-02-05T13:55:42+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/02/05/135542"/><summary type="html">凸頂点の数 。30分。 今回は共通化したいところをグッとこらえてコピペ。前回まで初めから抽象化にこだわって問題を解いていたが、具象例が集まってからのほうが良い抽象化ができることから、60分という時間を考えると抽象化はし過ぎないほうが良い選択だということだろう。 この問題の場合、各頂点に2つの図形が隣接するが、そのうちいずれかと隣接してしまうと凸頂点ではなくなる。 00 でも同じ性質を満たしており、ほぼ同じ関数が使いまわせたのは面白いと感じた。 package Nofconv; use strict; use warnings; use Exporter qw(import); use List…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/02/04/154506</id><title type="text">Re: ぴったり含む長方形 横へな2016.3.5 問題</title><updated>2018-02-04T15:45:06+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/02/04/154506"/><summary type="html">ぴったり含む長方形 。点1個から帰納的に最小の長方形を出そうと方針を誤り、敗北。 方針変換後は45分。これはさらに15分かけて足切りを入れたもの。そもそも点を累積して数えるようにすればもっと速い。 package Pire; use strict; use warnings; use Exporter qw(import); our @EXPORT_OK = qw(solve); my @chars = ('0' .. '9', 'A' .. 'Z', 'a' .. 'z'); my %chars = do { my $i = 0; map { $_ =&gt; $i++ } @chars; }; …</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html</id><title type="text">「積み木の水槽」問題の Haskell での回答を読み解く</title><updated>2018-02-04T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;「積み木の水槽」問題の Haskell での回答を読み解く&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-04" itemprop="datePublished"&gt;
        Feb 4, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;今朝，バイト先で&lt;a href="http://nabetani.sakura.ne.jp/hena/ord13blocktup/"&gt;「積み木の水槽」問題&lt;/a&gt;の &lt;a href="https://rosettacode.org/wiki/Water_collected_between_towers#Haskell"&gt;Haskell での回答&lt;/a&gt;について話題になりました． リンク先の解答を見ると，恐ろしいことに，一行で書けてしまいます(正しくは，この解答では &lt;code&gt;nabetani&lt;/code&gt; さんの問題は解けませんが…)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- 2 == solve [1,5,3,7,2]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; filter (&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通の Haskeller であれば，これぐらい目コンパイルして振る舞いを読み解くのは朝飯前でしょうが，Haskell 初学者のために簡単な解説を残しておこうかなと思います．&lt;/p&gt;
&lt;h2 id="手直し"&gt;手直し&lt;/h2&gt;
&lt;p&gt;前述したとおり，そもそもこれでは &lt;code&gt;nabetani&lt;/code&gt; さんの問題は解けないので，解けるように手直しします． もちろん &lt;strong&gt;1行で&lt;/strong&gt; ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; fmap (sum &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)) &lt;span class="fu"&gt;.&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))) &lt;span class="fu"&gt;.&lt;/span&gt; words &lt;span class="fu"&gt;.&lt;/span&gt; fmap (bool &lt;span class="ch"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (&lt;span class="fu"&gt;/=&lt;/span&gt;) &lt;span class="ch"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Data.List&lt;/code&gt; と &lt;code&gt;Data.Bool&lt;/code&gt; を &lt;code&gt;import&lt;/code&gt; してる前提だが，一応一行で書けた． 雑に直したのでもう少し短くできるような気もしますが，まぁそもそも本質的なところでないので勘弁してください．&lt;/p&gt;
&lt;p&gt;ちなみに，そもそもなんで元のコードでは解けないのかというと，&lt;code&gt;nabetani&lt;/code&gt; さんの問題には &lt;code&gt;0&lt;/code&gt; が含むからだ． しかし，&lt;code&gt;0&lt;/code&gt; で水槽を切り分けてあげて，元の解答を &lt;code&gt;map&lt;/code&gt; してあげれば良いだけなのでコアのところはそのまんま(&lt;code&gt;filter (&amp;gt; 0)&lt;/code&gt; は要らない気がしたので消したけど)．&lt;/p&gt;
&lt;h2 id="読み解く"&gt;読み解く&lt;/h2&gt;
&lt;p&gt;手直しした最終的なコードはテストコードと共に&lt;a href="https://gist.github.com/matsubara0507/10a44fb2a9676bde9658c3eeec456676"&gt;ココ&lt;/a&gt;にあげた．&lt;/p&gt;
&lt;h3 id="トップダウンに"&gt;トップダウンに&lt;/h3&gt;
&lt;p&gt;順に読み解く． Haskell でプログラミングするとき(というか関数型プログラミング)はトップダウンに書いていくのが基本なので，読み解くときも上から順に切り分けてく．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;solve ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; fmap countWater &lt;span class="fu"&gt;.&lt;/span&gt; splitTank&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ot"&gt;splitTank ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;splitTank &lt;span class="fu"&gt;=&lt;/span&gt;  words &lt;span class="fu"&gt;.&lt;/span&gt; fmap (bool &lt;span class="ch"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (&lt;span class="fu"&gt;/=&lt;/span&gt;) &lt;span class="ch"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;span class="ot"&gt;countWater ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;countWater &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)) &lt;span class="fu"&gt;.&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;splitTank&lt;/code&gt; 関数は &lt;code&gt;0&lt;/code&gt; を区切り文字として文字列を切り分けてるだけだ． 悲しいことに，Haskell (というか GHC)の標準モジュールには「任意の文字で文字列を切り分ける」関数がない． なので，&lt;code&gt;0&lt;/code&gt; だけを空白 &lt;code&gt;' '&lt;/code&gt; に置換してから，&lt;code&gt;words&lt;/code&gt; で切り分けている(空白で切り分ける関数 &lt;code&gt;words&lt;/code&gt; は何故か標準にある)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;countWater&lt;/code&gt; 関数が各水槽の水の数を数え上げており，それを最後に総和 &lt;code&gt;sum&lt;/code&gt; しているだけだ．&lt;/p&gt;
&lt;h3 id="fmap-はわかるよね"&gt;&lt;code&gt;fmap&lt;/code&gt; はわかるよね？&lt;/h3&gt;
&lt;p&gt;ちなみに，さっきから出てきている &lt;code&gt;fmap&lt;/code&gt; という関数はわかりますよね？ 多くの言語でも導入されている，リストや配列の各要素に関数を適用する関数(あるいはメソッド) &lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt; をより一般化したものだ． 今回はリストにしか使わないので &lt;code&gt;map&lt;/code&gt; と同義だと考えてくれていい(hlint で注意されるので，&lt;code&gt;fmap&lt;/code&gt; と書く癖がついた)．&lt;/p&gt;
&lt;h3 id="コアの部分"&gt;コアの部分&lt;/h3&gt;
&lt;p&gt;さて，本題でもある &lt;code&gt;countWater&lt;/code&gt; 関数を読み解く． まずは切り分けよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;countWater ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;countWater &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; toWaterLine &lt;span class="fu"&gt;.&lt;/span&gt; toInts&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;toInts ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;toInts &lt;span class="fu"&gt;=&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;&lt;span class="ot"&gt;toWaterLine ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;toWaterLine &lt;span class="fu"&gt;=&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;toInts&lt;/code&gt; 関数は数列の文字列から数値のリストに変換している． Haskell で文字列を任意の型に変換するには &lt;code&gt;read :: String -&amp;gt; a&lt;/code&gt; 関数を使う． Haskell において &lt;code&gt;String = [Char]&lt;/code&gt; なので，&lt;code&gt;fmap (: [])&lt;/code&gt; をして &lt;code&gt;String&lt;/code&gt; のリストに変換し，各文字列を &lt;code&gt;read&lt;/code&gt; をしているというわけだ(&lt;code&gt;singleton&lt;/code&gt; みたいな関数が標準にあればいいのに)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toWaterLine&lt;/code&gt; 関数が水槽の各列の水の量を計算し，&lt;code&gt;sum&lt;/code&gt; で総和している． なので，重要なのは &lt;code&gt;toWaterLine&lt;/code&gt; 関数だ． &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; 演算子や &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; 演算子などがあって意味不明かもしれないが，この辺りはポイントフリーにするためのツールみたいなもので，アルゴリズムの本質的な部分ではないよ．&lt;/p&gt;
&lt;h3 id="関数も-monad-型クラスのインスタンス"&gt;関数も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; 演算子や &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; 演算子が何をしているかと言うのは &lt;strong&gt;関数型 &lt;code&gt;(-&amp;gt;) a&lt;/code&gt; も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス&lt;/strong&gt; だという事実を知っていれば簡単に読めますね． Haskell 界隈では常識(要出典)なので，説明しなくても良いかもしれないが，初学者のために念のためしておく．&lt;/p&gt;
&lt;p&gt;それぞれの演算子の型は以下の通り(めんどいので &lt;code&gt;Monad&lt;/code&gt; で統一)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(&amp;lt;*&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; m (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="ot"&gt;(=&amp;lt;&amp;lt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;で，前述したとおり，関数型 &lt;code&gt;(c -&amp;gt;)&lt;/code&gt; も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンスなので，&lt;code&gt;m = (c -&amp;gt;)&lt;/code&gt; と置き換えれる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(&amp;lt;*&amp;gt;) ::&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ot"&gt;(=&amp;lt;&amp;lt;) ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;便利そうなコンビネーターになった． なので，&lt;code&gt;toWaterLine&lt;/code&gt; 関数のこれらの演算子を同様のラムダ式で置き換えてあげよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toWaterLine ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;toWaterLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) ((\ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;$&lt;/span&gt; ys) (scanr1 max ys)) xs) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) ((\ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith min (scanl1 max ys) (scanr1 max ys)) xs) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) (zipWith min (scanl1 max xs) (scanr1 max xs)) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ついでに，他の言語の人では分かりにくい演算子も置き換えたので，これでどの言語の人でも読めるはずだ．&lt;/p&gt;
&lt;h3 id="アルゴリズム"&gt;アルゴリズム&lt;/h3&gt;
&lt;p&gt;ここからは Haskell 関係ない． ひとつひとつ見ていこう．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scanl :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt; 関数は左畳み込み関数 &lt;code&gt;foldl :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b&lt;/code&gt; の途中経過もリストで残したような関数だ． つまり &lt;code&gt;foldl f x xs = last $ scanl f x xs&lt;/code&gt; が成り立つ． &lt;code&gt;scanl1 :: (a -&amp;gt; a -&amp;gt; a) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 関数は初期値を無くしたバージョンだ． &lt;code&gt;scanr1&lt;/code&gt; は &lt;code&gt;scanl1&lt;/code&gt; の右畳み込みバージョン．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;scanl max xs&lt;/code&gt; は左から順に，水槽の高さを比較して高い方を残しているので，各列の最も高い左側が残る． &lt;code&gt;scanr1 max xs&lt;/code&gt; は各列の最も高い右側が残る．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/water-towers-hs/water1.gif" /&gt;&lt;/p&gt;
&lt;p&gt;そして，それらの低い方を残して，もとの高さを引く．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/water-towers-hs/water2.gif" /&gt;&lt;/p&gt;
&lt;p&gt;すごいできた！&lt;/p&gt;
&lt;h2 id="試しに"&gt;試しに&lt;/h2&gt;
&lt;p&gt;次のテストコードを走らせてみた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- WalterTowers.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; all ((&lt;span class="fu"&gt;==&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; snd &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (show &lt;span class="fu"&gt;.&lt;/span&gt; solve &lt;span class="fu"&gt;.&lt;/span&gt; fst)) testSet&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;testSet ::&lt;/span&gt; [(&lt;span class="dt"&gt;String&lt;/span&gt;, &lt;span class="dt"&gt;String&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;testSet &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;  [ (&lt;span class="st"&gt;&amp;quot;83141310145169154671122&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;24&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;  , (&lt;span class="st"&gt;&amp;quot;923111128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;45&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;  , (&lt;span class="st"&gt;&amp;quot;923101128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;  , (&lt;span class="st"&gt;&amp;quot;903111128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;9&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;  , (&lt;span class="st"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;  , (&lt;span class="st"&gt;&amp;quot;31&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" data-line-number="15"&gt;  , (&lt;span class="st"&gt;&amp;quot;412&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-16" data-line-number="16"&gt;  , (&lt;span class="st"&gt;&amp;quot;3124&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-17" data-line-number="17"&gt;  , (&lt;span class="st"&gt;&amp;quot;11111&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-18" data-line-number="18"&gt;  , (&lt;span class="st"&gt;&amp;quot;222111&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-19" data-line-number="19"&gt;  , (&lt;span class="st"&gt;&amp;quot;335544&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-20" data-line-number="20"&gt;  , (&lt;span class="st"&gt;&amp;quot;1223455321&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-21" data-line-number="21"&gt;  , (&lt;span class="st"&gt;&amp;quot;000&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-22" data-line-number="22"&gt;  , (&lt;span class="st"&gt;&amp;quot;000100020003121&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-23" data-line-number="23"&gt;  , (&lt;span class="st"&gt;&amp;quot;1213141516171819181716151413121&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;56&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-24" data-line-number="24"&gt;  , (&lt;span class="st"&gt;&amp;quot;712131415161718191817161514131216&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;117&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-25" data-line-number="25"&gt;  , (&lt;span class="st"&gt;&amp;quot;712131405161718191817161514031216&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;64&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-26" data-line-number="26"&gt;  , (&lt;span class="st"&gt;&amp;quot;03205301204342100&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-27" data-line-number="27"&gt;  , (&lt;span class="st"&gt;&amp;quot;0912830485711120342&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;18&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-28" data-line-number="28"&gt;  , (&lt;span class="st"&gt;&amp;quot;1113241120998943327631001&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;20&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-29" data-line-number="29"&gt;  , (&lt;span class="st"&gt;&amp;quot;7688167781598943035023813337019904732&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;41&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-30" data-line-number="30"&gt;  , (&lt;span class="st"&gt;&amp;quot;2032075902729233234129146823006063388&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;79&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-31" data-line-number="31"&gt;  , (&lt;span class="st"&gt;&amp;quot;8323636570846582397534533&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;44&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-32" data-line-number="32"&gt;  , (&lt;span class="st"&gt;&amp;quot;2142555257761672319599209190604843&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;41&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-33" data-line-number="33"&gt;  , (&lt;span class="st"&gt;&amp;quot;06424633785085474133925235&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;51&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-34" data-line-number="34"&gt;  , (&lt;span class="st"&gt;&amp;quot;503144400846933212134&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;21&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-35" data-line-number="35"&gt;  , (&lt;span class="st"&gt;&amp;quot;1204706243676306476295999864&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;21&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-36" data-line-number="36"&gt;  , (&lt;span class="st"&gt;&amp;quot;050527640248767717738306306596466224&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;29&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-37" data-line-number="37"&gt;  , (&lt;span class="st"&gt;&amp;quot;5926294098216193922825&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;65&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-38" data-line-number="38"&gt;  , (&lt;span class="st"&gt;&amp;quot;655589141599534035&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;29&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-39" data-line-number="39"&gt;  , (&lt;span class="st"&gt;&amp;quot;7411279689677738&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;34&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-40" data-line-number="40"&gt;  , (&lt;span class="st"&gt;&amp;quot;268131111165754619136819109839402&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;102&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-41" data-line-number="41"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;stack runghc&lt;/code&gt; で走らせると．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack runghc WalterTowers.hs
True&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;こういうのを自分で思いつけるようになりたいね…&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/02/03/142044</id><title type="text">Re: まわせ! Bouwkamp!! 横へな2016.2.6 問題</title><updated>2018-02-03T14:20:44+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/02/03/142044"/><summary type="html">まわせ! Bouwkamp!! に挑戦したが、惜敗。90分かかった。 正攻法で挑むと楽しい良問ではあったが、意外に手数が多い。 package Bouwkamp; use strict; use warnings; use Exporter qw(import); our @EXPORT_OK = qw(solve); sub decode_bouwkamp ($) { my @result; while ($_[0] =~ /\((\d+(?:,\d+)*)\)/g) { push @result, [split /,/, $1, -1]; } \@result; } sub sort_po…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/02/01/140804</id><title type="text">Re: 不良セクタの隣〜 横へな 2014.3.7 問題</title><updated>2018-02-01T14:18:35+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/02/01/140804"/><summary type="html">不良セクタの隣 の問題で肩慣らし。 以下はとりあえずテスト通しただけの状態そのままのコード。単体テスト含めてフルスクラッチからで45分くらい。場当たり的にモジュール化したので、無駄が多い。 初め「複数の」を見落としてて、最後に方針転換したけど、適度にモジュール化されてたのでなんとかなった。 Cloud9上で解いたので、キーバインドでも苦しんだ。Ctrl-s 押し忘れてセーブされてなかったり Ctrl-k 押してよくわからなくなったり。あと、45分の時間には含んでないけど、 コアモジュールのインストールも必要 。 package Sector; use strict; use warnings;…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2018/01/27/%E5%BC%8A%E5%90%8C%E4%BA%BA%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E3%81%AE%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F</id><title type="text">弊同人サークルのウェブサイトを作りました</title><updated>2018-01-28T12:39:56+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2018/01/27/%E5%BC%8A%E5%90%8C%E4%BA%BA%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E3%81%AE%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F"/><summary type="html">がんばった。 doujin.kakkun61.com GitHub Pages だからと Jekyll にしたけど、生成したものを置けばいいんだから Hakyll でもよかったな。変えようかなというところ。 後はレスポンシブ対応したい。</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/01/19/101040</id><title type="text">GHCi上でpiと打てば円周率が表示されるという話</title><updated>2018-01-19T19:06:10+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/01/19/101040"/><summary type="html">裏書きに残りっぱなしになってたのを書いておく。GHCI上で pi と打つと、πの値が表示できる。 Prelude&gt; pi 3.141592653589793 Pythonだとそうはいかない。 &gt;&gt;&gt; pi Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'pi' is not defined &gt;&gt;&gt; from math import pi &gt;&gt;&gt; pi 3.141592653589793 つまり、Haskellではグローバルな名前空間に pi が出ているように見えるとい…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/01/09/133833</id><title type="text">自分の開発環境用Vagrantfileを作った</title><updated>2018-01-09T13:38:33+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/01/09/133833"/><summary type="html">qiita.com ubuntuのインストール作業に勤しむ意味はないので、vagrantに任せることに。 ということでWindows上でvagrant使うことに決めたのだけど、Surface StudioとSurface Book 2の両方で環境構築するのはダルいので Vagrantfile 作って上げた。 github.com 最近はデフォルト厨なので Vagrantfile なんて要らんかなと思ったのだけど、細かい調整でハマって時間を潰してしまったりしたので、まとめることにした。細かい点とは、例えば以下の通り。 stack は apt で入れない (コマンドを覚えられないのでググるのがめん…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2018/01/01/173124</id><title type="text">WindowsのreaderアプリがEdgeに惨殺される</title><updated>2018-01-01T20:35:02+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2018/01/01/173124"/><summary type="html">Windowsのreaderアプリが2/15で使えなくなるとのこと 。騒いでいる人がほとんどいないけど、Surfaceをタブレットモードで使ったときの相性が非常に良かったので、どうしてそんなことをするのか全く理解ができない1。これでSurfaceを使う理由が1つなくなってしまった。 2/15までサポートされるということになっているが、readerアプリを立ち上げると画面上部がメッセージで専有されてUIがぶっ壊れるので、もうすでに使い物にならない。スクリーンショット取るのが億劫だったのでTwitterから拝借。 Windows にはほとんどアプリを入れていないので、PDF も Reader で読…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/12/28/103308</id><title type="text">Haskell入門の10章をDocker化する</title><updated>2017-12-28T10:33:08+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/12/28/103308"/><summary type="html">Haskell入門 の10章は、 SQLite への依存があったりして Windows で試すのは若干面倒だったので、 Docker for Windows で試せるようにした。 https://github.com/hiratara/Haskell-Nyumon-Sample/compare/docker/chap10 docker/chap10 ブランチを持ってきて、Docker for Windows が動いている環境でこんな感じで動かせる。 $ docker-compose build $ docker-compose run --rm --service-ports weight-r…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/12/24/202404</id><title type="text">ガバガバAltJSを作った(言語実装 Advent Calendar 2017)</title><updated>2017-12-24T20:27:10+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/12/24/202404"/><summary type="html">qiita.com JavaScriptを書いていると、頻出する継続渡しのリフレインにうんざりさせられる。 foo.bar(function(result){ qux.baz(function(data){ hoge(function(r){ ... }); }); }); そこで、腕試しに継続モナドをベースにしたAltJS、jatkoを作った。フィンランド語で「継続」という意味だ(継続戦争から知った人も多いだろう)。しかし、なんの考えもなしに653行Haskellを書いた結果ガバガバな言語になってしまった。 Hello, world Haskellにだいぶ近いのでなんとなく読めるはず。 in…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/12/19/203500</id><title type="text">HaskellのABC(Haskell Advent Calendar 6th)</title><updated>2017-12-19T20:35:00+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/12/19/203500"/><summary type="html">Haskellといえば一文字変数名、一文字変数名といえばHaskellという{{要出典}}ほどにHaskellでは一文字の変数名がよく使われている。これは名前を考えるのをサボっているとは限らない。多相性によって変数が具体的な性質を持たないがゆえに、具体的な名前がつけられないというのが主な理由だ。あるいは、適切な名前があっても、既存の名前と被っているという場合もある。かといって完全なランダムというわけでもないので、一文字変数名はどのように選べばいいか考察していこう。 a よくある種: * アルファベットの最初であるaは汎用性が高い。型変数に使うのが王道だ。値レベルの変数として単体で使うことは意外…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/12/12/170000</id><title type="text">Go言語のHTTPリクエストのレスポンスボディーとEOF</title><updated>2017-12-12T18:16:42+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/12/12/170000"/><summary type="html">Reader interface の Read 関数は、どのタイミングで io.EOF を返すのでしょうか。 まずは strings.Reader で見てみましょう。 package main import ( "fmt" "strings" ) func main() { r := strings.NewReader("example\n") for { var b [1]byte n, err := r.Read(b[:]) fmt.Printf("%d %q %v\n", n, b, err) if err != nil { break } } } 結果 1 "e" &lt;nil&gt; 1 "x…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/12/11/090512</id><title type="text">Surface Book 2 15”  を買った</title><updated>2017-12-12T17:21:51+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/12/11/090512"/><summary type="html">去年 と同様に、今年は Surface Book 2 15” を個人輸入した。 MS製品の個人輸入は3度目 1 で、毎年年末の散財の恒例行事となりつつある。 誤解のないように書いておくと、Surface Book 2は 国内でも販売している 。ただし、 15” はUSのみでの販売であるのと、US配列も国内では手に入らない。 15” は フルパワーだと電源につないでいてもバッテリーが減る という問題はあるものの、実用上そんなに困ってはいない。ゲーミングでむしろ邪魔になるのは高温でパワーが抑制されてしまう方で、これは結構頻繁に遭遇する。ので、ゲーミングに使うときは設定は低めの設定で使っている。PU…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/07/02/174426</id><title type="text">Haskellの最近の例外ハンドリング</title><updated>2017-12-06T17:19:02+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/07/02/174426"/><summary type="html">どうもHaskellには標準のControl.Exceptionモジュールだけでなくmtlやexceptionsやexceptionalといった例外を扱うためのパッケージがあるらしいのだが、そのあたりのパッケージの選び方や使い方についてまとまった情報を見つけられなかった。 HaskellWiki例外のページも少々古いようで、deprecatedなものや統合される前のパッケージを書いていたりする。 調べた限り、mtlとexceptionsが今の主流っぽい。 その2つの使い方をまとめる。 なおバージョンはlts-6.1を基準としている。 mtl mtlパッケージのControl.Monad.Exc…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/08/28/175500</id><title type="text">続・Haskellの最近の例外ハンドリング</title><updated>2017-12-06T17:18:53+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/08/28/175500"/><summary type="html">前回 の記事ではHaskellの例外ハンドリングには exceptions パッケージを使えばいいのではないかと書いた。 ところが今年の6月に safe-exceptions という exceptions を拡張したようなパッケージがさる FPComplete から 発表 された。 そこでこの記事では safe-exceptions について調べてみる。 おそらくほぼ FPComplete の発表の受け売りになってしまうので英語を読める人は原文を読む方がいいかもしれない。 さすが FPComplete だけあってこれは既に LTS Haskell に入っている。 この記事では lts-6.14…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/haskell-library-2016</id><title type="text">Haskellライブラリ所感2016</title><updated>2017-12-06T17:18:40+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/haskell-library-2016"/><summary type="html">(これは Haskell Advent Calendar 2016 の7日目の記事です) 今年使ったり調べたりした Haskell ライブラリを広く紹介していく企画です。 あくまで今年使ったものなので新しいものばかりではないです。 また記事の性質上、紹介するものが偏っていてもご容赦ください。 Hackage にはすごい数のライブラリが登録されていて、 頼もしいことですが目が回りそうにもなってしまいます。 この記事が Haskell のライブラリを調べる上での指針になったら幸いです。 なおこの企画と方向性が似ているものとして State of the Haskell ecosystem ( 20…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/04/26/005415</id><title type="text">超技術書典でGHCJSの本を出します</title><updated>2017-12-06T17:18:31+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/04/26/005415"/><summary type="html">【告知】ニコニコ超会議2017と併催される超技術書典Day1(4/29)にて、GHCJSの入門的な本を出します。@y_taka_23 さんのスペースに委託する形になります。Haskell×JavaScriptに興味のある方はぜひA-04まで。 #技術書典 #超技術書典 pic.twitter.com/zUhiVc3CyX — しょしー 超技術書典A-04 (@syocy) 2017年4月25日 出します。 GHCJSの仕組みの話はほとんどなくて、あくまで使い方とか周辺事情の話になります。 GHCJSって昔は導入すること自体が難しくて、他のHaskell系AltJSに水をあけられている感があった…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/05/20/025021</id><title type="text">Haskellは真面目なアプリケーション開発に向いている</title><updated>2017-12-06T17:18:19+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/05/20/025021"/><summary type="html">qiita.com ↑の記事で（主題ではないと思うものの）Haskellの批判に結構な分量が割かれていて、その批判のなかに「ちょっと違うんじゃないかな」という点がいくつかあったので反論ぽいことを書きます。 "Haskell は真面目なアプリケーション開発には向いてない"について これには多分いくつか事例を挙げればよくて、 Facebook ではスパム等の攻撃と戦うためのシステムを Haskell で作っています。 Fighting spam with Haskell | Engineering Blog | Facebook Code | Facebook (この記事を書いている Simon …</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/08/14/235830</id><title type="text">HaskellとJSON、そしてレコード型</title><updated>2017-12-06T17:18:07+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/08/14/235830"/><summary type="html">HaskellのJSON周りについて、こうやるのがいいんじゃないかという私の現在のやり方を書きます。 題材としては、 Swagger Petstore に記されている REST API にリクエストを投げてレスポンスを取り出すというのをやります。 (Swagger ですが scaffold は使わず自分で HTTP クライアントライブラリを使います)。 基本方針は「出力は厳密に入力には寛容に」(出典失念) です。 もくじ JSONの前に: レコードのフィールドへのアクセス JSONの前に: レコードのデフォルト値 Haskellのデータ型→JSON JSONデータを含むHTTPリクエスト レス…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/08/27/003035</id><title type="text">GoのTickerみたいなやつをHaskellで作った</title><updated>2017-12-06T17:17:55+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/08/27/003035"/><summary type="html">github.com 作った。 GoのTickerはとてもシンプルな関数で、 指定した周期でチャネルに値を送るスレッドを生成する。 一定間隔で何かの処理を行いたいときに利用する。 今回作ったHaskell版もだいたい同じようなものを提供する。 実際のところパッケージにするには小さすぎる気もするけど、 Haskellパッケージ製作の練習をしたかったのでHackageのアカウントを取ってHackageに上げた。 練習のため、HaddockによるAPIドキュメントおよびhspecとdoctestによるテストも書いてある。 あとは何かCIを導入してGithubのページにCIのステータスを表示するような…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell</id><title type="text">A Tour of Go in Haskellを作ったのと、GoとHaskellの比較</title><updated>2017-12-06T17:17:38+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell"/><summary type="html">A Tour of Go in Haskell (日本語版/英語版) というサイトを作ったので、それの紹介をします。 https://a-tour-of-go-in-haskell.syocy.net/ja_JP/index.html Haskell は Go と同じく軽量スレッドやチャネルの機能があり、並行並列が得意な言語です。このサイトは A Tour of Go という Go のチュートリアルの並行性の章を題材として２つの言語を比較しています。</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/12/04/044908</id><title type="text">NGK2017B で Liquid Haskell について話してきました</title><updated>2017-12-04T04:49:08+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/12/04/044908"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2017B / 名古屋合同懇親会 2017 忘年会 で発表してきました。 Liquid Haskell で普通の型システムの上を行け #NGK2017B from y_taka_23 www.slideshare.net 当日の動画は NGK2017B 第2部 - YouTube から見ることができます。 ちなみに NGK での発表は 5 年連続 5 回目です。前回まではモデル検査をテーマにしていましたが、今回はちょっと目先を変えて（とはいえ同じ形式手法の枠内ですが）もう少しプログラム寄りの題材として Liquid Haskell を選びました。 N…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/11/28/201852</id><title type="text">今日は「Club MySQL #2：(MySQLの)XProtocolはじめました、Haskellで」の日です</title><updated>2017-11-28T21:07:55+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/11/28/201852"/><summary type="html">マニアックなイベント に来てますので、メモを残しています。 XProtocol始めました、Haskellで / Naoto Ogawaさん 意外とHaskellの人が多いかな、と haskellとMySQLで半分半分 XProtocol ProtocolBuffer Xはクロス (いろいろな言語から) CRUDスタイルAPIもある ドキュメントストアとの親和性 パイプライン処理(これに注目したい) XDev API EBNFの定義がある BNFとは？ → 文法を定義したもの 複数DBサーバのコネクション管理も含む（理解しきれてないけど） XPluginをMySQLへインストールする Xdev …</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/11/27/070558</id><title type="text">現在時刻をモックする Haskell ライブラリ time-machine を作ってみました</title><updated>2017-11-27T07:05:58+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/11/27/070558"/><summary type="html">主としてテスト時のために、現在時刻を操作する Haskell ライブラリを作成しました。Hackage にも登録済みです。 github.com 試しに次のコードを実行してみましょう。getCurrentTime しているはずなのに、返ってくる値が 1985 年 10 月 26 日になっているはずです。 module Main where import Control.Monad.TimeMachine import Control.Monad.Trans ( liftIO ) main :: IO () main = backTo (the future) $ do t &lt;- getCurr…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/11/17/090000</id><title type="text">zshの標準エラー出力の色を赤くする</title><updated>2017-11-17T09:01:59+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/11/17/090000"/><summary type="html">最近stderrを赤くするように設定したら、コマンドの出力がかなり見やすくなりました。 設定はこんな感じに書いてます。 zmodload zsh/terminfo zsh/system color_stderr() { while sysread std_err_color; do syswrite -o 2 "${fg_bold[red]}${std_err_color}${terminfo[sgr0]}" done } exec 2&gt; &gt;(color_stderr) fg_bold[red] のところを fg[red] とかbg_bold[red] とかするとスタイルを変更できます。 古い…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/11/06/090000</id><title type="text">Serverlessconf Tokyo 2017で『サーバレスアーキテクチャによる時系列データベースの構築と監視』という発表してきました</title><updated>2017-11-06T14:01:24+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/11/06/090000"/><summary type="html">先日開催されたServerlessconf Tokyo 2017にスピーカーとして参加しました。 2017.serverlessconf.tokyo Mackerelの今の時系列データベースは、マネージドサービスを組み合わせて作っています。 検証・実装・投入フェーズを終えて、運用・新機能開発フェーズに入っています。そんな中で、監視サービスを提供する私たちが、サーバーレスアーキテクチャで作ったミドルウェアをどのように監視しているかについてお話しました。 何かしら役に立つことや発想の元となるようなことをお伝えできていたらいいなと思います。 私も他の発表から様々なことを学びました。特に面白かった発表…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/25/033444</id><title type="text">技術書典 3 で新刊落としました</title><updated>2017-10-25T03:34:44+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/25/033444"/><summary type="html">先日、秋葉原で開催された技術系同人誌のオンリーイベント 技術書典 3 にサークル参加しました。 本当は新刊として Scala 用の静的解析ツール Stainless の入門書を頒布する予定で、サークルカットも完全にその線で準備していたのですが、残念ながら諸事情につき完成しませんでした。 事前にサークルチェックしてくださっていた 36 名の方々には大変申し訳ありませんでした。チェシャ猫先生の次回作にご期待ください。 何も並べるものがないのはちょっとどうかと思ったので、当日は 前回の技術書典 2 で頒布 した既刊『入門 LiquidHaskell』の PDF 版（ダウンロードカード）を持ち込みまし…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/18/202148</id><title type="text">Serverless Meetup Tokyo #6 で Kubernetes について話してきました</title><updated>2017-10-21T02:14:23+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/18/202148"/><summary type="html">先日行われた Serverless Meetup Tokyo #6 で、Kubernetes 上で動作する Serverless フレームワーク Fission について発表してきました。 Fission で 始める Containerless Kubernetes #serverlesstokyo from y_taka_23 www.slideshare.net 先週も 似たようなブログ を書いたような気がしなくもないですが、Kubeless と Fission を比較した前回の発表に対し、今回は話題を Fission に限定しています。一方で追加要素として、複数の Function を組…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/10/17/172322</id><title type="text">ステートマシン猛レース</title><updated>2017-10-19T18:19:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/10/17/172322"/><summary type="html">ストリーム処理ライブラリはHaskellにおいて競争の激しい分野の一つだ。ストリーム処理ライブラリとは大雑把に言うと、IOなどの作用を絡めながら値の列(ストリーム)を生成したり、処理したりする構造を提供するライブラリである。多くのライブラリは、以下の3種の構造を定義している。 生産者(プロデューサー): IOなどのアクションを伴いつつ値を生成する。 消費者(コンシューマー): 多くの場合モナド変換子になっており、await :: Consumer s m sのようなアクションを組み合わせ、値の列を処理するプログラムを書ける。 変換者(トランスデューサー): 入力を受け取りながら、出力もできる。…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/14/092409</id><title type="text">Kubernetes Meetup Tokyo #7 で Serverless について話してきました</title><updated>2017-10-14T09:24:09+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/14/092409"/><summary type="html">先日行われた Kubernetes Meetup Tokyo #7 で、Kubernetes 上で動作する Serverless フレームワークについて発表してきました。 Kubernetes でも Serverless したい！ #k8sjp from y_taka_23 www.slideshare.net Serverless on Kubernetes を謳うツールはいくつかありますが、今回はそのうち Kubeless と Fission に焦点を当て、それぞれのアーキテクチャの違いを比較してみました。 当日の補足 Twitter 上で反応をもらった点についていくつか補足します。 Fu…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/10/11/230117</id><title type="text">WindowsでのHaskell開発環境構築(2017年秋版)</title><updated>2017-10-13T23:20:39+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/10/11/230117"/><summary type="html">身の丈に合わないと形容されても仕方ないようなハイスペックなPCを買った。開発環境は当然作り直すことになるので、その軌跡を残しておく。 MSYS2 まずはMSYS2を入れる。これでツールチェーンが揃い、minttyというターミナルエミュレータもついてくる。 $ pacman -Syuu $ pacman -Sy git stack Haskellのビルドツールであるstackのインストーラを入手する。処理系から依存パッケージまで無難かつ自動的に用意してくれるので便利だ。 Home - The Haskell Tool Stack ただしstackはMSYS2上ではうまく動作しない。設定ファイル(…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/10/10/100000</id><title type="text">負荷を均すための『時間軸シャーディング』という考え方</title><updated>2017-10-10T10:46:10+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/10/10/100000"/><summary type="html">ウェブアプリケーションを作っていると、負荷を分散させるために「タイミングをばらけさせる」場面に時々遭遇します。 データの更新、キャッシュのフラッシュ、バッチ処理など様々な問題で、同じ構造が見られます。 例えば、スマホアプリからバックグラウンドで1時間ごとに何らかの情報をサーバーに送りたいとします。 愚直に毎時0分に更新処理を行うようにすると、すべてのユーザーから同じタイミングでリクエストが来てしまいます。 ですから、リクエストのタイミングをユーザーごとにばらして負荷を均す必要があります。 他のケースを考えます。 5分ごとにジョブを投入して何らかの更新を行うタスクがあるとします。 本来ならデータ…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/10/05/090000</id><title type="text">Mackerelのプラグインを書く楽しみ ― Rustでプラグインを書くためのライブラリを作りました！</title><updated>2017-10-07T14:43:39+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/10/05/090000"/><summary type="html">Mackerelは「エンジニアをワクワクさせる」ツールであることをサービスの大事な考え方の一つとして捉えています。 一体どういう場面でエンジニアはワクワクするのでしょうか。 簡単にインストールできるmackerel-agentや、直感的で触りやすい画面、チャットツールとの連携は大事な機能です。 しかし、監視ツールとしてもっと重要なのは、ミドルウェアのメトリックをどのように可視化し、何を監視するかということです。 Mackerelは公式のプラグインリポジトリに各種プラグインを揃えています (contributorの皆様ありがとうございます)。 これらはすべてGo言語で書かれています。 しかし、M…</summary></entry><entry><id>http://lotz84.github.io/posts/an-introduction-to-haskell-for-engineers.html</id><title type="text">エンジニアのための『Haskell入門』</title><updated>2017-10-03T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/an-introduction-to-haskell-for-engineers.html"/><summary type="html"></summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/08/15/C%23_%E3%81%A7%E3%83%A9%E3%83%B3%E3%82%AF_N_%E5%A4%9A%E7%9B%B8</id><title type="text">C# でランク N 多相</title><updated>2017-09-25T06:24:00+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/08/15/C%23_%E3%81%A7%E3%83%A9%E3%83%B3%E3%82%AF_N_%E5%A4%9A%E7%9B%B8"/><summary type="html">追記：これだと解決できていない。 C# に Sprache というパーサーコンビネーターがあるのだが、最近そいつを継続渡しスタイル（continuation passing style; CPS）にしてやろうと、Haskell のパーサーコンビネーター attoparsec を参考にいじっていた。 そこでこういう型があった。 newtype Parser i a = Parser { runParser :: forall r. State i -&gt; Pos -&gt; More -&gt; Failure i (State i) r -&gt; Success i (State i) a r -&gt; IResu…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/09/17/104015</id><title type="text">Haskell入門という本を書きました</title><updated>2017-09-17T10:49:04+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/09/17/104015"/><summary type="html">Haskell入門 という本を書きました。まだ店頭で買うことはできませんが、amazonでは予約を開始しています。また、電子版も早いうちに出ると聞いているので、そちらもあわせてお求め下さい。技術評論社さんのサイトではサンプルのpdfも読むことができます。 Haskellには すごいH本 というとても良い教科書がすでにありますが、「アプリケーションを作って楽しむ」という観点から書かれた本も欲しいなということを常々感じていました1。すごいH本でHaskellの考え方やプログラムの組み方は学べますが、例えば、プロジェクトを作成して開発を始めるにはどうするかであったり、必要なライブラリをどこから探して…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/09/14/150435</id><title type="text">Haskell ライブラリにスターを送るツール thank-you-stars を作ってみました</title><updated>2017-09-14T15:04:35+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/09/14/150435"/><summary type="html">Haskell の GitHub レポジトリを眺めてみると、有名ライブラリであってもスター数が意外と少ないことがあります。かの Yesod ですら本記事執筆時点で 1,794 個であり、Rails の 36,933 個や Django の 28,165 個と比較すると文字通り桁違いです。 スター数は必ずしも OSS としての評価や価値を反映しませんし、そもそも Haskell ユーザの絶対数が少ないからと言ってしまえばそれまでなのですが、若干寂しい感じがしません？ 一方、先日 id:teppeis さんが 依存しているライブラリにスターを送る npm ツール を公開されていました。そこで真似し…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/08/06/154901</id><title type="text">FRPクライシス</title><updated>2017-08-06T18:18:29+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/08/06/154901"/><summary type="html">FRP(Functional Reactive Programming)は、リアクティブプログラミングと関数型プログラミングの性質を持つプログラミングパラダイムである。FRPは古典的FRPと矢矧のFRPに大別される。 古典的FRP 古典的(Classical)FRPは、非連続的な値の列Eventと、常に何らかの値を取るBehaviourの二種類の構造を導入したものである。 代表的な実装としてreactive-banana、euphoria、reflexなどが挙げられる。 Haskellにおいては、EventはIOを通じて非同期的に生成できる設計が多い。Eventはマップやフィルタリングができ、…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/08/04/104221</id><title type="text">今日は「builderscon tokyo 2017 一日目」の日です</title><updated>2017-08-04T18:00:37+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/08/04/104221"/><summary type="html">慶応日吉キャンバスにおりますので、自分用のメモを残しておきます。 Opening / lestrrat さん 諸事情で英語(スライドは日本語)。 builderscon は YAPC::Asia の直系のカンファレンス いろんな技術の話を集めたものがbuilderscon 近年、様々な技術が互いに関わり合うようになっている 新しいものを発見する場 (Discover something new) #builderscon @builderscon スポンサーランチあるよ ベストスピーカー賞投票してね パネルで写真撮ってね STAFFは腕章つけてるよ 問い合わせは Twitter か googl…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/08/03/175919</id><title type="text">今日は「builderscon tokyo 2017 前夜祭」の日です</title><updated>2017-08-03T17:59:19+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/08/03/175919"/><summary type="html">おとなのビルコン へ来ていますので、自分用のメモを残しておきます。 めっちゃ混んでる。大規模カンファレンス感 「すげえ！」 「来てよかった！」</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/08/02/230422</id><title type="text">快速のExtensible effects</title><updated>2017-08-03T08:52:52+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/08/02/230422"/><summary type="html">extensibleは拡張可能レコードだけでなく拡張可能作用(extensible effects)も用意している。拡張可能作用は一時期Haskell界隈で話題になったものの、今では人気も下火になってしまった。新しいバージョンをリリースした今、拡張可能作用の動機と使い方について改めて紹介しよう。 難行の一次関数 Haskellでモナドをカスタマイズする方法としては、transformersのモナド変換子がよく使われている。モナド変換子は、モナドをパラメータとして取り、新たな能力を付与したモナドにする構造だ。例えば、StateT sはモナド変換子の一つである。任意のアクションm aはliftを使…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/01/30/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E6%AD%A3%E8%AA%A4%E8%A1%A8</id><title type="text">『遠回りして学ぶ Yesod 入門』正誤表</title><updated>2017-07-25T03:40:10+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/01/30/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E6%AD%A3%E8%AA%A4%E8%A1%A8"/><summary type="html">kakkun61.booth.pm C91 版 電子版では修正済みです。 ページ 章節 誤 正 補足 3 はじめに Yesod の初歩的な解説が書かれた本の上巻です。 Yesod の初歩的な解説が書かれた本の上巻です。 7 1 リンク切れの検出や リンク切れの検出や 17 3.2 これは quasi quote（準引用）と呼ばれる これは quasi quotes（準引用）と呼ばれる 表記の統一 20 4.1 メモリーに文字のデータが メモリーに文字列のデータが 23 5.1 GHC Users Guidehttp://wiki.haskell.org/GHC GHC Users Guide …</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/07/15/131139</id><title type="text">今日は「Haskell入門ハンズオン！」の日です</title><updated>2017-07-15T16:40:41+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/07/15/131139"/><summary type="html">今日は「Haskell入門ハンズオン！」の日です https://shinjukuhs.connpass.com/event/58224/へメンター枠で来ていますので、自分用のメモを残しておく。 はじめに / 木下さん #Haskel 講師重城さん＋メンター5人居ます haskellでわからないことはteratailで質問しましょう 8/28 に Haskell入門者LT大会やるよ Haskellの概要 / 重城さん 自己紹介 : Gentoo on KVM on Gentoo, TUT-code, Xmonad, rxvt-unicode, Tmux, Mutt, HHKB ハンズオンの中身…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/07/08/%E2%80%9Cmeaningless_REX_prefix_used%E2%80%9D_%E2%80%9Cuse_of_REX.w_is_meaningless%E2%80%9D</id><title type="text">“meaningless REX prefix used” “use of REX.w is meaningless”</title><updated>2017-07-09T00:20:11+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/07/08/%E2%80%9Cmeaningless_REX_prefix_used%E2%80%9D_%E2%80%9Cuse_of_REX.w_is_meaningless%E2%80%9D"/><summary type="html">コマンドプロンプトや PowerShell でプログラムを実行したときに次のようなエラーが出て困っていた。 [0x7FFE822C2B00] ANOMALY : meaningless REX prefix used [0x7FFE85B3DDA0] ANOMALY : use of REX.w is meaningless (default operand size is 64) REX プレフィックスとは何ぞや。 ロングモードでは、64ビット化するにあたり、16ビット時代から存在した1バイトのinc/dec命令であるinc reg16/dec reg16命令(op 0x40〜0x4f)を廃…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/07/20/PureScript_ver__0_7_0_%E4%BB%A5%E4%B8%8A%E3%81%A7%E3%81%AE_Hello%2C_World%21</id><title type="text">PureScript ver. 0.7.0 以上での Hello, World!</title><updated>2017-07-01T16:58:23+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/07/20/PureScript_ver__0_7_0_%E4%BB%A5%E4%B8%8A%E3%81%A7%E3%81%AE_Hello%2C_World%21"/><summary type="html">PureScript 0.7.1.0 で Node でコンソールに Hello, World! するところまでできたのでそのまとめ。 実例による PureScript を読んで勉強していたんだけど、先月終わりのバージョンアップの関係でそのままでは動かなくって調べたんでまとめる。英語の本家の方のドキュメントもこれから対応させていくらしい。 コマンドは Windows コマンドプロンプトのを使っているので UNIX 系の人は適宜読み替えること。 環境構築 用意するものは、PureScript コンパイラー（psc）と Node（NPM も使う）と Bower。（好みによって Cabal も。）NP…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/06/28/184113</id><title type="text">去年の9月にconduitの演算子が変わっていた</title><updated>2017-06-28T18:41:13+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/06/28/184113"/><summary type="html">conduitといえば $$ や $= =$= のような演算子を使い分けなければいけなくて 面倒だなものだと思っていた のだが、去年の9月から .| だけを使えばいいように変わっていた。これは直感的で使いやすい。 module Main (main) where import Data.Char (ord, chr, toUpper) import Data.Conduit (Conduit, runConduit, (.|)) import qualified Data.Conduit.Binary as B import qualified Data.Conduit.List as L i…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/06/20/124634</id><title type="text">自由モナドの定義であるところの Control.Monad.Free.Church.foldF</title><updated>2017-06-20T12:46:34+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/06/20/124634"/><summary type="html">圏論勉強会の資料 によれば、 と自由な構成 について、 を与えると が得られるとある。 自由モナドの文脈でこれを考えると、関手 からモナド (の構造を忘れて関手と思ったもの)への自然変換を定義すれば、自由モナド からモナド への自然変換(正確にはモナドモーフィズム)が得られるという意味となる。 free パッケージにこの対応関係に相当するものは入ってないのかなと探してみたら、 Control.Monad.Free.Church というモジュールで定義されていた。 foldF :: Monad m =&gt; (forall x. f x -&gt; m x) -&gt; F f a -&gt; m a The ver…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/06/19/090000</id><title type="text">音量を調節できるCLIツールをGo言語で作りました！</title><updated>2017-06-19T09:01:35+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/06/19/090000"/><summary type="html">volumeコマンドを作りました。 音量の調整ってコマンドからどうやるんだろう、ポータブルな形でコマンドラインツールがあれば便利なのでは… と思ったので作りました。 macOSとUbuntuで動作確認をしています。 インストール go get -u github.com/itchyny/volume-go/cmd/volume getは今の音量を返します。set (0-100) で音量を設定できます。 $ volume get 25 $ volume set 20 $ volume get 20 up, down, mute, unmuteなど、直感的に使えるサブコマンドを揃えています。 $ …</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/06/15/085810</id><title type="text">IOモナドで使うときだけログを吐く関数を定義する</title><updated>2017-06-15T08:58:10+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/06/15/085810"/><summary type="html">純粋な関数として定義できるんだけど内部でやってることが複雑な場合、何が起きてるかわからないと心配だからとログを吐く機能をつけると、その時点でそいつは IO アクションになってしまう。ログを吐くという副作用を持つのだから IO になるのは当たり前でそれを避けるべきではないのだけど、ログを吐かなくていいいシチュエーションでは、その計算を純粋な関数として使えたほうが理想的ではある。 そんなことを Identity と 型クラス 使えば簡単にできるんじゃねと思いついたんだけど、 monad-logger でそもそも機能が提供されてた。 runLoggingT や runNoLoggingT でモナドに…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/06/12/090000</id><title type="text">コマンドラインがさらに便利になるfillinコマンドを作りました！</title><updated>2017-06-12T16:23:44+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/06/12/090000"/><summary type="html">fillinというコマンドラインツールを作成しました。 コマンドの一部を変数化して、別の履歴に保存しておけるツールです。 ステージング環境と本番環境のように、同じコマンドで複数の環境を切り替えるのに便利です。 どうして作ったの コマンド履歴って便利ですよね。 私はよくコマンド履歴からコマンドを選んで実行しています。 シェルに付属しているデフォルトの履歴を使っている方もおられるでしょうし、fzfやpecoのようなインタラクティブな絞り込みを行なっている方もいるでしょう。 私が一番困っていたのが、認証キーの扱いです。 webアプリを作っていてcurlで素早く確認するときに、認証キーやアクセストーク…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/06/07/210000</id><title type="text">Vimに自分の書いたパッチが取り込まれた！</title><updated>2017-06-08T15:33:13+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/06/07/210000"/><summary type="html">Vim 8.0.0623に私の書いたパッチが取り込まれました。 わーい ∩(＞◡＜*)∩ わーい！ もともとのきっかけは、自分のプラグインを開発している中で、[\u3000-\u4000]という正規表現に対する挙動がset re=1とset re=2で違うことに気がついたのです。 Vimは正規表現エンジンを2つ積んでいる恐ろしいエディターなのですが、この2つの正規表現エンジンの挙動に微妙な違いがあることに気がつきました。 新しいNFAエンジンではエラーは出ませんが、古いエンジンではエラーが出ます。 古い正規表現エンジンでは、[a-z] みたいなパターンで、[\u3000-\u4000]のように…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/06/07/081239</id><title type="text">C言語の多次元配列の型はどう読むのか</title><updated>2017-06-07T08:16:46+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/06/07/081239"/><summary type="html">int a[2][3] って、「整数2個の配列( int a[2] )を 3個の配列( [3] )にした、と読めるけどどうなのか1。 http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf と比べて確認。 116ページのArray declaratorsの節によると、 T D[n] という形式のときは「… array of T」となると書かれている。ここで T は int で D は a[2] 、 n は 3 なので、「整数3個の配列… 」となる。 … の部分は仕様上で “derived-declarator-type-list” と…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/05/29/084112</id><title type="text">man introとcalコマンド</title><updated>2017-05-29T08:41:12+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/05/29/084112"/><summary type="html">月末って何曜日だっけとかってときいつもgoogleカレンダー開いてたんだけど、これでいいじゃん。知らなかった・・・。 ubuntu:~$ cal May 2017 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 man 1 intro したら書いてあった。 man intro なんて初めて使ったし、そもそも man の基本的な使い方もわかってないよね。適切な情報を得る術を知らずに何年も費やしても、まともな知識は得られないってことだね。</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/05/22/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84</id><title type="text">関係と代数的データ型との相互変換についての妄想 その3</title><updated>2017-05-22T10:11:04+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/05/22/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84"/><summary type="html">思い付き その2 class QueryUser ? where queryUser :: (?) =&gt; Key -&gt; MonadDB User instance QueryUser ? where -- queryUser :: (HasFriends ?) =&gt; Key -&gt; MonadDB User query = … instance QueryUser ? where -- queryUser :: (HasName ?) =&gt; Key -&gt; MonadDB User query = … userFriends :: (HasFriends ?) =&gt; User -&gt; [User] …</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/05/21/120000</id><title type="text">Haskellで10を作るプログラムを書いてみたので動画で公開してみた</title><updated>2017-05-21T23:25:27+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/05/21/120000"/><summary type="html">最近Rui Ueyamaさんがコーディング動画をアップされているのを見て、私も動画を撮りたくなりました。題材をしばらく考えていたんですが、10を作るプログラムを書いてみることにしました。 www.youtube.com 後から見直すと色々ミスっていて、わりと焦っていることがわかります。なにかの癖で適当に bc -l とかやったのだけど、音声をあてる時は関係ないオプションだと勘違いしてしまいました。確かにglobされていたのはよくなかったけど、 echo '5 / (5 / (5 + 5))' | bc -l とかで考えてみると -l も必要なんですよね。2つの問題が起きていて混乱してしまった……</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/05/21/150903</id><title type="text">JJUG CCC 2017 Spring で Haskell on JVM について話してきました</title><updated>2017-05-21T15:14:00+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/05/21/150903"/><summary type="html">先日行われた JJUG CCC 2017 Spring で、JVM 上で動作する Haskell について発表してきました。 思ったほど怖くない！ Haskell on JVM 超入門 #jjug_ccc #ccc_l8 from y_taka_23 www.slideshare.net メインになるコンテンツはふたつの JVM 言語、Frege と Eta です。 今回はあくまでも Java のイベントなので、発表前半では Haskell の基本概念、特にモナドについてそれなりの時間を割いて説明してみました。さらにそれを踏まえて後半ではモナドを利用した Java ライブラリの呼び出しに焦点を…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/05/21/120211</id><title type="text">VMWareのインストール</title><updated>2017-05-21T12:02:11+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/05/21/120211"/><summary type="html">最近ずっとVirtualBoxを使っていたのだけど、3Dアクセラレーションを有効にするとOpenGLがまともに動かなかったので、代わりとして久々にVMWareを入れてみた。 Ubuntu 17.04 を入れたんだけど、 Install VMWare tools が動かなかったので、 /media/ユーザ名/VMWare\ Tools 以下のファイルを /tmp へ展開し、手で ./vmware-install.pl を叩いて入れた。途中 ifconfig がなくて怒られたので、 sudo apt-get update sudo apt install net-tools した上で /sbin/…</summary></entry><entry><id>http://hiratara.hatenadiary.jp/entry/2017/05/16/082326</id><title type="text">monadiusを動かす</title><updated>2017-05-18T08:27:41+09:00</updated><author><name>hiratara</name></author><link href="http://hiratara.hatenadiary.jp/entry/2017/05/16/082326"/><summary type="html">12年前に書かれた http://www.geocities.jp/takascience/haskell/monadius_ja.html を手元で動かした。と言っても、ほぼ手を加えずにそのまま動いた。 $ diff -ur monadius.BK/ monadius diff -ur monadius.BK/src/Main.hs monadius/src/Main.hs --- monadius.BK/src/Main.hs 2017-05-16 08:02:04.566956400 +0900 +++ monadius/src/Main.hs 2017-05-16 08:08:18.5…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/05/17/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84</id><title type="text">関係と代数的データ型との相互変換についての妄想 その2</title><updated>2017-05-17T15:13:55+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/05/17/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84"/><summary type="html">思い付き その1 型レベルのリストをクエリー函数に与えてやる。（DataKinds が有効） data Attr = Id | Name | Friends data User = User { id :: Int, name :: String, friends :: [User] } query :: Proxy '[??] -&gt; Key -&gt; MonadDB User userFriends :: Proxy '[Friends] -&gt; User -&gt; [User] リストだとダメだなーって気付いた。勝手に型の和が取られるわけじゃないからね。 それはそれとして、分からないところが2点。 …</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/05/16/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84</id><title type="text">関係と代数的データ型との相互変換についての妄想 その1</title><updated>2017-05-16T10:53:24+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/05/16/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84"/><summary type="html">OR マッパーみたいな、関係*1とデータ型との相互変換が機械的にできたら嬉しいなという話。 シンプルなのは簡単だしすでにできる。例えば次のような関係がある場合*2、 var user base relation { id integer, name string, } key { id }; var friends base relation { user1 integer, user2 integer }; これを単に次のようなデータ型に変換するのはいくらかのライブラリーで実現できる。 data User = User { id: Int, name: String } data Frien…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/05/07/100000</id><title type="text">gitのファイル変更日時をファイルのアクセス日時に設定</title><updated>2017-05-07T10:00:11+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/05/07/100000"/><summary type="html">普段使っているファイラーはファイルのアクセス日時でソートされるように設定しています。大きめのリポジトリをcloneしてコードを読む時に、意外とファイルの最終変更日時が参考になったりします。仕事で使うリポジトリや、定期的にpullしているなら、徐々に変更のないファイルはファイラーの下の方に移動していく (上の方からアクセス日時の降順として) のですが、cloneしたばかりだとこうは行きません。 要はgitリポジトリ内の各ファイルのアクセス日時を、そのファイルのgit履歴上での最終変更日時に戻したいという気持ちになるわけです。そうするとファイラー上でもいい感じにファイルがソートされるのです。 #!…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/05/06/060400</id><title type="text">超技術書典で同人誌『入門 LiquidHaskell』を頒布できませんでした</title><updated>2017-05-06T06:04:00+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/05/06/060400"/><summary type="html">先日、ニコニコ超会議内で行われた「超技術書典」にて、LiquidHaskell の同人誌でサークル参加してきました。 lh101.dodgsonlabs.com 技術書典 2 ではそこそこの部数が出た ので Haskell 同人誌の需要はゼロではないと踏んでいたのですが、びっくりするぐらい売れません でした。とりあえず後に続く人が同じ轍を踏まないように、今回の様子について記録しておきます。 頒布物 頒布した同人誌は以下の 2 種類です。前者は技術書典 2 で頒布したものの増刷、後者は id:kazeula さんから委託を受けた新刊です。 入門 LiquidHaskell −篩型による静的コード…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/02/28/Yesod_%E3%81%A8_HDBC-mysql_%E3%81%A8_haskell-relational-record_%E3%81%A7_%E2%80%9CCommands_out_of_sync%E2%80%9D</id><title type="text">Yesod と HDBC-mysql と haskell-relational-record で “Commands out of sync”</title><updated>2017-04-27T10:05:11+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/02/28/Yesod_%E3%81%A8_HDBC-mysql_%E3%81%A8_haskell-relational-record_%E3%81%A7_%E2%80%9CCommands_out_of_sync%E2%80%9D"/><summary type="html">Yesod と HDBC-mysql と haskell-relational-record を一緒に使っているのだが、MySQL サーバーに「Commands out of sync; you can’t run this command now」って言われてぐぬぬってなって、最近デバッグをがんばっている。とりあえず途中経過をメモしておく。 そもそも MySQL プロトコルの呼び出し順とか知らないので苦戦していた。 この辺でエラーが出ている。結合をしなければエラーは出ない。 import Import hiding (on) import Database.Relational.Query …</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/04/11/044041</id><title type="text">技術書典 2 で同人誌『入門 LiquidHaskell』を頒布しました</title><updated>2017-04-11T04:40:41+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/04/11/044041"/><summary type="html">先日、秋葉原で行われた技術書のオンリーイベント「技術書典 2」にて、LiquidHaskell の同人誌を頒布してきました。 lh101.dodgsonlabs.com LiquidHaskell は、SMT ソルバをバックエンドとして利用することで、Haskell の持つ型の表現力をより強化する仕組みです。通常の Haskell では型情報としてエンコードできない値レベルの制約を記述できるため、例えば「0 でない Int 型」を定義すればゼロ除算をコンパイル時に検知できます。以前の記事 にちょっとした解説があります。 当日は冊子版を 30 冊と PDF 版ダウンロードカードを 50 シリアル…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/03/30/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B82%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%99</id><title type="text">技術書典2にサークル参加します 「Haskell Yesod 本」</title><updated>2017-04-06T19:35:40+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/03/30/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B82%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%99"/><summary type="html">4月9日日曜日にアキバ・スクエアにて開催される技術書オンリー同人誌即売会「技術書典2」にサークル「趣味はデバッグ……」として参加します。 冬コミで頒布した『遠回りして学ぶ Yesod 入門』の誤字脱字等を修正して組版を改善したものを持っていきます。 新作はちょっと間に合うか…… 内容 内容は、下記となります。 ビルドツール Stack 効率のよい文字列の扱い Haskell の言語拡張 コンパイル時計算 Template Haskell Web Application Interface とは 簡単な Yesod の解説 ロガー用 Middleware を作る 詳しい内容は見本誌で確認ください…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/12/24/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%8891_%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F</id><title type="text">コミックマーケット91 『遠回りして学ぶ Yesod 入門』</title><updated>2017-03-30T10:45:09+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/12/24/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%8891_%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F"/><summary type="html">サークル「趣味はデバッグ……」の2冊目の頒布をコミックマーケット91にて行います！ 『遠回りして学ぶ Yesod 入門』 前回、技術書典で頒布した『遠回りして学ぶ Yesod 入門（上）』の増補改訂版という形になります。 対象読者 対象読者は前回通り、下記ような方になります。 Haskell の入門書は読み終わったよ Yesod のサンプルコード見たら知らない文法とかあって読めないよ 内容 内容は、下記となります。 ビルドツール Stack 効率のよい文字列の扱い Haskell の言語拡張 コンパイル時計算 Template Haskell Web Application Interface…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/03/28/Yesod_%E3%81%A71%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E8%A4%87%E6%95%B0%E5%80%8B%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AF_identifyForm_%E3%82%92%E4%BD%BF</id><title type="text">Yesod で1ページに複数個フォームがある場合は identifyForm を使う</title><updated>2017-03-28T10:49:23+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/03/28/Yesod_%E3%81%A71%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E8%A4%87%E6%95%B0%E5%80%8B%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AF_identifyForm_%E3%82%92%E4%BD%BF"/><summary type="html">resolver lts-5.4 で確認。 問題 1ページに複数個フォームがある場合、runFormPost はそれぞれのフォームの区別をしてくれません。どういうことかというと、例えば下記のような2つのフォームを利用するとします。 data AFormData = AFormData Text aForm :: Html -&gt; MForm Handler (FormResult AFormData, Widget) aForm = renderDivs $ AFormData &lt;$&gt; areq textField "A Text" Nothing data BFormData = BFormD…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/03/11/232319</id><title type="text">generateの罠</title><updated>2017-03-11T23:24:28+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/03/11/232319"/><summary type="html">vectorパッケージのData.Vectorにはgenerateという関数がある。 generate :: Int -&gt; (Int -&gt; a) -&gt; Vector a 型から全てを知ることはできないが、だいたい想像通りgenerate n fは[f 0, f 1, f 2, ...f (n - 1)]からなるVectorを生成する。しかし、これは要素を評価はしない。生成されるのはあくまでサンクのVectorだ。 Prelude &gt; import Data.Vector as V Prelude V&gt; V.length $ V.generate 5 (const undefined) 5 ve…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/02/12/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E8%AA%A4%E5%AD%97%E8%84%B1%E5%AD%97%E7%AD%89%E3%82%92%E4%BF%AE%E6%AD%A3%E3%81%97%E3%81%9F</id><title type="text">『遠回りして学ぶ Yesod 入門』誤字脱字等を修正した電子版を公開しました</title><updated>2017-02-12T01:49:25+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/02/12/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E8%AA%A4%E5%AD%97%E8%84%B1%E5%AD%97%E7%AD%89%E3%82%92%E4%BF%AE%E6%AD%A3%E3%81%97%E3%81%9F"/><summary type="html">先日の投稿で公開した正誤表の内容を反映した電子版を公開しました。 kakkun61.hatenablog.com コミックマーケット 91 で購入した方は対面電書で、オンラインで購入した方は BOOTH で更新後のファイルを入手することができます。</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/12/31/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%88_91_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A</id><title type="text">コミックマーケット 91 ふりかえり</title><updated>2017-02-11T02:26:37+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/12/31/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%88_91_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A"/><summary type="html">コミックマーケットお疲れさまでしたー。 Yesod 本 紙面版 完売！後は電子版のみ。電子版はいっぱいあります！ #C91 #Haskell #Yesod— kakkun61@技術書典2 う-04 (@kakkun61) 2016年12月29日 印刷分完売しました。ありがとうございますー。技術書典のときよりも早く売り切れたのはまさかという感じでした。技術書典が特別技術系が売れるのかと思っていたんですが、そうでもないんですね。もっと刷ればよかった。 スケジュール 8月 冬コミの申込セット、明日24時オンライン申込締切で、宅配が明日21時になったマン 不安しかない— kakkun61@技術書典2 …</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2017/01/23/100000</id><title type="text">二週間で簡単なインタープリタ言語を実装してみた (日記)</title><updated>2017-01-26T15:49:35+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2017/01/23/100000"/><summary type="html">私は昔から言語処理系に興味があり、自分で言語を作ることを夢見てきました。 しかし、いざ言語を実装しようと思って言語処理系に関する本を読んでも何から手を付けていいか分からず、アセンブラもまともに読めないまま、数年が経ってしまいました。 大学時代は情報系ではなかったため、コンパイラの実験がある情報系の学科のカリキュラムを羨ましく思い、情報系の授業の教科書を手にとって見ても読む気が起きず、自分に作れるのは所詮、構文木をちょこっといじって変換するレベルのもの (例えばsjspなど) にとどまっていました。 そんな中、去年のRebuild.fmで、とても感銘を受けた回がありました。 LLVMのlinke…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/12/31/Adobe_Typekit_%E3%81%AE%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%A0%B4%E6%89%80%EF%BC%88Windows%EF%BC%89</id><title type="text">Adobe Typekit のフォントファイルの場所（Windows）</title><updated>2016-12-31T18:00:02+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/12/31/Adobe_Typekit_%E3%81%AE%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%A0%B4%E6%89%80%EF%BC%88Windows%EF%BC%89"/><summary type="html">アプリがフォントをうまく認識しない場合にフォントファイルを直接インストールして対処したりできる。同一マシンならライセンス的にも大丈夫なはず。保証はしません。 環境 Adobe Photoshop CC 2017 Windows 10 場所 %appdata%\Adobe\Adobe Photoshop CC 2017\CT Font Cache にメタファイルがある。↓ のような項目が並んでいる。 %BeginFont Handler:DirectoryHandler FontType:Type1 FontName:AdobeDevanagari-Bold FamilyName:Adobe D…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/27/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8F%E3%81%AE%E9%9B%BB%E5%AD%90%E7%89%88%EF%BC%88PDF%EF%BC%89%E3%81%AE</id><title type="text">『遠回りして学ぶ Yesod 入門（上）』の電子版（PDF）のインターネット販売を開始しました</title><updated>2016-12-27T23:42:20+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/27/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8F%E3%81%AE%E9%9B%BB%E5%AD%90%E7%89%88%EF%BC%88PDF%EF%BC%89%E3%81%AE"/><summary type="html">BOOTH にて『遠回りして学ぶ Yesod 入門（上）』の電子版（PDF）のインターネット販売を開始しました！ 1000円となります。 kakkun61.booth.pm 結構さっくり開設できてびっくりしてる。 店舗候補 どこでダウンロード販売すべきなんかなと思ってちょっと調べたんでまとめときます。 候補としては、メロンブックス・BOOTH・DLsite がありました。それぞれの店舗での販売価格に対する受取価格はざっくり次の通りでした。 店舗 受取価格 メロンブックス*1 販売価格 × 0.7 -（振込手数料） BOOTH*2 販売価格 × 0.966 - 10 -（振込手数料 300 or…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/12/24/193038</id><title type="text">LiquidHaskell コトハジメ</title><updated>2016-12-25T15:06:06+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/12/24/193038"/><summary type="html">このエントリは Haskell Advent Calendar 2016 および Formal Method Advent Calendar 2016 の 23 日目の投稿です。のはずでしたがすでに日付が変わりました。謹んでお詫び申し上げます。 ちなみに 22 日目の担当者はそれぞれ Haskell Advent Calendar 2016 : heredocsの紹介 - Qiita Formal Method Advent Calendar 2016 : 農夫 山羊 キャベツ 狼 - Qiita です。偶然ですが同じ方が執筆担当ですね。 さて、本エントリでは Haskell の型の表現力をよ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/12/19/060147</id><title type="text">NGK2016B で Kubernetes + Alloy について話してきました</title><updated>2016-12-19T06:01:47+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/12/19/060147"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2016B / 名古屋合同懇親会 2016 忘年会 で発表してきました。 机上の Kubernetes - 形式手法で見るコンテナオーケストレーション #NGK2016B from y_taka_23 www.slideshare.net 当日の動画は NGK 2016B LT #2 - YouTube から見ることができます。 ちなみに NGK での発表は 4 年連続 4 回目です。今回も含めてすべてモデル検査が題材になっています。 NGK2013B : Alloy ではじめる簡単モデル検査 NGK2014B : 猫でもわかる！ モデル検査器 SPI…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/12/18/181540</id><title type="text">波打たせるものの正体(エクステンシブル・タングル)</title><updated>2016-12-18T18:15:40+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/12/18/181540"/><summary type="html">Haskell Advent Calendar 11日目 リアルワールドなHaskellerは、幾十ものフィールドを持つ大きなレコードをしばしば扱う羽目になる。モナディックにレコードを構築したい場合、RecordWildCards拡張を用いて以下のようにするのが定番だ。 import System.Random data Rec = Rec { foo :: String, bar :: Int, baz :: Double, qux :: Bool } makeRec = do foo &lt;- getLine bar &lt;- length &lt;$&gt; getLine baz &lt;- readLn qu…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html</id><title type="text">[haskell][yesod] TypedContentを利用してクライアントが要求するフォーマットでレスポンスを返す</title><updated>2016-12-17T15:16:26.835+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html"/><summary type="text">Yesod Advent Calendar 2016の6日目の記事です。

RESTfulなAPIを提供する場合、クライアントの都合にあわせて、フォーマットを変えてレスポンスを返したいケースがあります。サーバー上で管理しているDBから、表現だけをHTML, JSON, XML, CSVなどに変更して返すイメージです。例えば、人物情報（名前、年齢、性別など）の一覧を返す際には以下のようなデータが返されることになります。

HTML
&lt;table border&gt;
  &lt;tr&gt;
    &lt;th&gt;name&lt;/th&gt;    &lt;th&gt;sex&lt;/th&gt;    &lt;th&gt;age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Taro Yamada&lt;/td&gt;    &lt;td&gt;Male&lt;/td&gt;    &lt;td&gt;18&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Hanako Yamada&lt;/</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/12/11/%E5%B0%91%E5%A5%B3%E3%82%BB%E3%82%AF%E3%83%88</id><title type="text">少女セクト</title><updated>2016-12-11T00:01:06+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/12/11/%E5%B0%91%E5%A5%B3%E3%82%BB%E3%82%AF%E3%83%88"/><summary type="html">この記事は Krile Advent Calendar 11日目の記事です。 Krile いいですね。Wassr 民だったので Krile 2 のころから使ってました。 さて本題。 少女セクト 少女セクト (メガストアコミックス)作者: 玄鉄絢出版社/メーカー: コアマガジン発売日: 2005/08/19メディア: コミック購入: 24人 クリック: 440回この商品を含むブログ (177件) を見る なぜこれを買ったのかは正確には覚えてないのですが（おそらくなんらかの書評を読んだのだと思う）いわゆる「控えめに言って最高」というやつですね。 8日目の『星川銀座四丁目』と同じ作者の玄鉄絢さんです…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/12/04/120000</id><title type="text">珍しいSHA1ハッシュを追い求めて</title><updated>2016-12-07T19:11:02+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/12/04/120000"/><summary type="html">「SHA1ハッシュってあるだろう？」 放課後、いつものように情報処理室に行くと、高山先輩が嬉しそうな顔でそう言った。 「ええ、SHA1、ありますね」 「SHA1って何桁か覚えているかい？」 「えっと…」 一年下の後輩、岡村が口を開いた。 「50桁くらいはありましたっけ…？」 先輩はパソコンに向かって何かを打ちはじめた。 現在、情報部の部員は三人しかいない。部長の高山先輩と、二年の自分と、後輩の岡村だ。いや、正確に言うと、先輩の学年にはもう少しいたのだが、もうほとんど部室に来ることはなくなってしまった。無理もない、この季節になると先輩たちは受験勉強で忙しくなる。 「例えば、こういうふうに… 適当…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html</id><title type="text">[haskell][yesod] stackのnewコマンドで指定できるyesod関連templateの説明</title><updated>2016-12-03T23:37:28.283+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html"/><summary type="text">現状、stackで指定できるyesod関連のtemplatesには以下のものがあります。どのtemplateに何が用意されているのか、知りたかったのですがどこにも説明されていないようなので、調べてまとめてみました。
% stack templates | grep yesod
yesod-hello-world （←現時点では削除されています）
yesod-minimal
yesod-mongo
yesod-mysql
yesod-postgres
yesod-postgres-fay
yesod-simple
yesod-sqlite


以下、各テンプレートの説明です。後に出てくるテンプレートほど内容が複雑になっています。テンプレートを指定して新しいプロジェクトを生成する場合は以下のコマンドを実行します。
% stack new プロジェクト名 yesod-???




</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html</id><title type="text">[emacs] emacs上のgrep関連機能、複数ファイルの一括置換手順のまとめ</title><updated>2016-11-30T10:03:25.873+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html"/><summary type="text">emacs上でgrep関連の機能を利用する際のTIPSをまとめておきます（よく忘れて調べ直すので…）。


grepコマンドのオプション

指定ディレクトリ以下のファイルを再帰的に検索

-R DIR    シンボリックリンクを辿る
-r  DIR    シンボリックリンクは辿らない

検索対象をファイル名でフィルタする

--include=GLOB    GLOBにファイル名を指定する。"*.cpp"のようにワイルドカード（*,?,[...]）を指定可能

検索対象から指定ファイル・ディレクトリを除外する

--exclude=GLOB   GLOBに除外するファイルのファイル名を指定する（ワイルドカード指定可能）。
--exclude-dir=DIR DIRに指定されたディレクトリをスキップ


使用例：

docディレクトリ以下の.txtを拡張子に持つ全てのファイルを対象に"</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html</id><title type="text">[cygwin] cygwin64セットアップメモ</title><updated>2016-11-28T00:47:36.358+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html"/><summary type="text">自分向け備忘録。cygwin64環境をセットアップする際の手順をまとめておきます。


設定


ssh-agent関連

ssh-agentの重複起動を防ぐ
ssh-agentのために秘密鍵セットアップ

~/.ssh/

※group/otherのrw権限は削除


ssh-agentがパスワードを覚えてくれなくなった問題への対処

pingのエラー回避
ユーザーのアカウント名、ホームディレクトリの変更

/etc/passwdを編集する

GNU screen でlessやvimの終了後に画面クリアをしない方法
改行コードにCR+LFが用いられているbashスクリプトを実行するための設定
tcshのデフォルト補完設定のイマイチな部分を修正




環境変数

HOME

ホームディレクトリを設定



SHELL

"/bin/tcsh"とすることでデフォルトのシェルが切り替わる
</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/11/20/163839</id><title type="text">Frege のチュートリアル集「Frege Goodness」を翻訳しました</title><updated>2016-11-20T16:38:39+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/11/20/163839"/><summary type="html">Frege のチュートリアル集を日本語に翻訳しました。原著は Dierk Koenig 氏による Frege Goodness · GitBook です。 www.gitbook.com 対象読者 まえがきでも述べられている通り、Frege の (すなわち Haskell の) 基本的な文法については既知のものとして扱われます。より具体的には「すごい Haskell」の前半部分を読んだ、ぐらいでしょうか。例えば型クラス自体は知っている必要がありますが、モナドに対する理解は要求しません。 ちなみに、目を通していただけるとすぐにわかりますが、実は Frege に特有な内容はさほど登場しません。どち…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/11/10/200000</id><title type="text">git grepで仕事してる</title><updated>2016-11-10T20:43:06+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/11/10/200000"/><summary type="html">私はコードを書く時に頻繁にgit grepを使っていて、一日に何回くらいgit grepを使っているのか気になったのでログを取ってみました。 2016 10/24 月: 61 2016 10/25 火: 36 2016 10/26 水: 19 2016 10/27 木: 80 2016 10/28 金: 51 2016 10/31 月: 96 2016 11/ 1 火: 47 2016 11/ 2 水: 53 2016 11/ 4 金: 84 2016 11/ 7 月: 56 2016 11/ 8 火: 33 2016 11/ 9 水: 19 2016 11/10 木: 71 これは私が会社の…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/10/31/025512</id><title type="text">HaskellのロガーKatipを試す</title><updated>2016-10-31T02:55:12+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/10/31/025512"/><summary type="html">モチベ Haskell の実行時ログ出力を行うライブラリは monad-logger が一番有名っぽい。 これは Yesod 陣営が開発しているから安心感があるし、バックエンドが fast-logger なので速度も信頼できる。 ただ (自分の調べ方が悪いのかもしれないが) ちょっと自分の用途には機能が足りなかった。 具体的には以下の機能: ログにタイムスタンプを付記したい。 ロガーに名前をつけたい。 ファイルサイズか日付でログローテーションしたい。 Katip という別のロガーライブラリは機能が豊富のようなので今回はそれを試してみる。 (この記事のHaskell環境: lts-6.23) K…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/10/30/155758</id><title type="text">Frege からメールが送信できるようになりました</title><updated>2016-10-30T17:31:40+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/10/30/155758"/><summary type="html">ちょっとした Web アプリを作成しようと思うと、メール送信機能がないと困ります。例えば、ログイン機能を持っていれば必然的にパスワードリセットとかも必要になりますからね。 Haskell 風の JVM 言語 Frege でもフレームワーク Chinook を使用して Web アプリが作れますが、メールを送信するライブラリが見当たらなかったので自作しました。 github.com なお、すでに Bintray に公開済みなので、各種ビルドツール経由で呼び出すことができます。現状、Frege のビルドは Gradle がデファクトスタンダードなので、以下でも Gradle で説明しましょう。 bi…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/10/23/201420</id><title type="text">JAWS FESTA 東海道 2016 で形式手法によるネットワーク設計について話してきました</title><updated>2016-10-23T20:14:20+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/10/23/201420"/><summary type="html">先日行われた JAWS FESTA 東海道 2016 で登壇してきました。 形式手法と AWS のおいしい関係。- モデル検査器 Alloy によるインフラ設計技法 #jawsfesta from y_taka_23 www.slideshare.net テーマは以前 AWS Summit で発表したものと同じですが、前回が 5 分の LT だったのに比べて今回は 25 分の枠を頂きました。そこで、形式手法を用いる動機を中心に据えた前回と比較して、以下のような実践的なトピックを充実させてあります。 Alloy を使うためにの最低限必要な言語機能を知る シンプルな Web サーバ周りのネットワー…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/10/08/220000</id><title type="text">スマホが割れた日</title><updated>2016-10-12T10:16:41+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/10/08/220000"/><summary type="html">その瞬間は、前触れもなくやってきた。 いつものように、仕事帰りに烏丸御池の交差点で信号待ちをしていた。ちょうど赤に変わったタイミングで時間があったので、スマホでニュースを眺めていた。信号が切り替わり、そろそろ渡ろうとしてスマホをポケットにしまおうとした瞬間だった。左手と右手がいきなりぶつかり、右手の力が緩み、スマホは宙に舞った。 何が起きたのか自分でもわからなかった。はっと我に返ったら、スマホは硬いコンクリートに打ち付けられていた。 一体左手で何をしようとしたのだろうか、今となってはもう思い出せない。右手に痒みを感じて掻こうとしたのか、スマホを左手に持ち替えようとしたのか、あるいはゴミが入った…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/10/10/000011</id><title type="text">割とすぐに始められるextensibleチュートリアル(レコード編)</title><updated>2016-10-10T00:50:06+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/10/10/000011"/><summary type="html">ごきげんよう諸君。今回はextensibleについて説明しよう。 extensibleはその名の通り、拡張可能なデータ構造を提供するライブラリである。具体的には、型レベルのリストによって特徴づけられる積と和を提供する。非常に残念なことに、GHC 8.0.1ではコンパイラのバグのせいでそもそもライブラリがビルドできない*1。来たる8.0.2では修正されているので、それを待つほかない。 とにかく、ここでは積の応用技である拡張可能レコードについて紹介する。使い方は簡単だ。まず使いたいフィールド名をスペースで区切ってmkFieldに渡す。 {-# LANGUAGE TemplateHaskell, D…</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/09/13/000000</id><title type="text">Vim 8.0 リリース！</title><updated>2016-09-30T16:16:02+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/09/13/000000"/><summary type="html">Vim 8.0 released! Vim 8.0が先ほどリリースされました。10年ぶりのVimのメジャーバージョンアップです。 Vimのバージョンをcronで毎日上げ続け、最新のパッチを確認し続ける日々を送ってきました。そして、今日も夜11時のcronでバージョンが上がりました。新しいメジャーバージョン、8.0でした。 ここ一年はVimにとって様々な重要な機能が入りました。JSONエンコーダーとパーサー、パッケージ機構、channelとjob、タイマー、ラムダ式など、プラグイン製作者にとって大事な機能ばかりです。今後、より高度なプラグインがでてくることでしょう。これらの機能に対する日本人の貢…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/13/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%81%AB%E3%81%A6%E4%BA%BA%E7%94%9F%E5%88%9D%E3%81%AE%E5%90%8C%E4%BA%BA%E8%AA%8C%E3%82%92%E9%A0%92%E5%B8%83%E3%81%97%E3%81%BE%E3%81%99%EF%BC%81</id><title type="text">技術書典にて人生初の同人誌を頒布します！</title><updated>2016-09-30T12:11:59+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/13/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%81%AB%E3%81%A6%E4%BA%BA%E7%94%9F%E5%88%9D%E3%81%AE%E5%90%8C%E4%BA%BA%E8%AA%8C%E3%82%92%E9%A0%92%E5%B8%83%E3%81%97%E3%81%BE%E3%81%99%EF%BC%81"/><summary type="html">技術書典にて人生初の同人誌を頒布します！うおぉぉ！！ドコドコドコ！プワプワー！ 『遠回りして学ぶ Yesod 入門（上）』 内容は、入門書程度の内容の Haskell を理解した人がウェブアプリケーションフレームワーク Yesod を使うときに手助けになるような内容です。具体的には次の通り。 ビルドツール Stack 効率のよい文字列の扱い Web Application Interface とは Scotty を使ったウェブアプリ ただ書いてたら最後まで間に合わない気がしてきたので今回は「上巻」ってことで逃げました！これから下巻書かなきゃ。 ペンタブレットを買って表紙も自分で書きました！絵が…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A</id><title type="text">技術書典 ふりかえり</title><updated>2016-09-11T19:14:03+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A"/><summary type="html">技術書典お疲れさまでしたー。 閉場30分前まで整理券制で、だいたいの方が1時間半待ちだったそうですね。びっくりするような盛況で何よりです。運営さんの手際もよく大変ありがとうございました。 #技術書典 会場のキャパに余裕が出てきたため、只今から整理券なしでも入場可能にします！残り三十分強ですがお楽しみいただければと思います。— TechBooster@3日目西a05a (@TechBooster) June 25, 2016 最終的に1200人は超えたそうですね。 #技術書典 最終集計できてないですが速報(すぐ数えられるもので)来場数は1200名を超えました！至らないところもありましたがサークル…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html</id><title type="text">[haskell][yesod] YesodにおけるRESTfulなJSON API実装チュートリアル</title><updated>2016-08-28T17:53:43.356+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html"/><summary type="text">HaskellのwebフレームワークであるYesodにおいて、RESTful APIを実装する手順を紹介します。Haskell上のデータ構造をJSONテキストに変換する、逆に、JSONテキストをパースしてHaskell上のデータ構造を生成する、といった処理が非常に簡単に実現できます。加えて、コードを書かなくてもバックエンドのDBとのORマッピングが可能になっており、効率的に開発することができます。
ここで紹介しているコードはgithubにコミットしています。


準備：

json-sampleというプロジェクト名でYesodのscaffolding siteをセットアップする

空のプロジェクト生成

% stack new json-sample yesod-sqlite --system-ghc

"--system-ghc"は省略可能。インストール済みのghcを使うことを指示し</summary></entry><entry><id>https://itchyny.hatenablog.com/entry/2016/08/01/100000</id><title type="text">Go言語でbase58コマンドを作りました</title><updated>2016-08-01T10:00:00+09:00</updated><author><name>itchyny</name></author><link href="https://itchyny.hatenablog.com/entry/2016/08/01/100000"/><summary type="html">Go言語でbase58コマンドを書きました。コマンドラインツールだけではなくて、Goのパッケージとして作っています。 github.com 仕事の関係でbase58を扱うことがあり、base64コマンドのように素早くコマンドラインで変換できるツールが欲しくなったので作りました。ご自由にお使い下さい。 コマンドラインツールは次のように使うことができます。 $ go get -u github.com/itchyny/base58-go/cmd/base58 $ base58 100000000 9QwvW 79228162514264337593543950336 5QchsBFApWPVxyp…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html</id><title type="text">[haskell][yesod] stack対応版Yesod tutorial</title><updated>2016-07-17T18:06:36.108+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html"/><summary type="text">HaskellのwebサービスフレームワークにYesodというフレームワークがあります。Yesodに触れたことのない開発者向けに書かれたチュートリアルの一つにYesod tutorialがあり、手順に沿っていくだけで簡単なwebサービスを動作させることができ、Yesodで何ができるかを簡単に理解できるようになっています。
ただ残念なことに、このYesod tutorialの記載は内容が古く、stackを利用した現行の手順とマッチしなくなっています。stackに対応している最新環境（Yesod 1.4.x）における順があると役に立つと思い、書き起こしてみました。


Before the real start（はじめに）

Install（インストール手順）
stackをインストールする。以下のサイトが参考になります。

installation instructions for </summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html</id><title type="text">[haskell][yesod] stack exec -- yesod devel で devel.hs: getAddrInfo: does not existというエラーになる問題の対処方法</title><updated>2016-07-17T17:39:43.279+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html"/><summary type="text">
Widnwos環境での現象：
windows上でyesodのscafolding siteをセットアップし、さあ起動！ブラウザから接続確認してOKとなるはずが、なぜか「The application isn't built」という表示が出てしまいました。



このときターミナルには以下のようなログが出力されていました。
% stack exec -- yesod devel
Yesod devel server. Type 'quit' to quit
Application can be accessed at:

http://localhost:3000
https://localhost:3443
If you wish to test https capabilities, you should set the following variable:
  export </summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%80%81%E5%BE%8C%E6%97%A5%E9%85%8D%E9%80%81%E3%81%A7%E8%B3%BC%E5%85%A5%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%A3%E3%81%9F%E3%81%91%E3%81%A9%E3%83%80</id><title type="text">技術書典、後日配送で購入してくださったけどダウンロードカードを受け取っていない方へ</title><updated>2016-06-26T18:56:10+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%80%81%E5%BE%8C%E6%97%A5%E9%85%8D%E9%80%81%E3%81%A7%E8%B3%BC%E5%85%A5%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%A3%E3%81%9F%E3%81%91%E3%81%A9%E3%83%80"/><summary type="html">お詫び お詫びです。技術書典で『遠回りして学ぶ Yesod 入門（上）』を後日配送で購入してくださった方のうち1名の方に PDF のダウンロードができる URI の書いたカードをお渡しするのを忘れてしまいました。 申込用紙の連絡先を記入していただいた部分は技術書典運営および印刷所に提出してしまったため、こちらから連絡することができません。 申し訳ありませんが、自分だという方は後日発送申込用紙の控えの「運営受注№」を明記して kazuki.okamoto@kakkun61.com までお願いします。 よろしくお願いします。</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/05/03/211430</id><title type="text">写真の撮り方</title><updated>2016-06-14T23:59:05+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/05/03/211430"/><summary type="html">物体の発する光や反射した光を結像し、何らかの媒体に記録したものを写真と呼ぶ。カメラと呼ばれる道具には「撮影」という動作が必ず定義されており、撮影によって内部状態に画像を記録できる。内部状態を取り出して処理する(現像)ことで写真が得られる。大抵のカメラには以下のようなパラメータがあり、それらを最適化するのが撮影者の仕事になる。 焦点(Focus) はっきりとした像を得るには、光学系の焦点をそれに合わせる必要がある。最近のカメラは対象物の距離を測定し、自動で焦点を合わせる(オートフォーカス)機能を持っているものもある。 焦点距離(Focal length) 焦点距離が長いほど像は拡大されて見えるよ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/06/06/051120</id><title type="text">AWS Summit Tokyo 2016 で形式手法について話してきました</title><updated>2016-06-06T05:11:20+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/06/06/051120"/><summary type="html">先日行われた AWS Summit Tokyo 2016 で、形式手法のインフラ設計への応用について発表してきました。 形式手法で捗る！インフラ構成の設計と検証 from y_taka_23 www.slideshare.net モデル検査器 Alloy を利用して AWS の設定を検査する、という内容の LT で、昨年 12 月の NGK2015B でも同じテーマについて話しています。よければ以下の記事も合わせてお読みください。 ccvanishing.hateblo.jp NGK2015B の発表ではサンプルコードの紹介に比較的時間を割いているのに対して、今回の発表では「動機」の部分により…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/04/17/201842</id><title type="text">NL 名古屋で Frege の評価戦略について話してきました</title><updated>2016-04-17T20:18:42+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/04/17/201842"/><summary type="html">先日の 歌舞伎座.tech に引き続き、NL名古屋 - connpass で Haskell 風 JVM 言語 Frege について発表してきました。 今回の発表では、Frege の持つ Haskell 的特徴である非正格評価に焦点を当て、正格評価を行うはずの Java 上でなぜ評価を遅延させられるのか、その内幕を解説しています。 Frege, What a Non-strict Language from y_taka_23 www.slideshare.net なお当日の様子は NL名古屋 -NLとはなんだったのか- #nlnagoya - Togetterまとめ にまとめられています。長…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/04/08/215045</id><title type="text">今のところ比較的簡単なモナドの作り方</title><updated>2016-04-08T21:51:50+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/04/08/215045"/><summary type="html">準備 モナドを作るには、どんなモナドを作りたいか考える。モナドは一般に、どのようなアクションが使えるかによって特徴付けられる。その点ではオブジェクト指向におけるインターフェイスとよく似ている。 では、foo :: String -&gt; M Boolとbar :: M Intという二種類のアクションを持つモナドを作るとしよう。まず、どんなアクションが使えるかを表すデータ型を定義する。 {-# LANGUAGE GADTs #-} data MBase x where Foo :: String -&gt; MBase Bool Bar :: MBase Int GADT(一般化代数的データ型)の各データ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/03/22/020302</id><title type="text">歌舞伎座.tech #9 で Frege について話してきました</title><updated>2016-03-22T02:03:02+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/03/22/020302"/><summary type="html">先日行われた 歌舞伎座.tech#9「異種プログラミング言語格闘勉強会」 - connpass で Haskell 風 JVM 言語である Frege について発表してきました。 今回の勉強会のテーマは「様々な言語に触れて視野を広げる」ということだったので、細かな言語仕様にはあえて触れていません。Frege 自体の紹介と、あとは JVM 言語として一番キャッチーな機能である Java 呼び出しについて解説しました。 すごい Frege たのしく学ぼう！ from y_taka_23 www.slideshare.net 勉強会自体も、マイナ言語の話を一度にこれだけ聞けるというのは珍しくなかなか…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/02/29/191740</id><title type="text">GHC 8.0.1/base-4.9.0.0の新機能まとめ</title><updated>2016-02-29T19:17:40+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/02/29/191740"/><summary type="html">GHC 8.0.1は、最上位の桁が変わるだけあって、かなり新しい機能が追加されている。 base-4.9.0.0 めっちゃインスタンスが増えた ghc/changelog.md at ghc-8.0 · ghc/ghc · GitHubを参照。あるべきインスタンスが存在することにより、孤児インスタンスを定義する必要がなくなるため、ぐっとストレスが減る。Monoid a =&gt; Monad ((,) a)、Traversable ZipListなど、いくつかは私がやった。 Semigroup ついにData.Semigroupが追加された。将来的にはこれはモノイドのスーパークラスになる。この変更に…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/02/13/175220</id><title type="text">すごい JVM 言語 Frege をたのしく学ぼう！</title><updated>2016-02-13T17:52:20+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/02/13/175220"/><summary type="html">言わずと知れた Haskell の定番教科書『すごい Haskell たのしく学ぼう！』に登場するサンプルコードを、プログラミング言語 Frege に翻訳してみました。 github.com Frege について Frege は、JVM 上で動く純粋関数型プログラミング言語です。 github.com 最近、JVM 用 Lisp である Clojure の存在感を増してきている気がしますが、Frege はいわばその Haskell 版ですね。 文法的には Haskell + Java のメソッドを呼び出すための追加構文、といった感じ。細かな違いはありますが、Haskell が読める人間であれば…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html</id><title type="text">[haskell] cmdargsパッケージで楽々コマンドライン引数パース</title><updated>2016-02-11T01:10:46.307+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html"/><summary type="text">コマンドラインツール実装時、オプション指定とか引数の並びとか考え始めると大変です。HaskellではSystem.EnvironmentモジュールからgetArgsという関数が提供されていますが、本エントリで紹介するcmdargsパッケージを利用すると以下のようなことが簡単にできます。

cmdargsパッケージの特徴：

データ構造を定義するだけで起動引数・オプションのパースができる
パース結果を型付きで参照することができる
パース失敗時には、原因がわかるエラーメッセージが表示される
--help, --versionオプションで表示される情報を自動で生成してくれる

Haskell版GNU getoptライブラリと比べて以下の2点が優れている、とHPには書かれています。

HLintコマンドラインのハンドリングが1/3の短さ
Cabal, darcsなどのmultiple mode</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/02/04/214714</id><title type="text">比を最適化する</title><updated>2016-02-04T21:47:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/02/04/214714"/><summary type="html">二つの負でない実数、を考える。比をある値に近づけたいといった条件が複数あり、それらを最適化したいとき、どうするのがよいだろうか。 序: 近道の階段 簡単な方法の一つとして考えられるのは、単純に比の差をとり、それらの平方の和を最適化の対象とするというものだ。 しかし、これは最適化の結果、しばしば、のどちらかが0にぶつかってしまう。これは目的関数として非常にいびつであり、直感的とも言いがたい。 破: バリアフリー化 0や1に近い比率は極端であり、望まれていない。境界に近づくほど目的関数が無限大に発散するようにできないだろうか。 そんなときに使えるのがロジットだ。ロジットは0より大きい1未満の実数を…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージ利用時にテーブルにインデックスを生成する方法</title><updated>2016-01-30T17:12:12.076+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html"/><summary type="text">PersistentパッケージにはMigration機能が備わっており、自動的にテーブルを生成してくれます。スキーマ変更を行った際にも、変換が可能な限りテーブル内のレコードを保持したまま新しいスキーマに変換してくれます（Migration機能については過去のエントリでまとめています）。

自分が利用する上で、インデックスやトリガーを生成する手順が紹介されておらず困っていたのですが、rawExecuteという関数を用いることで自由にDDLを発行できることがわかりました。以下その手順とサンプルを紹介しておきます。


サンプルコード：
以下は、personテーブルのnameカラムにインデックスをs生成するサンプルです。runMigration実行直後に、runExecuteを実行することでインデックスを生成しています。このサンプルではインデックスを生成しているだけですが、同じ手順でトリガーの</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージのmigration機能のまとめ</title><updated>2016-01-30T17:11:40.032+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html"/><summary type="text">HaskellでDB操作ができるPersistentパッケージの紹介をしましたが、このエントリではPersistentパッケージが提供しているmigration機能をまとめておきます。
DBを作って運用していると、機能追加や仕様変更に伴いスキーマ変更が必要になるケースが多々あります。このようなケースにおいてPersistentのmigration機能がどれくらい使えるのかを調べた結果です。


基本：
Persistetのmigration機構は（保守的なルールに沿って）スキーマ変更をある程度まで自動で処理してくれます。
ロードしたDB内のテーブル情報と、コードで定義されたEntity Definition（テーブル定義）を比較し、以下のケースにおいてスキーマの変更を行います。

カラムの型を変更した場合：

ただし、値の変換ができない場合には、DBによって拒否されることになります。

</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html</id><title type="text">[haskell][gcc][win] Windows版Haskell Platform付属のgccでC++11のコードをコンパイルする方法</title><updated>2016-01-15T00:45:37.692+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html"/><summary type="text">Windows版のHaskell Platformにはmingwが同梱されておりgccが含まれています。現在自分のPCにはHaskell Platform 2014.2.0.0をインストールしているのですが、これに付属されているgccでC++11のコードをコンパイルしようとすると、以下のようなエラーになってしまいました。
% gcc -std=c++11 cpp11.cpp
cc1plus.exe: error: unrecognized command line option '-std=c++11'


-stdオプションで"c++11"を指定しても、認識してくれません。
本家のサイトによると、'-std=c++11'オプションはgcc 4.7でサポートされたようです。これに対し、Haskell Platform 2014.2.0.0に付属されているgccのバージョンを確認したところ</summary></entry><entry><id>https://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html</id><title type="text">[sqlite] SQLiteのロック・トランザクション関連仕様の整理</title><updated>2016-01-06T12:11:40.986+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html"/><summary type="text">SQLiteは共有ロック・排他ロックの仕組みを備えており、プロセス内の複数スレッド、だけでなく、プロセスをまたぐ状態でSQLが同時に発行されても適切に処理されます。
トランザクションに複数のモードが存在し、指定するモードに依って取得されるロックが変わります。さらにSQLの内容に依存してロック状態が遷移するため、複数プロセスがアクセスしたときの挙動を正確に把握できるよう、仕様を整理してみました。
（文中の「プロセス」は、正確には「プロセス、もしくはスレッド」を意味します。）


DBのロック状態の種類：

UNLOCKED

ロックされていない状態。誰も読み書きしていない。DBの初期状態。

SHARED

read可、write不可な状態。複数プロセスが同時にSHAREDロックを取得可能。複数プロセスが同時にreadできることを意味する。DBがこの状態にあるとき、他のプロセスからの</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/12/30/220159</id><title type="text">デシリアライザとスキーマ</title><updated>2015-12-30T22:16:49+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/12/30/220159"/><summary type="html">盛大に遅れました… qiita.com 最近思いついたネタで実用性の高そうなものを紹介。 binaryやcerealのようなライブラリはデータを密にシリアライズするが、その際にフィールド名や型などの情報は失われてしまう。かといってそれらを一つ一つすべて含めるとひどく効率の悪いフォーマットになってしまう。そこで、スキーマを分離できるような仕組みを作れないかと考えて作ったのがこのクラスだ。 {-# LANGUAGE TypeFamilies, ScopedTypeVariables, FlexibleContexts, UndecidableInstances #-} import Data.Bi…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html</id><title type="text">[cygwin][haskell][emacs] MinGWでcygwinの"/cygdrive"パスにアクセスする裏技（cygwin環境のemacsでflycheckを動作させる方法）</title><updated>2015-12-27T23:55:24.842+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html"/><summary type="text">haskell関連のコマンドはMinGW上でビルドされているため、cygwin環境の"/cygdrive"から始まるパスには対応していません。haskell-hlintから呼び出されるhlintも当然この問題の影響を受けておりemacs関連の設定が適切にされていたとしても、以下のようなエラーが表示されてしまいます。



ミニバッファに表示されるエラー詳細：
Suspicious state from syntax checker haskell-hlint: Checker haskell-hlint returned non-zero exit code 1, but no errors from output: hlint.exe: Couldn't find file: /cygdrive/c/Users/Hiroyuki/tmp/flycheck_hello.hs



</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/12/23/190729</id><title type="text">Alloy で自動定理証明っぽいやつ</title><updated>2015-12-23T19:42:18+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/12/23/190729"/><summary type="html">このエントリは Theorem Prover Advent Calendar 2015 - Qiita の 23 日目です。 とは言ってみたものの、内容はいわゆる定理証明器の話ではありません。モデル検査器 Alloy を利用して古典命題論理のシークエント計算をモデル化し、証明図を自動生成させることを目標にします。 なお、以下で部分的に引用しているモデル定義の完全版は alloy_sequent.als · GitHub にアップロードしてあります。 モデル化してみる 命題論理式の実装 まず対象となる論理式を Alloy で記述します。 abstract sig Formula {} sig A…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/12/13/193508</id><title type="text">NGK2015B で AWS + Alloy について話してきました</title><updated>2015-12-13T19:35:08+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/12/13/193508"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2015B / 名古屋合同懇親会 2015 忘年会 で発表してきました。 AWS は形式手法の夢を見るか？ - モデル検査器 Alloy によるインフラ設計 from y_taka_23 www.slideshare.net 当日の動画は [3] NGK2015B（名古屋合同懇親会 2015 忘年会） - YouTube から見ることができます。 TL;DR AWS でインフラ運用中 でも設定が大人の都合でカオスになりがちだったりして辛い よろしい、ならば形式手法だ サンプルコードを動かしてみよう！ まずはインストールしてみる 公式ページ Alloy …</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/12/10/200630</id><title type="text">正格フラグ、バンパターン、正格版関数・データ構造</title><updated>2015-12-10T20:06:30+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/12/10/200630"/><summary type="html">Haskellスペースリーク Advent Calendar 2015 9日目 Haskellerとて、時には厳しくならなければいけないこともある―― @fumieval, 2015 Haskellは遅延評価を基本としているため、場合によっては未評価の式が積もり非効率な状況に陥ることがある。これを防ぐため、部分的に正格評価にするための仕組みが用意されている。もちろんこれらは闇雲に使えばよいというものではない。使うべきポイントを把握し、これらを見逃さないようにしよう。 この記事では、それらの機能の正しい使い方、間違った使い方を紹介していこう。 カウンター・カウンターズ・サンクス 条件を満たす要素…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/07/26/NPM_%E3%81%A8_Bower_%E3%81%AB%E4%BE%9D%E5%AD%98%E3%82%92%E7%AE%A1%E7%90%86%E3%81%95%E3%81%9B%E3%82%8B%EF%BC%88PureScript_%E3%81%A7_Hello%2C_World%21%EF%BC%89</id><title type="text">NPM と Bower に依存を管理させる（PureScript で Hello, World!）</title><updated>2015-11-10T14:49:44+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/07/26/NPM_%E3%81%A8_Bower_%E3%81%AB%E4%BE%9D%E5%AD%98%E3%82%92%E7%AE%A1%E7%90%86%E3%81%95%E3%81%9B%E3%82%8B%EF%BC%88PureScript_%E3%81%A7_Hello%2C_World%21%EF%BC%89"/><summary type="html">前々回の記事「PureScript ver. 0.7.0 以上での Hello, World!」、前回の記事「PureScript ver. 0.7.0 以上で “ブラウザーで” Hello, World!」に次ぐ記事。 NPM の package.json とか Bower の bower.json とかに依存を書いてビルドを簡単にするのが今回の目的。 おさらいと前提 ファイル一覧。 &gt; dir /b src &gt; dir /b src index.html Main.purs ファイルの中身。src\index.html は下記。 &lt;html&gt;&lt;head&gt;&lt;script type="text…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/10/18/Gulp_%E3%81%A7%E3%83%93%E3%83%AB%E3%83%89%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92%E6%9B%B8%E3%81%8F%EF%BC%88PureScript_%E3%81%A7_Hello%2C_World%21%EF%BC%89</id><title type="text">Gulp でビルドスクリプトを書く（PureScript で Hello, World!）</title><updated>2015-11-10T14:49:26+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/10/18/Gulp_%E3%81%A7%E3%83%93%E3%83%AB%E3%83%89%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92%E6%9B%B8%E3%81%8F%EF%BC%88PureScript_%E3%81%A7_Hello%2C_World%21%EF%BC%89"/><summary type="html">第1話 PureScript ver. 0.7.0 以上での Hello, World! 第2話 PureScript ver. 0.7.0 以上で “ブラウザーで” Hello, World! 第3話 NPM と Bower に依存を管理させる（PureScript で Hello, World!） これらに続く第4話。前回では NPM の scripts を使ってコマンドを書いてビルドをしていたんだが、sh と cmd と2つ管理しないといけなかったり、ワンライナーなんで保守がしづらかったりと問題があるので、今回はビルドツールである Gulp を使って PureScript のコードをビル…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html</id><title type="text">[haskell][stack] stack exec ghciで”Couldn't match expected type"エラーが発生する問題の対処</title><updated>2015-11-08T15:09:21.187+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html"/><summary type="text">先日、haskellのパッケージ管理をcabalからstackに移行して「便利〜！」と感動していたところなのですが、stach exec ghciでソースをロードしようとすると"Couldn't match expected type: xxxxx"とエラーが発生する問題に遭遇しました。
ネットの情報を参考に解決することができたのでその手順をまとめておきます。


問題：
stack buildは成功するにもかかわらず、stack exec ghci xxx.hs（xxx.hsはbuild対象のファイル）がエラーになる。
stack exec ghci実行時のエラーログ：
% stack exec ghci FileToVec.hs
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
[1 of 1] </summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html</id><title type="text">[cygwin] cygwinのシェル起動時にPATHの先頭に/usr/binと/usr/local/binが勝手に追加されないようにする</title><updated>2015-11-04T22:29:43.126+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html"/><summary type="text">cygwinのデフォルトの設定では、シェル起動時に以下の2つのディレクトリが自動的にPATHの先頭に追加されます。

/usr/local/bin
/usr/bin


cygwinでインストールされているコマンドと同名の別コマンドを優先して起動したい場合には、この設定が邪魔になります。
これを無効にするには以下の方法があります。お好みでどちらかを選択してください。

/etc/profileもしくは/etc/csh.loginの該当処理をコメントアウトする（bash / tcsh）

cygwinがPATHを上書きしているのは、/etc/profile（bashの場合）と/etc/csh.login（tcshの場合）です。これらのスクリプトを編集することで、/usr/binと/usr/local/binが勝手に追加されないようにできます。

ORIGINAL_PATHでPATHを上書き</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/10/27/234832</id><title type="text">動物、とくにヒトと性について</title><updated>2015-10-27T23:52:44+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/10/27/234832"/><summary type="html">我々脊椎動物は有性生殖をする。したがって、繁殖に寄与する性質が必然的に残り、そうでないものは消えてゆく。オスは精子、メスは卵を作り出すという非対称性があり、体つきや行動もそれに合わせるように決まるのは自然だ。一夫多妻制の種においては、オスはメスを取り合うためにより強靭で攻撃的な性質が要求される。日本では法律上一夫一妻制を取るが、その影響は強く残っているだろう。実際、オスとして生を受けた私も、コミュニティの中でそれを体感している。 生まれつきの体質か、育った環境のせいかは知らないが、幼いころは体が弱かった(3才のころ、両足飛びができなかったそうだ)。そのため、幼いころの私の趣味は読書、ままごとや…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/10/26/PC_%E7%92%B0%E5%A2%83</id><title type="text">PC 環境</title><updated>2015-10-27T11:34:42+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/10/26/PC_%E7%92%B0%E5%A2%83"/><summary type="html">ディスプレー買い足そうかって思ったときに「端子空いてたっけ？そもそもグラボ何だっけ？」ってなったので書き残しておこうと思った。 CPU Intel Core i5 4440 ark.intel.com 3.1GHz 4コア 6MB キャッシュ マザーボード ASRock Fatal1ty H87 Performance www.asrock.com LGA 1150 PCIe PCIe 3.0 x16 1つ PCIe 2.0 x16 1つ PCIe 2.0 x1 2つ 映像出力 DVI-D 1つ D-Sub 1つ HDMI 1つ 映像入力（出力へのリダイレクト） HDMI 1つ Etherne…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/10/08/183215</id><title type="text">就職しました</title><updated>2015-10-08T18:32:15+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/10/08/183215"/><summary type="html">本日、Tsuru Capitalのポジションを得ました。 Tsuru Capitalはデリバティブの取引を行っている企業で、自動株取引の会社ではありません。取引に関わっている10人のメンバーのうち、創始者であるSimonを除く全員がHaskellerで、取引状況の分析や一部の取引の自動化など、あらゆるところにHaskellを使っているのが大きな特徴です。日本では数少ない、Haskellをメインに使っている企業の一つでもあります。 東京、シンガポール、バンクーバーにオフィスがあり、東京には私を含む5人の開発者と事務担当、Simonと愛犬テトがいます。 オフィスはオランダヒルズ森タワーRoPにあり…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/06/15/stack_%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F</id><title type="text">stack コマンドを使ってみた</title><updated>2015-10-06T02:27:04+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/06/15/stack_%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F"/><summary type="html">6月9日に FP Complete から stack コマンドがリリースされました（公式ブログ）。とりあえずブログ1文目を訳すとこんな感じです。 stack は新しく、完璧で、クロスプラットフォームで動作する開発ツールで、新参も古参も対象にしていて、コンパイラーをインストールしてセットアップして、必要なパッケージをインストールして、ビルドして、プロジェクト内の1つ以上のパッケージのテストをするもしくはベンチマークを取るためのものです。 stack is a new, complete, cross-platform development tool aimed at both new and …</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html</id><title type="text">[ssh] OpenSSHのアップデートでssh-agentがパスワードを覚えてくれなくなった問題への対処</title><updated>2015-09-06T00:44:24.703+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html"/><summary type="text">ssh-agent/ssh-addを利用してsshを用いたサーバーへのログイン時のパスワード入力を省略している方、OpenSSHのアップデートにより、毎回パスワード入力を求められるようになった場合は以下の設定を疑ってみてください。


問題の症状：
OpenSSHパッケージを最新版にアップデートすると発生するようになった問題です。ssh-agentを起動してssh-addで鍵を正しく登録しているにも関わらず、sshコマンドを実行する度に"password:"というプロンプトが表示されてパスワードの入力を求められてしまいます。


環境：
問題に遭遇＆解決した私のcygwin環境では以下のバージョンで問題が発生することを確認しました。

OpenSSH_7.0p1, OpenSSL 1.0.2d 9 Jul 2015
OpenSSH_7.1p1, OpenSSL 1.0.2d 9 Jul </summary></entry><entry><id>https://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html</id><title type="text">[cygwin] cygwin版X server（XWin）にリモートクライアントから接続できない問題の対処方法</title><updated>2015-09-02T23:09:07.989+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html"/><summary type="text">cygwinを最新バージョンにアップデートしたところ、リモートのX clientからwindows上のcygwin版X serverに接続できなくなってしまいました。
対処方法は簡単でXWin起動時に"-listen tcp"オプションを付けてあげればよいだけです。cygwinバージョンアップ前にはオプション指定なしで接続できていたため、デフォルトの設定が変わったのだと思われます。


cygwin環境：
uname -aで表示されるcygwinバージョン情報です。

% uname -a
CYGWIN_NT-6.1 xxx 2.2.1(0.289/5/3) 2015-08-20 11:42 x86_64 Cygwin



問題発生時の症状：
クライアント側で起動したxtermをサーバー側で表示しようとすると、以下のようなエラーになっていました。
% xterm
xterm Xt </summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/08/30/210019</id><title type="text">カリー化</title><updated>2015-08-30T21:00:19+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/08/30/210019"/><summary type="html">鍋にオリーブオイルを入れる。 にんにくを細切りにし、入れる。しょうがを少しすりおろす。いつもの流れである。 玉ねぎの半分をみじん切りにし、鍋に入れ、しばらく炒める。 キャベツ、にんじん、ヒラタケ、残りの玉ねぎ、じゃがいも(皮ごと)を大き目に切り、蓋をしつつ少し間隔を置いて順に入れる。 しばらくしたあと、鶏肉を入れる。少量のクレイジーソルトとバターも入れた。 水は少しだけ加え、他は素材の水分に頼る。Vita Craftの性能に期待を寄せる。 ビタクラフトオフィシャルサイト｜全面多層鍋の無水調理で実証www.vitacraft.co.jp 市販のカレールウをある程度分割し、まぶすように入れる。6分…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/08/23/145932</id><title type="text">最近作った料理(簡単さ順)</title><updated>2015-08-23T14:59:32+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/08/23/145932"/><summary type="html">面倒なので写真はなし。 ミニマリスティック卵スープ 鍋で水を沸かす。 創味シャンタンを1人あたり小さじ半分ほど入れる。塩で味を補う。 溶き卵を乱暴に投入する。 賞味期限の近い具材を消費するためのチャーハン ごま油とサラダ油を強火で熱したフライパンに入れる。 溶き卵を乱暴に投入する。 数秒後にご飯を投入する。 ねぎと薄く切ったにんにくを入れる。 創味シャンタンを小さじ半分入れる。 適当な具材を入れる。賞味期限が切れそうだったソーセージとキムチを入れた。 醤油と黒胡椒で味を調える。 牛丼 ごま油とサラダ油をフライパンに入れる。 みじん切りにしたにんにく、少量のおろししょうがを加える。 ここで七味唐…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html</id><title type="text">[cygwin][emacs] cygwin版emacsでgtagsを使えるようにする方法</title><updated>2015-08-17T00:49:02.649+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html"/><summary type="text">これまでタグジャンプにはctagsを用いていたのですが、gtagsの「呼び出し元も一覧できる」という機能に惹かれてセットアップしてみました。いくつかはまりポイントがあったのでその対応方法も含め、手順を残しておきます。
cgwin提供のパッケージにはgtagsは含まれていなかったため、自前でビルドすることにしました。


目次：

gatgsの特徴
gtagsのインストール手順
emacsの設定
gtagsの使い方




gtagsの特徴：

良い点！

関数の呼び出し元を一覧表示しジャンプできる（gtags-find-rtag）
関数だけでなく、ローカル変数を含む任意のシンボルをタグジャンプできる（gtags-find-symbol）

正規表現で一覧絞り込み可能（gtags-find-pattern）
開いているファイルで絞り込み可能（gtags-parsefiile）

特定文字列</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/08/01/203751</id><title type="text">第十二回渋谷 Java で Featherweight Java の話をしてきました</title><updated>2015-08-01T20:37:51+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/08/01/203751"/><summary type="html">8 月 1 日に行われた第十二回渋谷 Java で Java の型システムについて LT をしてきました。以下が使用したスライドです。 Hello, Type Systems! - Introduction to Featherweight Java from y_taka_23 ちなみに Featherweight Java を導入した論文はここで読めます。今回の LT では時間の都合上細かい内容をほとんど述べていないので、もし興味があればぜひ元論文に目を通してみると面白いと思います。なお LT で扱ったのは第 2 章で述べられている（ジェネリクスを持たない）FJ の部分です。 スライドの補…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/07/26/174136</id><title type="text">稼働中の Docker コンテナ内にファイルを転送するツール Docker Inject を作ってみました</title><updated>2015-07-26T17:41:36+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/07/26/174136"/><summary type="html">ホスト側から run 中の Docker コンテナ内へ、ディレクトリごとコピーします。 y-taka-23/docker-injectgithub.com 背景 Docker を運用している上で、動いているコンテナの中にファイルを送り込みたくなったことはないでしょうか。ないですか？ 残念ながらあるところにはあるのです。とりあえず今回はあるということにして進みます。 docker cp コマンドを使用すれば「コンテナからホストへ」のファイル転送は可能ですが、逆に「ホストからコンテナへ」の転送手段は公式では提供されていないはずです。docker run 時に -v オプションを付けておいて、マウン…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/07/22/PureScript_ver__0_7_0_%E4%BB%A5%E4%B8%8A%E3%81%A7_%22%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%22_Hello%2C_World%21</id><title type="text">PureScript ver. 0.7.0 以上で “ブラウザーで” Hello, World!</title><updated>2015-07-22T11:24:59+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/07/22/PureScript_ver__0_7_0_%E4%BB%A5%E4%B8%8A%E3%81%A7_%22%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%22_Hello%2C_World%21"/><summary type="html">先日の記事では Node で Hello, World! するところまでできた。では、それをブラウザーで動かすにはどうするんだって思って調べてうまくいったのでまとめる。 CommonJS psc コマンドで吐いた Javascript には require 関数が使われてて複数のファイルに分かれていてこいつどうするんだって思ってたんだけど、これは CommonJS っていう仕様なのね。ブラウザーは CommonJS に対応してないので（全部がそうか調べたわけじゃないけど）こいつをなくす変換をする必要がある。 Browserify 「require ブラウザー」とかで検索すると Browseri…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/07/14/223329</id><title type="text">lensパッケージのオプティクス(弱い順)</title><updated>2015-07-14T22:33:29+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/07/14/223329"/><summary type="html">lensではオプティクスと呼ばれる様々な構造が定義されている。これらの関係を把握していれば、ドキュメントから欲しいものを見つけるのが楽になる。この記事では弱い順にオプティックの数々を紹介していく。 Fold type Fold s a = forall f. (Applicative f, Contravariant f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s Contravariantがついているのでわかりにくいが、これは本質的に以下の型と等価だ。mappendは*&gt;、memptyはfmap absurd $ contramap absurd $ pure ()に相当する。 t…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/06/subversion.html</id><title type="text">[subversion] 特定ディレクトリ以下をサーバーとの同期対象から除外する方法</title><updated>2015-06-26T13:55:24.651+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/06/subversion.html"/><summary type="text">subversionでチェックアウトした作業コピー内の特定ディレクトリ以下をサーバーとの同期対象から除外したい、ということを考えたことはないでしょうか。
例えば、リポジトリの特定ディレクトリ以下に自分にとって不要なファイルやアーカイブが多数コミットされていると、以下のような無駄が生じます。これらの無駄をなくしたい、というのが主なユースケースです。

不要なファイル・アーカイブによってディスクスペースが占有される
サーバー上に更新が発生した際にupdateに余計な時間がかかってしまう



単純に特定ディレクトリ以下の作業ファイルを削除してしまうと、コミット時に差分として検知されてしまう、また、次回以降のupdateコマンドで再ダウンロードされてしまう、という非常に残念な挙動になります。

このようなケースでは以下の方法を使えば、差分が検知されない状態で所定ディレクトリ以下のファイルを削除</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/06/22/162833</id><title type="text">Haskellの型クラスを活用する</title><updated>2015-06-22T16:30:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/06/22/162833"/><summary type="html">Haskellの型クラスは、うまく使えば高いパフォーマンスと抽象度を両立できる、優れた仕組みである。その使い方のコツは、決して理解の難しいものではない。 小さな性質、大きな恩恵 プログラマは大きなものを小さく見せがちだ。オブジェクト指向プログラミングに慣れている人がやりがちなアンチパターンとして、欲しい機能と、それを分割する基準が現実に寄りすぎていて、一つ一つが巨大というものがある。 普通のプログラミングではありえない例かもしれないが、たとえば家を作りたいことを考える。「ベッド」「箪笥」「台所」「冷蔵庫」「トイレ」「風呂」のように設備ごとに分けた抽象化をしたいと考えるだろう。確かにこれは理に適…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/06/21/200416</id><title type="text">Dockerfile をパラメータ化するツール VoicePipe を作ってみました</title><updated>2015-06-21T20:04:16+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/06/21/200416"/><summary type="html">ひとつの Dockerfile から複数の Docker イメージをビルドすることができます。 y-taka-23/voicepipegithub.com 背景 インフラ環境まわりを Docker 化している場合、しばしば複数の Docker イメージを同時並行的に管理する必要が生じます。例えばミドルウェアのバージョンの組み合わせをいろいろ試したいとか、開発環境と本番環境とで設定を変えたいとか。 一方、一般的にイメージとしてビルドされる情報はすべて Dockerfile に記述されており、docker build コマンドの際にはパラメータを渡すことができないため、いきおい、一部分だけ異なる …</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/05/01/TEX_Yoda_TrackPoint_Keyboard_%E3%81%8C%E6%9D%A5%E3%81%9F%EF%BC%86%E7%B5%84%E3%81%BF%E7%AB%8B%E3%81%A6%E3%81%9F</id><title type="text">TEX Yoda TrackPoint Keyboard が来た＆組み立てた</title><updated>2015-05-07T17:18:42+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/05/01/TEX_Yoda_TrackPoint_Keyboard_%E3%81%8C%E6%9D%A5%E3%81%9F%EF%BC%86%E7%B5%84%E3%81%BF%E7%AB%8B%E3%81%A6%E3%81%9F"/><summary type="html">トラックポイントが付いてて Cherry MX スイッチなキーボードがクラウドファンディングで買えたのでポチった。 TEX Yoda TrackPoint Keyboard ってやつです。 特徴としては下記な感じ。 Cherry MX スイッチ（注文時に何色か選べる） トラックポイント 自分で組み立て（追加料金で組み立て済みもあった） 1月30日に購入して4月3日にアメリカ合衆国から発送されてドイツ経由で到着が4月15日。事業を始めたいっていうクラウドファンディングじゃなくて共同購入みたいな感じで購入者が多くなるほど廉くなるっていうしくみで、お値段 $199.99、送料込みで $261.47 …</summary></entry><entry><id>http://lotz84.github.io/posts/published_haskell_by_example.html</id><title type="text">Haskell by Exampleを公開しました</title><updated>2015-05-06T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/published_haskell_by_example.html"/><summary type="html"></summary></entry><entry><id>http://lotz84.github.io/posts/build-chat-server-on-haskell.html</id><title type="text">Haskellでチャットサーバーを建ててみた</title><updated>2015-04-27T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/build-chat-server-on-haskell.html"/><summary type="html"></summary></entry><entry><id>http://lotz84.github.io/posts/unity-hands-on-session-at-camphor.html</id><title type="text">Unityハンズオン勉強会に参加しました@CAMPHOR-</title><updated>2015-04-25T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/unity-hands-on-session-at-camphor.html"/><summary type="html"></summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/17/125213</id><title type="text">最近やったこと</title><updated>2015-04-20T18:52:24+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/17/125213"/><summary type="html">最近やったことのまとめ。 CPSのモナド変換子 モナド変換子の速さを測ってみる - モナドとわたしとコモナドfumieval.hatenablog.com で作ったmtl-cの塵を払い、Hackageにリリースした。 StateTやWriterTは中でタプルを作ったり壊したりしているが、CPS変換するとそれがなくなり、しかも(&gt;&gt;=)も最適化されるためそれなりのパフォーマンスの向上が期待できる。モナドガチユーザにおすすめだ。 補足 GHC 7.10.1現在、StateTに関しては最適化がうまく効くらしく、Lazy、Strict、CPS版のパフォーマンスはほぼ同じだった。一方、CPS版Write…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/06/173848</id><title type="text">Haskellでいかに多態を表すか</title><updated>2015-04-06T17:46:12+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/06/173848"/><summary type="html">オブジェクト指向を行使する心 ではオブジェクト指向の必要性と仕組みについて議論した。 インスタンスは言語によって様々な実装方法があるが、大きく分けて「クラス(処理)のインデックス」か「処理そのもの」のどちらかがインスタンスの内部に隠れている。 と述べたが、Haskellの場合、クラスのインデックスに基づいた表現では、インターフェイスは型クラス、クラスはインスタンス、インスタンスは存在量化された型の値に対応する。…といってもややこしいことこの上ないので、実装例を考えてみよう。 まず、問題となっている愚直な実装は、Haskellではこんな感じだ。 data World = World { … } …</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/06/141523</id><title type="text">オブジェクト指向を行使する心</title><updated>2015-04-06T14:16:10+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/06/141523"/><summary type="html">今日、とあるツイートでプログラミングにおけるよくある問題が顕現していた。 プログラミングしてそうなサークル探したら、ゲーム公開してて、ソースコード公開されてたから見た。 pic.twitter.com/7W09sb9DFa— タコス(祭り) (@tacosufestival) 2015, 4月 4 奇妙な行コメントには目を瞑るとして、このコードは要約すれば以下のような処理を実現していることが窺える。 ゲームプログラミングでは、現在のシーンによって処理を切り替える必要がある。メニュー画面ならメニューの処理を、戦闘画面なら戦闘を、マップならマップの表示をそれぞれ行う。 現在のシーンの種類は変数によ…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html</id><title type="text">[windows][haskell] Widnwos環境でHaskell Platformを完全削除する方法</title><updated>2015-04-05T01:53:40.022+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html"/><summary type="text">Windows上でHaskell Platformを完全削除する方法です。
LinuxやMac環境についてはネット上に多数情報がありますが、Windows環境についてはそれが見当たらなかったため、本エントリにまとめておきます。確認した環境はWindows 8.1＋Haslell Platform 2014.2.0.0です。


削除手順：
Windows環境では以下の手順でHaskell Platformを完全に削除できます。

Haskell Platformのアンインストール

[コントロールパネル] - [プログラム] - [プログラムと機能]を開く
"Haslell Platform 2014.2.0.0"を選択して[アンインストール]を実行

ユーザー領域に作成されたパッケージ関連ファイルの削除

手動（エクスプローラ、rmコマンドなど）で次の２つのディレクトリ以下を完全に削除</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/03/20/155326</id><title type="text">モノイドと継続渡しの道具箱</title><updated>2015-03-21T06:54:08+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/03/20/155326"/><summary type="html">関数型言語Haskellにおいて、普通は計算の結果は関数の戻り値として扱うが、「結果を受け取る関数」 に渡すという継続渡しというスタイルもある。これは単なる冗長なやり方ではなく、様々な興味深い性質を持つ。 基本形は、aという値を渡すところを ∀r. (a -&gt; r) -&gt; r のような表現にする。たとえば、与えられた数の42倍を渡したいとき、そのまま\x -&gt; x * 42ではなく、\x f -&gt; f (x * 42)と書く。もちろんこれだけではありがたみが分からない。 さて、与えられた文字列の中のうち、大文字のアルファベットを取り出し、それがアルファベットの何番目か計算するプログラムを作りた…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/03/08/214505</id><title type="text">Haskellにおけるたった一つのデザインパターン</title><updated>2015-03-08T21:45:05+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/03/08/214505"/><summary type="html">デザインパターンを作らないこと。型とクラスがあんたの武器だ。</summary></entry><entry><id>http://lotz84.github.io/posts/the-way-of-separate-compilation-in-swift.html</id><title type="text">Swift で分割コンパイルする方法</title><updated>2015-02-07T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/the-way-of-separate-compilation-in-swift.html"/><summary type="html"></summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/02/05/174342</id><title type="text">出、出～～ｗｗｗｗｗ銀行員待行列解説奴～ｗｗｗｗｗｗｗ</title><updated>2015-02-06T14:16:34+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/02/05/174342"/><summary type="html">銀行員待行列(Banker's deque)、二つのリストで構成奴～～ｗｗｗｗｗ 入奴と出奴～ｗｗｗｗｗｗｗｗｗ ↓入奴 三(^o^)ノ [(^o^)ノ, (^o^)ノ, (^o^)ノ] ヽ(^o^)三 [ヽ(^o^), ヽ(^o^), ヽ(^o^)] ↑出奴 追加は入奴にcons、取り出しは出奴にuncons奴～ｗｗｗリストなので基本定数時間奴～ｗｗｗｗｗｗ リスト枯渇防止の為、リストの長さに以下の条件課奴～～～ｗｗｗｗｗｗ length (入奴) &lt;= length (出奴) * 3 + 1 length (出奴) &lt;= length (入奴) * 3 + 1 条件充足不能場合、|leng…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2014/12/15/220409</id><title type="text">NGK2014B で SPIN について話してきました</title><updated>2014-12-15T22:04:09+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2014/12/15/220409"/><summary type="html">名古屋工業大学で行われた LT 大会 NGK2014B で発表しました。内容はタイトルそのままで、モデル検査ツール SPIN とその記述言語である Promela の特徴を概観する、というものです。 猫でもわかる！ モデル検査器 SPIN 入門 from y_taka_23 当日の動画は Youtube から見ることができます。ちなみに、発表順は乱数で決められているはずなのですが、なぜか去年の NGK と全く同じ 3 番目でした。 リソース共有問題の Promela モデル LT の冒頭に登場するリソース共有時のデッドロックについて、Promela で記述したモデルが Gist においてありま…</summary></entry><entry><id>http://lotz84.github.io/posts/use-selenium-by-haskell.html</id><title type="text">HaskellでSeleniumを使ってみる＠勉強会</title><updated>2014-12-14T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/use-selenium-by-haskell.html"/><summary type="html"></summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2014/12/08/Krile_%E3%82%92%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B%E6%89%8B%E9%A0%86</id><title type="text">Krile をビルドする手順</title><updated>2014-12-08T23:38:16+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2014/12/08/Krile_%E3%82%92%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B%E6%89%8B%E9%A0%86"/><summary type="html">この記事は Krile Advent Calendar 2014 の8日目の（7本目の）記事です。 ふと、Krile をビルドしてみようかなと思いました。せっかちな人は最後の項だけ見ればいいです。ここに書いてあるのは最短手順ではないです。自分のしたことを辿っています。 きっかけ Krile Advent Calendar 2014 を見付けます。Visual Studio Community 2013 がとりあえずインストールだけされてあります。 ソースコードを落とす GitHub にソースコードがあります。Git 環境は適当に調えなさい。 $ git clone git@github.com…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2014/12/01/234509</id><title type="text">最近ミニ四駆がアツすぎるんだが #mini4wd</title><updated>2014-12-01T23:51:24+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2014/12/01/234509"/><summary type="html">この記事はミニ四駆アドベントカレンダー 2014 の1日目の記事です。 「『ミニ四駆』そういえばそんなものもあったなぁ」という人向けに、「最近こんなんなっとんねんで」というのを伝えられたらなぁと思って書いています。 【おさらい】そもそもミニ四駆とは こんなコースで こんな模型を走らせます。 手を離したら見守るだけ 事前のセッティングが命 な遊びです。 15年前、25年前に2度のブームがあり、ダッシュ四駆太郎や爆走兄弟レッツ＆ゴー！！などの漫画・アニメがはやりました。 ダッシュ!四駆郎 第1巻 (てんとう虫コミックス)作者: 徳田ザウルス出版社/メーカー: 小学館発売日: 1988/05メディア…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/02/03/133158</id><title type="text">Coq で Quine</title><updated>2013-03-11T23:24:40+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/02/03/133158"/><summary type="html">Coq で自己出力プログラム、いわゆる Quine を作成してみました。全体の流れとしては情報処理学会の連載「自分自身を出力するプログラム」の Haskell 版を参考にしてあります。今回のコードは短いので記事の最後に全体を載せてありますが、一応いつものごとく Gist 上 https://gist.github.com/4700318 にも同じものを置いておきました。 Coq の特性あれこれ Quine なるものを初めて聞いた人は wikipedia:クワイン_(プログラミング) あたりを見てみましょう。「自分自身のソースコードを標準出力する。ただし空ファイルでなく、入力は受け付けない」とい…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/01/27/201809</id><title type="text">Coq でクイックソート (3)</title><updated>2013-01-27T20:18:09+09:00</updated><author><name>チェシャ猫</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/01/27/201809"/><summary type="html">Coq でクイックソートの検証、三回目です。今回は最後に残った部分をちょろっとだけ埋めましょう。コードは前回、前々回に追記する形で、https://gist.github.com/4526374 に置いてありますのでよかったらご参照を。 アルゴリズムの定義 仕様の検証その 1 仕様の検証その 2 (この記事) 今回の目標 今回は、最後に残った qsort の二つ目の仕様 出力が入力の置換 (並び替え) になっていること を証明します。モジュール Sorting.Permutation を使いましょう。前回の Sorted に比べ、Permutation はリスト操作とそれなりに相性がよく、証明…</summary></entry></feed>